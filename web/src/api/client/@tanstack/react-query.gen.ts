// This file is auto-generated by @hey-api/openapi-ts

import { type Options, getAiBoilerplates, getAiModels, postAiByProjectIdChat, getAiByProjectIdConversations, postAiByProjectIdConversations, getAiByProjectIdConversationsByConversationId, getAiByProjectIdConversationsByConversationIdExport, postAiByProjectIdConversationsByConversationIdSummarize, getAuditLogs, getAuditLogsById, postAuthChangePassword, postAuthLogin, postAuthLogout, getAuthMe, getBackups, postBackups, getBackupsSchedules, postBackupsSchedules, deleteBackupsSchedulesById, getBackupsSchedulesById, putBackupsSchedulesById, putBackupsSchedulesByIdDisable, putBackupsSchedulesByIdEnable, getBackupsTargets, postBackupsTargets, deleteBackupsTargetsById, getBackupsTargetsById, putBackupsTargetsById, deleteBackupsById, getBackupsById, getChaincodeProjects, postChaincodeProjects, deleteChaincodeProjectsById, getChaincodeProjectsById, getChaincodeProjectsByIdCommits, getChaincodeProjectsByIdCommitsByCommitHash, getChaincodeProjectsByIdDiff, getChaincodeProjectsByIdDownload, putChaincodeProjectsByIdEndorsementPolicy, getChaincodeProjectsByIdFileAtCommit, postChaincodeProjectsByIdInvoke, getChaincodeProjectsByIdLogs, getChaincodeProjectsByIdLogsStream, getChaincodeProjectsByIdMetadata, postChaincodeProjectsByIdQuery, postChaincodeProjectsByIdStart, postChaincodeProjectsByIdStop, postDummy, getKeyProviders, postKeyProviders, deleteKeyProvidersById, getKeyProvidersById, getKeys, postKeys, getKeysAll, getKeysFilter, deleteKeysById, getKeysById, postKeysByKeyIdSign, postKeysByKeyIdSignData, getMetricsDefaults, postMetricsDeploy, getMetricsLogs, getMetricsNodeById, getMetricsNodeByIdLabelByLabelValues, postMetricsNodeByIdQuery, getMetricsNodeByIdRange, getMetricsPortByPortCheck, postMetricsRefresh, postMetricsReload, postMetricsStart, getMetricsStatus, postMetricsStop, postMetricsUndeploy, getNetworksBesu, postNetworksBesu, postNetworksBesuImport, deleteNetworksBesuById, getNetworksBesuById, getNetworksBesuByIdMap, getNetworksFabric, postNetworksFabric, getNetworksFabricByNameByName, postNetworksFabricImport, postNetworksFabricImportWithOrg, deleteNetworksFabricById, getNetworksFabricById, postNetworksFabricByIdAnchorPeers, getNetworksFabricByIdBlocks, getNetworksFabricByIdBlocksByBlockNum, getNetworksFabricByIdChannelConfig, getNetworksFabricByIdCurrentChannelConfig, getNetworksFabricByIdInfo, getNetworksFabricByIdMap, getNetworksFabricByIdNodes, postNetworksFabricByIdNodes, deleteNetworksFabricByIdOrderersByOrdererId, postNetworksFabricByIdOrderersByOrdererIdJoin, postNetworksFabricByIdOrderersByOrdererIdUnjoin, postNetworksFabricByIdOrganizationCrl, getNetworksFabricByIdOrganizationsByOrgIdConfig, deleteNetworksFabricByIdPeersByPeerId, postNetworksFabricByIdPeersByPeerIdJoin, postNetworksFabricByIdPeersByPeerIdUnjoin, postNetworksFabricByIdReloadBlock, getNetworksFabricByIdTransactionsByTxId, postNetworksFabricByIdUpdateConfig, putNetworksByIdGenesis, getNodes, postNodes, getNodesDefaultsBesuNode, getNodesDefaultsFabric, getNodesDefaultsFabricOrderer, getNodesDefaultsFabricPeer, getNodesPlatformByPlatform, deleteNodesById, getNodesById, putNodesById, postNodesByIdCertificatesRenew, getNodesByIdChannels, getNodesByIdChannelsByChannelIdChaincodes, getNodesByIdEvents, getNodesByIdLogs, postNodesByIdRestart, getNodesByIdRpcAccounts, getNodesByIdRpcBalance, getNodesByIdRpcBlockByHash, getNodesByIdRpcBlockByNumber, getNodesByIdRpcBlockNumber, getNodesByIdRpcBlockTransactionCountByHash, getNodesByIdRpcBlockTransactionCountByNumber, getNodesByIdRpcChainId, getNodesByIdRpcCode, getNodesByIdRpcFeeHistory, postNodesByIdRpcLogs, getNodesByIdRpcPendingTransactions, getNodesByIdRpcProtocolVersion, postNodesByIdRpcQbftDiscardValidatorVote, getNodesByIdRpcQbftPendingVotes, postNodesByIdRpcQbftProposeValidatorVote, getNodesByIdRpcQbftRequestTimeout, getNodesByIdRpcQbftSignerMetrics, getNodesByIdRpcQbftValidatorsByBlockHash, getNodesByIdRpcQbftValidatorsByBlockNumber, getNodesByIdRpcStorage, getNodesByIdRpcSyncing, getNodesByIdRpcTransactionByBlockHashAndIndex, getNodesByIdRpcTransactionByBlockNumberAndIndex, getNodesByIdRpcTransactionByHash, getNodesByIdRpcTransactionCount, getNodesByIdRpcTransactionReceipt, postNodesByIdStart, postNodesByIdStop, getNotificationsProviders, postNotificationsProviders, deleteNotificationsProvidersById, getNotificationsProvidersById, putNotificationsProvidersById, postNotificationsProvidersByIdTest, getOrganizations, postOrganizations, getOrganizationsByMspidByMspid, deleteOrganizationsById, getOrganizationsById, putOrganizationsById, getOrganizationsByIdCrl, postOrganizationsByIdCrlRevokePem, deleteOrganizationsByIdCrlRevokeSerial, postOrganizationsByIdCrlRevokeSerial, getOrganizationsByIdKeys, postOrganizationsByIdKeys, postOrganizationsByIdKeysRenew, deleteOrganizationsByIdKeysByKeyId, getOrganizationsByIdKeysByKeyId, getOrganizationsByIdRevokedCertificates, getPlugins, postPlugins, getPluginsAvailable, postPluginsAvailableRefresh, deletePluginsByName, getPluginsByName, putPluginsByName, postPluginsByNameDeploy, getPluginsByNameDeploymentStatus, postPluginsByNameResume, getPluginsByNameServices, getPluginsByNameStatus, postPluginsByNameStop, postProjectsByProjectIdDirsCreate, deleteProjectsByProjectIdDirsDelete, getProjectsByProjectIdDirsList, deleteProjectsByProjectIdFilesDelete, getProjectsByProjectIdFilesEntries, getProjectsByProjectIdFilesList, getProjectsByProjectIdFilesRead, postProjectsByProjectIdFilesWrite, postScBesuDeploy, getScFabricChaincodes, postScFabricChaincodes, getScFabricChaincodesByChaincodeIdDefinitions, postScFabricChaincodesByChaincodeIdDefinitions, getScFabricChaincodesByChaincodeIdDefinitionsByDefinitionId, postScFabricChaincodesByChaincodeIdInvoke, getScFabricChaincodesByChaincodeIdMetadata, postScFabricChaincodesByChaincodeIdQuery, deleteScFabricChaincodesById, getScFabricChaincodesById, deleteScFabricDefinitionsByDefinitionId, putScFabricDefinitionsByDefinitionId, postScFabricDefinitionsByDefinitionIdApprove, postScFabricDefinitionsByDefinitionIdCommit, postScFabricDefinitionsByDefinitionIdDeploy, getScFabricDefinitionsByDefinitionIdDockerInfo, postScFabricDefinitionsByDefinitionIdInstall, getScFabricDefinitionsByDefinitionIdTimeline, postScFabricDefinitionsByDefinitionIdUndeploy, postScFabricDeploy, postScFabricPeerByPeerIdChaincodeApprove, postScFabricPeerByPeerIdChaincodeCommit, postScFabricPeerByPeerIdChaincodeInstall, getScFabricPeerByPeerIdChaincodeSequence, getSettings, postSettings, getUsers, postUsers, deleteUsersById, getUsersById, putUsersById, putUsersByIdPassword, putUsersByIdRole } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, infiniteQueryOptions, type InfiniteData, type DefaultError } from '@tanstack/react-query';
import type { GetAiBoilerplatesData, GetAiModelsData, PostAiByProjectIdChatData, PostAiByProjectIdChatError, PostAiByProjectIdChatResponse, GetAiByProjectIdConversationsData, PostAiByProjectIdConversationsData, PostAiByProjectIdConversationsError, PostAiByProjectIdConversationsResponse, GetAiByProjectIdConversationsByConversationIdData, GetAiByProjectIdConversationsByConversationIdExportData, PostAiByProjectIdConversationsByConversationIdSummarizeData, PostAiByProjectIdConversationsByConversationIdSummarizeError, PostAiByProjectIdConversationsByConversationIdSummarizeResponse, GetAuditLogsData, GetAuditLogsError, GetAuditLogsResponse, GetAuditLogsByIdData, PostAuthChangePasswordData, PostAuthChangePasswordError, PostAuthChangePasswordResponse, PostAuthLoginData, PostAuthLoginError, PostAuthLoginResponse, PostAuthLogoutData, PostAuthLogoutError, PostAuthLogoutResponse, GetAuthMeData, GetBackupsData, PostBackupsData, PostBackupsError, PostBackupsResponse, GetBackupsSchedulesData, PostBackupsSchedulesData, PostBackupsSchedulesError, PostBackupsSchedulesResponse, DeleteBackupsSchedulesByIdData, DeleteBackupsSchedulesByIdError, GetBackupsSchedulesByIdData, PutBackupsSchedulesByIdData, PutBackupsSchedulesByIdError, PutBackupsSchedulesByIdResponse, PutBackupsSchedulesByIdDisableData, PutBackupsSchedulesByIdDisableError, PutBackupsSchedulesByIdDisableResponse, PutBackupsSchedulesByIdEnableData, PutBackupsSchedulesByIdEnableError, PutBackupsSchedulesByIdEnableResponse, GetBackupsTargetsData, PostBackupsTargetsData, PostBackupsTargetsError, PostBackupsTargetsResponse, DeleteBackupsTargetsByIdData, DeleteBackupsTargetsByIdError, GetBackupsTargetsByIdData, PutBackupsTargetsByIdData, PutBackupsTargetsByIdError, PutBackupsTargetsByIdResponse, DeleteBackupsByIdData, DeleteBackupsByIdError, GetBackupsByIdData, GetChaincodeProjectsData, PostChaincodeProjectsData, PostChaincodeProjectsError, PostChaincodeProjectsResponse, DeleteChaincodeProjectsByIdData, DeleteChaincodeProjectsByIdError, DeleteChaincodeProjectsByIdResponse, GetChaincodeProjectsByIdData, GetChaincodeProjectsByIdCommitsData, GetChaincodeProjectsByIdCommitsError, GetChaincodeProjectsByIdCommitsResponse, GetChaincodeProjectsByIdCommitsByCommitHashData, GetChaincodeProjectsByIdDiffData, GetChaincodeProjectsByIdDownloadData, PutChaincodeProjectsByIdEndorsementPolicyData, PutChaincodeProjectsByIdEndorsementPolicyError, PutChaincodeProjectsByIdEndorsementPolicyResponse, GetChaincodeProjectsByIdFileAtCommitData, PostChaincodeProjectsByIdInvokeData, PostChaincodeProjectsByIdInvokeError, PostChaincodeProjectsByIdInvokeResponse, GetChaincodeProjectsByIdLogsData, GetChaincodeProjectsByIdLogsStreamData, GetChaincodeProjectsByIdMetadataData, PostChaincodeProjectsByIdQueryData, PostChaincodeProjectsByIdQueryError, PostChaincodeProjectsByIdQueryResponse, PostChaincodeProjectsByIdStartData, PostChaincodeProjectsByIdStartError, PostChaincodeProjectsByIdStartResponse, PostChaincodeProjectsByIdStopData, PostChaincodeProjectsByIdStopError, PostChaincodeProjectsByIdStopResponse, PostDummyData, PostDummyResponse, GetKeyProvidersData, PostKeyProvidersData, PostKeyProvidersError, PostKeyProvidersResponse, DeleteKeyProvidersByIdData, DeleteKeyProvidersByIdError, GetKeyProvidersByIdData, GetKeysData, GetKeysError, GetKeysResponse, PostKeysData, PostKeysError, PostKeysResponse, GetKeysAllData, GetKeysFilterData, GetKeysFilterError, GetKeysFilterResponse, DeleteKeysByIdData, DeleteKeysByIdError, GetKeysByIdData, PostKeysByKeyIdSignData, PostKeysByKeyIdSignError, PostKeysByKeyIdSignResponse, PostKeysByKeyIdSignDataData, PostKeysByKeyIdSignDataError, PostKeysByKeyIdSignDataResponse, GetMetricsDefaultsData, PostMetricsDeployData, PostMetricsDeployError, PostMetricsDeployResponse, GetMetricsLogsData, GetMetricsNodeByIdData, GetMetricsNodeByIdLabelByLabelValuesData, PostMetricsNodeByIdQueryData, PostMetricsNodeByIdQueryError, PostMetricsNodeByIdQueryResponse, GetMetricsNodeByIdRangeData, GetMetricsNodeByIdRangeError, GetMetricsNodeByIdRangeResponse, GetMetricsPortByPortCheckData, PostMetricsRefreshData, PostMetricsRefreshError, PostMetricsRefreshResponse, PostMetricsReloadData, PostMetricsReloadError, PostMetricsReloadResponse, PostMetricsStartData, PostMetricsStartError, PostMetricsStartResponse, GetMetricsStatusData, PostMetricsStopData, PostMetricsStopError, PostMetricsStopResponse, PostMetricsUndeployData, PostMetricsUndeployError, PostMetricsUndeployResponse, GetNetworksBesuData, GetNetworksBesuError, GetNetworksBesuResponse, PostNetworksBesuData, PostNetworksBesuError, PostNetworksBesuResponse, PostNetworksBesuImportData, PostNetworksBesuImportError, PostNetworksBesuImportResponse, DeleteNetworksBesuByIdData, DeleteNetworksBesuByIdError, GetNetworksBesuByIdData, GetNetworksBesuByIdMapData, GetNetworksFabricData, GetNetworksFabricError, GetNetworksFabricResponse, PostNetworksFabricData, PostNetworksFabricError, PostNetworksFabricResponse, GetNetworksFabricByNameByNameData, PostNetworksFabricImportData, PostNetworksFabricImportError, PostNetworksFabricImportResponse, PostNetworksFabricImportWithOrgData, PostNetworksFabricImportWithOrgError, PostNetworksFabricImportWithOrgResponse, DeleteNetworksFabricByIdData, DeleteNetworksFabricByIdError, GetNetworksFabricByIdData, PostNetworksFabricByIdAnchorPeersData, PostNetworksFabricByIdAnchorPeersError, PostNetworksFabricByIdAnchorPeersResponse, GetNetworksFabricByIdBlocksData, GetNetworksFabricByIdBlocksError, GetNetworksFabricByIdBlocksResponse, GetNetworksFabricByIdBlocksByBlockNumData, GetNetworksFabricByIdChannelConfigData, GetNetworksFabricByIdCurrentChannelConfigData, GetNetworksFabricByIdInfoData, GetNetworksFabricByIdMapData, GetNetworksFabricByIdNodesData, PostNetworksFabricByIdNodesData, PostNetworksFabricByIdNodesError, PostNetworksFabricByIdNodesResponse, DeleteNetworksFabricByIdOrderersByOrdererIdData, DeleteNetworksFabricByIdOrderersByOrdererIdError, DeleteNetworksFabricByIdOrderersByOrdererIdResponse, PostNetworksFabricByIdOrderersByOrdererIdJoinData, PostNetworksFabricByIdOrderersByOrdererIdJoinError, PostNetworksFabricByIdOrderersByOrdererIdJoinResponse, PostNetworksFabricByIdOrderersByOrdererIdUnjoinData, PostNetworksFabricByIdOrderersByOrdererIdUnjoinError, PostNetworksFabricByIdOrderersByOrdererIdUnjoinResponse, PostNetworksFabricByIdOrganizationCrlData, PostNetworksFabricByIdOrganizationCrlError, PostNetworksFabricByIdOrganizationCrlResponse, GetNetworksFabricByIdOrganizationsByOrgIdConfigData, DeleteNetworksFabricByIdPeersByPeerIdData, DeleteNetworksFabricByIdPeersByPeerIdError, DeleteNetworksFabricByIdPeersByPeerIdResponse, PostNetworksFabricByIdPeersByPeerIdJoinData, PostNetworksFabricByIdPeersByPeerIdJoinError, PostNetworksFabricByIdPeersByPeerIdJoinResponse, PostNetworksFabricByIdPeersByPeerIdUnjoinData, PostNetworksFabricByIdPeersByPeerIdUnjoinError, PostNetworksFabricByIdPeersByPeerIdUnjoinResponse, PostNetworksFabricByIdReloadBlockData, PostNetworksFabricByIdReloadBlockError, PostNetworksFabricByIdReloadBlockResponse, GetNetworksFabricByIdTransactionsByTxIdData, PostNetworksFabricByIdUpdateConfigData, PostNetworksFabricByIdUpdateConfigError, PostNetworksFabricByIdUpdateConfigResponse, PutNetworksByIdGenesisData, PutNetworksByIdGenesisError, PutNetworksByIdGenesisResponse, GetNodesData, GetNodesError, GetNodesResponse, PostNodesData, PostNodesError, PostNodesResponse, GetNodesDefaultsBesuNodeData, GetNodesDefaultsFabricData, GetNodesDefaultsFabricOrdererData, GetNodesDefaultsFabricPeerData, GetNodesPlatformByPlatformData, GetNodesPlatformByPlatformError, GetNodesPlatformByPlatformResponse, DeleteNodesByIdData, DeleteNodesByIdError, GetNodesByIdData, PutNodesByIdData, PutNodesByIdError, PutNodesByIdResponse, PostNodesByIdCertificatesRenewData, PostNodesByIdCertificatesRenewError, PostNodesByIdCertificatesRenewResponse, GetNodesByIdChannelsData, GetNodesByIdChannelsByChannelIdChaincodesData, GetNodesByIdEventsData, GetNodesByIdEventsError, GetNodesByIdEventsResponse, GetNodesByIdLogsData, PostNodesByIdRestartData, PostNodesByIdRestartError, PostNodesByIdRestartResponse, GetNodesByIdRpcAccountsData, GetNodesByIdRpcBalanceData, GetNodesByIdRpcBlockByHashData, GetNodesByIdRpcBlockByNumberData, GetNodesByIdRpcBlockNumberData, GetNodesByIdRpcBlockTransactionCountByHashData, GetNodesByIdRpcBlockTransactionCountByNumberData, GetNodesByIdRpcChainIdData, GetNodesByIdRpcCodeData, GetNodesByIdRpcFeeHistoryData, PostNodesByIdRpcLogsData, PostNodesByIdRpcLogsError, PostNodesByIdRpcLogsResponse, GetNodesByIdRpcPendingTransactionsData, GetNodesByIdRpcProtocolVersionData, PostNodesByIdRpcQbftDiscardValidatorVoteData, PostNodesByIdRpcQbftDiscardValidatorVoteError, PostNodesByIdRpcQbftDiscardValidatorVoteResponse, GetNodesByIdRpcQbftPendingVotesData, PostNodesByIdRpcQbftProposeValidatorVoteData, PostNodesByIdRpcQbftProposeValidatorVoteError, PostNodesByIdRpcQbftProposeValidatorVoteResponse, GetNodesByIdRpcQbftRequestTimeoutData, GetNodesByIdRpcQbftSignerMetricsData, GetNodesByIdRpcQbftValidatorsByBlockHashData, GetNodesByIdRpcQbftValidatorsByBlockNumberData, GetNodesByIdRpcStorageData, GetNodesByIdRpcSyncingData, GetNodesByIdRpcTransactionByBlockHashAndIndexData, GetNodesByIdRpcTransactionByBlockNumberAndIndexData, GetNodesByIdRpcTransactionByHashData, GetNodesByIdRpcTransactionCountData, GetNodesByIdRpcTransactionReceiptData, PostNodesByIdStartData, PostNodesByIdStartError, PostNodesByIdStartResponse, PostNodesByIdStopData, PostNodesByIdStopError, PostNodesByIdStopResponse, GetNotificationsProvidersData, PostNotificationsProvidersData, PostNotificationsProvidersError, PostNotificationsProvidersResponse, DeleteNotificationsProvidersByIdData, DeleteNotificationsProvidersByIdError, GetNotificationsProvidersByIdData, PutNotificationsProvidersByIdData, PutNotificationsProvidersByIdError, PutNotificationsProvidersByIdResponse, PostNotificationsProvidersByIdTestData, PostNotificationsProvidersByIdTestError, PostNotificationsProvidersByIdTestResponse, GetOrganizationsData, GetOrganizationsError, GetOrganizationsResponse, PostOrganizationsData, PostOrganizationsError, PostOrganizationsResponse, GetOrganizationsByMspidByMspidData, DeleteOrganizationsByIdData, DeleteOrganizationsByIdError, GetOrganizationsByIdData, PutOrganizationsByIdData, PutOrganizationsByIdError, PutOrganizationsByIdResponse, GetOrganizationsByIdCrlData, PostOrganizationsByIdCrlRevokePemData, PostOrganizationsByIdCrlRevokePemError, PostOrganizationsByIdCrlRevokePemResponse, DeleteOrganizationsByIdCrlRevokeSerialData, DeleteOrganizationsByIdCrlRevokeSerialError, DeleteOrganizationsByIdCrlRevokeSerialResponse, PostOrganizationsByIdCrlRevokeSerialData, PostOrganizationsByIdCrlRevokeSerialError, PostOrganizationsByIdCrlRevokeSerialResponse, GetOrganizationsByIdKeysData, PostOrganizationsByIdKeysData, PostOrganizationsByIdKeysError, PostOrganizationsByIdKeysResponse, PostOrganizationsByIdKeysRenewData, PostOrganizationsByIdKeysRenewError, PostOrganizationsByIdKeysRenewResponse, DeleteOrganizationsByIdKeysByKeyIdData, DeleteOrganizationsByIdKeysByKeyIdError, GetOrganizationsByIdKeysByKeyIdData, GetOrganizationsByIdRevokedCertificatesData, GetPluginsData, PostPluginsData, PostPluginsError, PostPluginsResponse, GetPluginsAvailableData, PostPluginsAvailableRefreshData, PostPluginsAvailableRefreshError, PostPluginsAvailableRefreshResponse, DeletePluginsByNameData, DeletePluginsByNameError, GetPluginsByNameData, PutPluginsByNameData, PutPluginsByNameError, PutPluginsByNameResponse, PostPluginsByNameDeployData, PostPluginsByNameDeployError, GetPluginsByNameDeploymentStatusData, PostPluginsByNameResumeData, PostPluginsByNameResumeError, PostPluginsByNameResumeResponse, GetPluginsByNameServicesData, GetPluginsByNameStatusData, PostPluginsByNameStopData, PostPluginsByNameStopError, PostProjectsByProjectIdDirsCreateData, PostProjectsByProjectIdDirsCreateError, PostProjectsByProjectIdDirsCreateResponse, DeleteProjectsByProjectIdDirsDeleteData, DeleteProjectsByProjectIdDirsDeleteError, DeleteProjectsByProjectIdDirsDeleteResponse, GetProjectsByProjectIdDirsListData, DeleteProjectsByProjectIdFilesDeleteData, DeleteProjectsByProjectIdFilesDeleteError, DeleteProjectsByProjectIdFilesDeleteResponse, GetProjectsByProjectIdFilesEntriesData, GetProjectsByProjectIdFilesListData, GetProjectsByProjectIdFilesReadData, PostProjectsByProjectIdFilesWriteData, PostProjectsByProjectIdFilesWriteError, PostProjectsByProjectIdFilesWriteResponse, PostScBesuDeployData, PostScBesuDeployError, PostScBesuDeployResponse, GetScFabricChaincodesData, PostScFabricChaincodesData, PostScFabricChaincodesError, PostScFabricChaincodesResponse, GetScFabricChaincodesByChaincodeIdDefinitionsData, PostScFabricChaincodesByChaincodeIdDefinitionsData, PostScFabricChaincodesByChaincodeIdDefinitionsError, PostScFabricChaincodesByChaincodeIdDefinitionsResponse, GetScFabricChaincodesByChaincodeIdDefinitionsByDefinitionIdData, PostScFabricChaincodesByChaincodeIdInvokeData, PostScFabricChaincodesByChaincodeIdInvokeError, PostScFabricChaincodesByChaincodeIdInvokeResponse, GetScFabricChaincodesByChaincodeIdMetadataData, PostScFabricChaincodesByChaincodeIdQueryData, PostScFabricChaincodesByChaincodeIdQueryError, PostScFabricChaincodesByChaincodeIdQueryResponse, DeleteScFabricChaincodesByIdData, DeleteScFabricChaincodesByIdError, DeleteScFabricChaincodesByIdResponse, GetScFabricChaincodesByIdData, DeleteScFabricDefinitionsByDefinitionIdData, DeleteScFabricDefinitionsByDefinitionIdError, DeleteScFabricDefinitionsByDefinitionIdResponse, PutScFabricDefinitionsByDefinitionIdData, PutScFabricDefinitionsByDefinitionIdError, PutScFabricDefinitionsByDefinitionIdResponse, PostScFabricDefinitionsByDefinitionIdApproveData, PostScFabricDefinitionsByDefinitionIdApproveError, PostScFabricDefinitionsByDefinitionIdApproveResponse, PostScFabricDefinitionsByDefinitionIdCommitData, PostScFabricDefinitionsByDefinitionIdCommitError, PostScFabricDefinitionsByDefinitionIdCommitResponse, PostScFabricDefinitionsByDefinitionIdDeployData, PostScFabricDefinitionsByDefinitionIdDeployError, PostScFabricDefinitionsByDefinitionIdDeployResponse, GetScFabricDefinitionsByDefinitionIdDockerInfoData, PostScFabricDefinitionsByDefinitionIdInstallData, PostScFabricDefinitionsByDefinitionIdInstallError, PostScFabricDefinitionsByDefinitionIdInstallResponse, GetScFabricDefinitionsByDefinitionIdTimelineData, PostScFabricDefinitionsByDefinitionIdUndeployData, PostScFabricDefinitionsByDefinitionIdUndeployError, PostScFabricDefinitionsByDefinitionIdUndeployResponse, PostScFabricDeployData, PostScFabricDeployError, PostScFabricDeployResponse, PostScFabricPeerByPeerIdChaincodeApproveData, PostScFabricPeerByPeerIdChaincodeApproveError, PostScFabricPeerByPeerIdChaincodeApproveResponse, PostScFabricPeerByPeerIdChaincodeCommitData, PostScFabricPeerByPeerIdChaincodeCommitError, PostScFabricPeerByPeerIdChaincodeCommitResponse, PostScFabricPeerByPeerIdChaincodeInstallData, PostScFabricPeerByPeerIdChaincodeInstallError, PostScFabricPeerByPeerIdChaincodeInstallResponse, GetScFabricPeerByPeerIdChaincodeSequenceData, GetSettingsData, PostSettingsData, PostSettingsResponse, GetUsersData, PostUsersData, PostUsersError, PostUsersResponse, DeleteUsersByIdData, DeleteUsersByIdError, GetUsersByIdData, PutUsersByIdData, PutUsersByIdError, PutUsersByIdResponse, PutUsersByIdPasswordData, PutUsersByIdPasswordError, PutUsersByIdPasswordResponse, PutUsersByIdRoleData, PutUsersByIdRoleError, PutUsersByIdRoleResponse } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const getAiBoilerplatesQueryKey = (options: Options<GetAiBoilerplatesData>) => createQueryKey('getAiBoilerplates', options);

/**
 * Get available boilerplates
 * Returns a list of available boilerplates filtered by network platform
 */
export const getAiBoilerplatesOptions = (options: Options<GetAiBoilerplatesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAiBoilerplates({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAiBoilerplatesQueryKey(options)
    });
};

export const getAiModelsQueryKey = (options?: Options<GetAiModelsData>) => createQueryKey('getAiModels', options);

/**
 * Get available AI models
 * Returns a list of available AI models for code generation
 */
export const getAiModelsOptions = (options?: Options<GetAiModelsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAiModels({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAiModelsQueryKey(options)
    });
};

export const postAiByProjectIdChatQueryKey = (options: Options<PostAiByProjectIdChatData>) => createQueryKey('postAiByProjectIdChat', options);

/**
 * Chat with AI assistant
 * Stream a conversation with the AI assistant using Server-Sent Events (SSE)
 */
export const postAiByProjectIdChatOptions = (options: Options<PostAiByProjectIdChatData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postAiByProjectIdChat({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAiByProjectIdChatQueryKey(options)
    });
};

/**
 * Chat with AI assistant
 * Stream a conversation with the AI assistant using Server-Sent Events (SSE)
 */
export const postAiByProjectIdChatMutation = (options?: Partial<Options<PostAiByProjectIdChatData>>): UseMutationOptions<PostAiByProjectIdChatResponse, PostAiByProjectIdChatError, Options<PostAiByProjectIdChatData>> => {
    const mutationOptions: UseMutationOptions<PostAiByProjectIdChatResponse, PostAiByProjectIdChatError, Options<PostAiByProjectIdChatData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postAiByProjectIdChat({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAiByProjectIdConversationsQueryKey = (options: Options<GetAiByProjectIdConversationsData>) => createQueryKey('getAiByProjectIdConversations', options);

/**
 * Get all conversations for a project
 * Returns a list of all chat conversations associated with a specific project
 */
export const getAiByProjectIdConversationsOptions = (options: Options<GetAiByProjectIdConversationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAiByProjectIdConversations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAiByProjectIdConversationsQueryKey(options)
    });
};

export const postAiByProjectIdConversationsQueryKey = (options: Options<PostAiByProjectIdConversationsData>) => createQueryKey('postAiByProjectIdConversations', options);

/**
 * Create a new conversation for a project
 * Creates a new empty conversation for the specified project
 */
export const postAiByProjectIdConversationsOptions = (options: Options<PostAiByProjectIdConversationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postAiByProjectIdConversations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAiByProjectIdConversationsQueryKey(options)
    });
};

/**
 * Create a new conversation for a project
 * Creates a new empty conversation for the specified project
 */
export const postAiByProjectIdConversationsMutation = (options?: Partial<Options<PostAiByProjectIdConversationsData>>): UseMutationOptions<PostAiByProjectIdConversationsResponse, PostAiByProjectIdConversationsError, Options<PostAiByProjectIdConversationsData>> => {
    const mutationOptions: UseMutationOptions<PostAiByProjectIdConversationsResponse, PostAiByProjectIdConversationsError, Options<PostAiByProjectIdConversationsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postAiByProjectIdConversations({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAiByProjectIdConversationsByConversationIdQueryKey = (options: Options<GetAiByProjectIdConversationsByConversationIdData>) => createQueryKey('getAiByProjectIdConversationsByConversationId', options);

/**
 * Get conversation messages
 * Get all messages in a conversation
 */
export const getAiByProjectIdConversationsByConversationIdOptions = (options: Options<GetAiByProjectIdConversationsByConversationIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAiByProjectIdConversationsByConversationId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAiByProjectIdConversationsByConversationIdQueryKey(options)
    });
};

export const getAiByProjectIdConversationsByConversationIdExportQueryKey = (options: Options<GetAiByProjectIdConversationsByConversationIdExportData>) => createQueryKey('getAiByProjectIdConversationsByConversationIdExport', options);

/**
 * Get conversation detail
 * Get detailed information about a conversation including all messages and metadata
 */
export const getAiByProjectIdConversationsByConversationIdExportOptions = (options: Options<GetAiByProjectIdConversationsByConversationIdExportData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAiByProjectIdConversationsByConversationIdExport({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAiByProjectIdConversationsByConversationIdExportQueryKey(options)
    });
};

export const postAiByProjectIdConversationsByConversationIdSummarizeQueryKey = (options: Options<PostAiByProjectIdConversationsByConversationIdSummarizeData>) => createQueryKey('postAiByProjectIdConversationsByConversationIdSummarize', options);

/**
 * Create a new conversation from an existing one with a summary
 * Summarizes an existing conversation and starts a new one with a summary message
 */
export const postAiByProjectIdConversationsByConversationIdSummarizeOptions = (options: Options<PostAiByProjectIdConversationsByConversationIdSummarizeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postAiByProjectIdConversationsByConversationIdSummarize({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAiByProjectIdConversationsByConversationIdSummarizeQueryKey(options)
    });
};

/**
 * Create a new conversation from an existing one with a summary
 * Summarizes an existing conversation and starts a new one with a summary message
 */
export const postAiByProjectIdConversationsByConversationIdSummarizeMutation = (options?: Partial<Options<PostAiByProjectIdConversationsByConversationIdSummarizeData>>): UseMutationOptions<PostAiByProjectIdConversationsByConversationIdSummarizeResponse, PostAiByProjectIdConversationsByConversationIdSummarizeError, Options<PostAiByProjectIdConversationsByConversationIdSummarizeData>> => {
    const mutationOptions: UseMutationOptions<PostAiByProjectIdConversationsByConversationIdSummarizeResponse, PostAiByProjectIdConversationsByConversationIdSummarizeError, Options<PostAiByProjectIdConversationsByConversationIdSummarizeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postAiByProjectIdConversationsByConversationIdSummarize({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAuditLogsQueryKey = (options?: Options<GetAuditLogsData>) => createQueryKey('getAuditLogs', options);

/**
 * List audit logs
 * Retrieves a paginated list of audit logs with optional filters
 */
export const getAuditLogsOptions = (options?: Options<GetAuditLogsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAuditLogs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAuditLogsQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getAuditLogsInfiniteQueryKey = (options?: Options<GetAuditLogsData>): QueryKey<Options<GetAuditLogsData>> => createQueryKey('getAuditLogs', options, true);

/**
 * List audit logs
 * Retrieves a paginated list of audit logs with optional filters
 */
export const getAuditLogsInfiniteOptions = (options?: Options<GetAuditLogsData>) => {
    return infiniteQueryOptions<GetAuditLogsResponse, GetAuditLogsError, InfiniteData<GetAuditLogsResponse>, QueryKey<Options<GetAuditLogsData>>, number | Pick<QueryKey<Options<GetAuditLogsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAuditLogsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAuditLogs({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAuditLogsInfiniteQueryKey(options)
    });
};

export const getAuditLogsByIdQueryKey = (options: Options<GetAuditLogsByIdData>) => createQueryKey('getAuditLogsById', options);

/**
 * Get audit log
 * Retrieves a specific audit log by ID
 */
export const getAuditLogsByIdOptions = (options: Options<GetAuditLogsByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAuditLogsById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAuditLogsByIdQueryKey(options)
    });
};

export const postAuthChangePasswordQueryKey = (options: Options<PostAuthChangePasswordData>) => createQueryKey('postAuthChangePassword', options);

/**
 * Change own password
 * Allows a user to change their own password
 */
export const postAuthChangePasswordOptions = (options: Options<PostAuthChangePasswordData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postAuthChangePassword({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAuthChangePasswordQueryKey(options)
    });
};

/**
 * Change own password
 * Allows a user to change their own password
 */
export const postAuthChangePasswordMutation = (options?: Partial<Options<PostAuthChangePasswordData>>): UseMutationOptions<PostAuthChangePasswordResponse, PostAuthChangePasswordError, Options<PostAuthChangePasswordData>> => {
    const mutationOptions: UseMutationOptions<PostAuthChangePasswordResponse, PostAuthChangePasswordError, Options<PostAuthChangePasswordData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postAuthChangePassword({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postAuthLoginQueryKey = (options: Options<PostAuthLoginData>) => createQueryKey('postAuthLogin', options);

/**
 * Login user
 * Authenticates a user and returns a session cookie
 */
export const postAuthLoginOptions = (options: Options<PostAuthLoginData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postAuthLogin({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAuthLoginQueryKey(options)
    });
};

/**
 * Login user
 * Authenticates a user and returns a session cookie
 */
export const postAuthLoginMutation = (options?: Partial<Options<PostAuthLoginData>>): UseMutationOptions<PostAuthLoginResponse, PostAuthLoginError, Options<PostAuthLoginData>> => {
    const mutationOptions: UseMutationOptions<PostAuthLoginResponse, PostAuthLoginError, Options<PostAuthLoginData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postAuthLogin({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postAuthLogoutQueryKey = (options?: Options<PostAuthLogoutData>) => createQueryKey('postAuthLogout', options);

/**
 * Logout user
 * Invalidates the current session and clears the session cookie
 */
export const postAuthLogoutOptions = (options?: Options<PostAuthLogoutData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postAuthLogout({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postAuthLogoutQueryKey(options)
    });
};

/**
 * Logout user
 * Invalidates the current session and clears the session cookie
 */
export const postAuthLogoutMutation = (options?: Partial<Options<PostAuthLogoutData>>): UseMutationOptions<PostAuthLogoutResponse, PostAuthLogoutError, Options<PostAuthLogoutData>> => {
    const mutationOptions: UseMutationOptions<PostAuthLogoutResponse, PostAuthLogoutError, Options<PostAuthLogoutData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postAuthLogout({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAuthMeQueryKey = (options?: Options<GetAuthMeData>) => createQueryKey('getAuthMe', options);

/**
 * Get current user
 * Returns information about the currently authenticated user
 */
export const getAuthMeOptions = (options?: Options<GetAuthMeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAuthMe({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAuthMeQueryKey(options)
    });
};

export const getBackupsQueryKey = (options?: Options<GetBackupsData>) => createQueryKey('getBackups', options);

/**
 * List all backups
 * Get a list of all backups
 */
export const getBackupsOptions = (options?: Options<GetBackupsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBackups({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBackupsQueryKey(options)
    });
};

export const postBackupsQueryKey = (options: Options<PostBackupsData>) => createQueryKey('postBackups', options);

/**
 * Create a new backup
 * Create a new backup with the specified configuration
 */
export const postBackupsOptions = (options: Options<PostBackupsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postBackups({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postBackupsQueryKey(options)
    });
};

/**
 * Create a new backup
 * Create a new backup with the specified configuration
 */
export const postBackupsMutation = (options?: Partial<Options<PostBackupsData>>): UseMutationOptions<PostBackupsResponse, PostBackupsError, Options<PostBackupsData>> => {
    const mutationOptions: UseMutationOptions<PostBackupsResponse, PostBackupsError, Options<PostBackupsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postBackups({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBackupsSchedulesQueryKey = (options?: Options<GetBackupsSchedulesData>) => createQueryKey('getBackupsSchedules', options);

/**
 * List all backup schedules
 * Get a list of all backup schedules
 */
export const getBackupsSchedulesOptions = (options?: Options<GetBackupsSchedulesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBackupsSchedules({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBackupsSchedulesQueryKey(options)
    });
};

export const postBackupsSchedulesQueryKey = (options: Options<PostBackupsSchedulesData>) => createQueryKey('postBackupsSchedules', options);

/**
 * Create a new backup schedule
 * Create a new backup schedule with the specified configuration
 */
export const postBackupsSchedulesOptions = (options: Options<PostBackupsSchedulesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postBackupsSchedules({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postBackupsSchedulesQueryKey(options)
    });
};

/**
 * Create a new backup schedule
 * Create a new backup schedule with the specified configuration
 */
export const postBackupsSchedulesMutation = (options?: Partial<Options<PostBackupsSchedulesData>>): UseMutationOptions<PostBackupsSchedulesResponse, PostBackupsSchedulesError, Options<PostBackupsSchedulesData>> => {
    const mutationOptions: UseMutationOptions<PostBackupsSchedulesResponse, PostBackupsSchedulesError, Options<PostBackupsSchedulesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postBackupsSchedules({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a backup schedule
 * Delete a backup schedule and stop its execution
 */
export const deleteBackupsSchedulesByIdMutation = (options?: Partial<Options<DeleteBackupsSchedulesByIdData>>): UseMutationOptions<unknown, DeleteBackupsSchedulesByIdError, Options<DeleteBackupsSchedulesByIdData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteBackupsSchedulesByIdError, Options<DeleteBackupsSchedulesByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteBackupsSchedulesById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBackupsSchedulesByIdQueryKey = (options: Options<GetBackupsSchedulesByIdData>) => createQueryKey('getBackupsSchedulesById', options);

/**
 * Get a backup schedule by ID
 * Get detailed information about a specific backup schedule
 */
export const getBackupsSchedulesByIdOptions = (options: Options<GetBackupsSchedulesByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBackupsSchedulesById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBackupsSchedulesByIdQueryKey(options)
    });
};

/**
 * Update a backup schedule
 * Update an existing backup schedule with new configuration
 */
export const putBackupsSchedulesByIdMutation = (options?: Partial<Options<PutBackupsSchedulesByIdData>>): UseMutationOptions<PutBackupsSchedulesByIdResponse, PutBackupsSchedulesByIdError, Options<PutBackupsSchedulesByIdData>> => {
    const mutationOptions: UseMutationOptions<PutBackupsSchedulesByIdResponse, PutBackupsSchedulesByIdError, Options<PutBackupsSchedulesByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putBackupsSchedulesById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Disable a backup schedule
 * Disable a backup schedule to stop it from running
 */
export const putBackupsSchedulesByIdDisableMutation = (options?: Partial<Options<PutBackupsSchedulesByIdDisableData>>): UseMutationOptions<PutBackupsSchedulesByIdDisableResponse, PutBackupsSchedulesByIdDisableError, Options<PutBackupsSchedulesByIdDisableData>> => {
    const mutationOptions: UseMutationOptions<PutBackupsSchedulesByIdDisableResponse, PutBackupsSchedulesByIdDisableError, Options<PutBackupsSchedulesByIdDisableData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putBackupsSchedulesByIdDisable({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Enable a backup schedule
 * Enable a backup schedule to start running
 */
export const putBackupsSchedulesByIdEnableMutation = (options?: Partial<Options<PutBackupsSchedulesByIdEnableData>>): UseMutationOptions<PutBackupsSchedulesByIdEnableResponse, PutBackupsSchedulesByIdEnableError, Options<PutBackupsSchedulesByIdEnableData>> => {
    const mutationOptions: UseMutationOptions<PutBackupsSchedulesByIdEnableResponse, PutBackupsSchedulesByIdEnableError, Options<PutBackupsSchedulesByIdEnableData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putBackupsSchedulesByIdEnable({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBackupsTargetsQueryKey = (options?: Options<GetBackupsTargetsData>) => createQueryKey('getBackupsTargets', options);

/**
 * List all backup targets
 * Get a list of all backup targets
 */
export const getBackupsTargetsOptions = (options?: Options<GetBackupsTargetsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBackupsTargets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBackupsTargetsQueryKey(options)
    });
};

export const postBackupsTargetsQueryKey = (options: Options<PostBackupsTargetsData>) => createQueryKey('postBackupsTargets', options);

/**
 * Create a new backup target
 * Create a new backup target with the specified configuration
 */
export const postBackupsTargetsOptions = (options: Options<PostBackupsTargetsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postBackupsTargets({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postBackupsTargetsQueryKey(options)
    });
};

/**
 * Create a new backup target
 * Create a new backup target with the specified configuration
 */
export const postBackupsTargetsMutation = (options?: Partial<Options<PostBackupsTargetsData>>): UseMutationOptions<PostBackupsTargetsResponse, PostBackupsTargetsError, Options<PostBackupsTargetsData>> => {
    const mutationOptions: UseMutationOptions<PostBackupsTargetsResponse, PostBackupsTargetsError, Options<PostBackupsTargetsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postBackupsTargets({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a backup target
 * Delete a backup target and all associated backups
 */
export const deleteBackupsTargetsByIdMutation = (options?: Partial<Options<DeleteBackupsTargetsByIdData>>): UseMutationOptions<unknown, DeleteBackupsTargetsByIdError, Options<DeleteBackupsTargetsByIdData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteBackupsTargetsByIdError, Options<DeleteBackupsTargetsByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteBackupsTargetsById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBackupsTargetsByIdQueryKey = (options: Options<GetBackupsTargetsByIdData>) => createQueryKey('getBackupsTargetsById', options);

/**
 * Get a backup target by ID
 * Get detailed information about a specific backup target
 */
export const getBackupsTargetsByIdOptions = (options: Options<GetBackupsTargetsByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBackupsTargetsById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBackupsTargetsByIdQueryKey(options)
    });
};

/**
 * Update a backup target
 * Update an existing backup target with new configuration
 */
export const putBackupsTargetsByIdMutation = (options?: Partial<Options<PutBackupsTargetsByIdData>>): UseMutationOptions<PutBackupsTargetsByIdResponse, PutBackupsTargetsByIdError, Options<PutBackupsTargetsByIdData>> => {
    const mutationOptions: UseMutationOptions<PutBackupsTargetsByIdResponse, PutBackupsTargetsByIdError, Options<PutBackupsTargetsByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putBackupsTargetsById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a backup
 * Delete a backup and its associated files
 */
export const deleteBackupsByIdMutation = (options?: Partial<Options<DeleteBackupsByIdData>>): UseMutationOptions<unknown, DeleteBackupsByIdError, Options<DeleteBackupsByIdData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteBackupsByIdError, Options<DeleteBackupsByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteBackupsById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBackupsByIdQueryKey = (options: Options<GetBackupsByIdData>) => createQueryKey('getBackupsById', options);

/**
 * Get a backup by ID
 * Get detailed information about a specific backup
 */
export const getBackupsByIdOptions = (options: Options<GetBackupsByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getBackupsById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getBackupsByIdQueryKey(options)
    });
};

export const getChaincodeProjectsQueryKey = (options?: Options<GetChaincodeProjectsData>) => createQueryKey('getChaincodeProjects', options);

/**
 * List all projects
 * Get a list of all projects
 */
export const getChaincodeProjectsOptions = (options?: Options<GetChaincodeProjectsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getChaincodeProjects({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getChaincodeProjectsQueryKey(options)
    });
};

export const postChaincodeProjectsQueryKey = (options: Options<PostChaincodeProjectsData>) => createQueryKey('postChaincodeProjects', options);

/**
 * Create a project
 * Create a new project, scaffold its directory, and store it in the DB
 */
export const postChaincodeProjectsOptions = (options: Options<PostChaincodeProjectsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postChaincodeProjects({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postChaincodeProjectsQueryKey(options)
    });
};

/**
 * Create a project
 * Create a new project, scaffold its directory, and store it in the DB
 */
export const postChaincodeProjectsMutation = (options?: Partial<Options<PostChaincodeProjectsData>>): UseMutationOptions<PostChaincodeProjectsResponse, PostChaincodeProjectsError, Options<PostChaincodeProjectsData>> => {
    const mutationOptions: UseMutationOptions<PostChaincodeProjectsResponse, PostChaincodeProjectsError, Options<PostChaincodeProjectsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postChaincodeProjects({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a project
 * Delete a project and its associated files from the system
 */
export const deleteChaincodeProjectsByIdMutation = (options?: Partial<Options<DeleteChaincodeProjectsByIdData>>): UseMutationOptions<DeleteChaincodeProjectsByIdResponse, DeleteChaincodeProjectsByIdError, Options<DeleteChaincodeProjectsByIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteChaincodeProjectsByIdResponse, DeleteChaincodeProjectsByIdError, Options<DeleteChaincodeProjectsByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteChaincodeProjectsById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getChaincodeProjectsByIdQueryKey = (options: Options<GetChaincodeProjectsByIdData>) => createQueryKey('getChaincodeProjectsById', options);

/**
 * Get a project by ID
 * Get details of a project by its ID
 */
export const getChaincodeProjectsByIdOptions = (options: Options<GetChaincodeProjectsByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getChaincodeProjectsById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getChaincodeProjectsByIdQueryKey(options)
    });
};

export const getChaincodeProjectsByIdCommitsQueryKey = (options: Options<GetChaincodeProjectsByIdCommitsData>) => createQueryKey('getChaincodeProjectsByIdCommits', options);

/**
 * List project commits with file changes
 * Get a paginated list of commits for a project, including added/removed/modified files
 */
export const getChaincodeProjectsByIdCommitsOptions = (options: Options<GetChaincodeProjectsByIdCommitsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getChaincodeProjectsByIdCommits({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getChaincodeProjectsByIdCommitsQueryKey(options)
    });
};

export const getChaincodeProjectsByIdCommitsInfiniteQueryKey = (options: Options<GetChaincodeProjectsByIdCommitsData>): QueryKey<Options<GetChaincodeProjectsByIdCommitsData>> => createQueryKey('getChaincodeProjectsByIdCommits', options, true);

/**
 * List project commits with file changes
 * Get a paginated list of commits for a project, including added/removed/modified files
 */
export const getChaincodeProjectsByIdCommitsInfiniteOptions = (options: Options<GetChaincodeProjectsByIdCommitsData>) => {
    return infiniteQueryOptions<GetChaincodeProjectsByIdCommitsResponse, GetChaincodeProjectsByIdCommitsError, InfiniteData<GetChaincodeProjectsByIdCommitsResponse>, QueryKey<Options<GetChaincodeProjectsByIdCommitsData>>, number | Pick<QueryKey<Options<GetChaincodeProjectsByIdCommitsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetChaincodeProjectsByIdCommitsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getChaincodeProjectsByIdCommits({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getChaincodeProjectsByIdCommitsInfiniteQueryKey(options)
    });
};

export const getChaincodeProjectsByIdCommitsByCommitHashQueryKey = (options: Options<GetChaincodeProjectsByIdCommitsByCommitHashData>) => createQueryKey('getChaincodeProjectsByIdCommitsByCommitHash', options);

/**
 * Get commit details
 * Get details for a single commit, including file changes
 */
export const getChaincodeProjectsByIdCommitsByCommitHashOptions = (options: Options<GetChaincodeProjectsByIdCommitsByCommitHashData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getChaincodeProjectsByIdCommitsByCommitHash({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getChaincodeProjectsByIdCommitsByCommitHashQueryKey(options)
    });
};

export const getChaincodeProjectsByIdDiffQueryKey = (options: Options<GetChaincodeProjectsByIdDiffData>) => createQueryKey('getChaincodeProjectsByIdDiff', options);

/**
 * Get file diff between two commits
 * Get the diff of a file between two commits
 */
export const getChaincodeProjectsByIdDiffOptions = (options: Options<GetChaincodeProjectsByIdDiffData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getChaincodeProjectsByIdDiff({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getChaincodeProjectsByIdDiffQueryKey(options)
    });
};

export const getChaincodeProjectsByIdDownloadQueryKey = (options: Options<GetChaincodeProjectsByIdDownloadData>) => createQueryKey('getChaincodeProjectsByIdDownload', options);

/**
 * Download a project as a zip file
 * Download a project and its associated files as a zip file, excluding common folders like node_modules, .vscode, etc.
 */
export const getChaincodeProjectsByIdDownloadOptions = (options: Options<GetChaincodeProjectsByIdDownloadData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getChaincodeProjectsByIdDownload({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getChaincodeProjectsByIdDownloadQueryKey(options)
    });
};

/**
 * Update a project's endorsement policy
 * Update the endorsement policy of an existing project
 */
export const putChaincodeProjectsByIdEndorsementPolicyMutation = (options?: Partial<Options<PutChaincodeProjectsByIdEndorsementPolicyData>>): UseMutationOptions<PutChaincodeProjectsByIdEndorsementPolicyResponse, PutChaincodeProjectsByIdEndorsementPolicyError, Options<PutChaincodeProjectsByIdEndorsementPolicyData>> => {
    const mutationOptions: UseMutationOptions<PutChaincodeProjectsByIdEndorsementPolicyResponse, PutChaincodeProjectsByIdEndorsementPolicyError, Options<PutChaincodeProjectsByIdEndorsementPolicyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putChaincodeProjectsByIdEndorsementPolicy({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getChaincodeProjectsByIdFileAtCommitQueryKey = (options: Options<GetChaincodeProjectsByIdFileAtCommitData>) => createQueryKey('getChaincodeProjectsByIdFileAtCommit', options);

/**
 * Get file contents at a specific commit
 * Get the contents of a file at a specific commit hash
 */
export const getChaincodeProjectsByIdFileAtCommitOptions = (options: Options<GetChaincodeProjectsByIdFileAtCommitData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getChaincodeProjectsByIdFileAtCommit({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getChaincodeProjectsByIdFileAtCommitQueryKey(options)
    });
};

export const postChaincodeProjectsByIdInvokeQueryKey = (options: Options<PostChaincodeProjectsByIdInvokeData>) => createQueryKey('postChaincodeProjectsByIdInvoke', options);

/**
 * Invoke a chaincode transaction
 * Invokes a transaction on the specified chaincode project
 */
export const postChaincodeProjectsByIdInvokeOptions = (options: Options<PostChaincodeProjectsByIdInvokeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postChaincodeProjectsByIdInvoke({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postChaincodeProjectsByIdInvokeQueryKey(options)
    });
};

/**
 * Invoke a chaincode transaction
 * Invokes a transaction on the specified chaincode project
 */
export const postChaincodeProjectsByIdInvokeMutation = (options?: Partial<Options<PostChaincodeProjectsByIdInvokeData>>): UseMutationOptions<PostChaincodeProjectsByIdInvokeResponse, PostChaincodeProjectsByIdInvokeError, Options<PostChaincodeProjectsByIdInvokeData>> => {
    const mutationOptions: UseMutationOptions<PostChaincodeProjectsByIdInvokeResponse, PostChaincodeProjectsByIdInvokeError, Options<PostChaincodeProjectsByIdInvokeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postChaincodeProjectsByIdInvoke({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getChaincodeProjectsByIdLogsQueryKey = (options: Options<GetChaincodeProjectsByIdLogsData>) => createQueryKey('getChaincodeProjectsByIdLogs', options);

/**
 * Get logs for a project server
 * Stream or return the logs for the project's running container
 */
export const getChaincodeProjectsByIdLogsOptions = (options: Options<GetChaincodeProjectsByIdLogsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getChaincodeProjectsByIdLogs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getChaincodeProjectsByIdLogsQueryKey(options)
    });
};

export const getChaincodeProjectsByIdLogsStreamQueryKey = (options: Options<GetChaincodeProjectsByIdLogsStreamData>) => createQueryKey('getChaincodeProjectsByIdLogsStream', options);

/**
 * Stream real-time logs for a project server
 * Stream logs for the project's running container using SSE
 */
export const getChaincodeProjectsByIdLogsStreamOptions = (options: Options<GetChaincodeProjectsByIdLogsStreamData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getChaincodeProjectsByIdLogsStream({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getChaincodeProjectsByIdLogsStreamQueryKey(options)
    });
};

export const getChaincodeProjectsByIdMetadataQueryKey = (options: Options<GetChaincodeProjectsByIdMetadataData>) => createQueryKey('getChaincodeProjectsByIdMetadata', options);

/**
 * Get project metadata
 * Retrieves metadata for the specified chaincode project
 */
export const getChaincodeProjectsByIdMetadataOptions = (options: Options<GetChaincodeProjectsByIdMetadataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getChaincodeProjectsByIdMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getChaincodeProjectsByIdMetadataQueryKey(options)
    });
};

export const postChaincodeProjectsByIdQueryQueryKey = (options: Options<PostChaincodeProjectsByIdQueryData>) => createQueryKey('postChaincodeProjectsByIdQuery', options);

/**
 * Query a chaincode transaction
 * Queries the state of the specified chaincode project
 */
export const postChaincodeProjectsByIdQueryOptions = (options: Options<PostChaincodeProjectsByIdQueryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postChaincodeProjectsByIdQuery({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postChaincodeProjectsByIdQueryQueryKey(options)
    });
};

/**
 * Query a chaincode transaction
 * Queries the state of the specified chaincode project
 */
export const postChaincodeProjectsByIdQueryMutation = (options?: Partial<Options<PostChaincodeProjectsByIdQueryData>>): UseMutationOptions<PostChaincodeProjectsByIdQueryResponse, PostChaincodeProjectsByIdQueryError, Options<PostChaincodeProjectsByIdQueryData>> => {
    const mutationOptions: UseMutationOptions<PostChaincodeProjectsByIdQueryResponse, PostChaincodeProjectsByIdQueryError, Options<PostChaincodeProjectsByIdQueryData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postChaincodeProjectsByIdQuery({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postChaincodeProjectsByIdStartQueryKey = (options: Options<PostChaincodeProjectsByIdStartData>) => createQueryKey('postChaincodeProjectsByIdStart', options);

/**
 * Start the server for a project
 * Start the server process for a given project using its boilerplate
 */
export const postChaincodeProjectsByIdStartOptions = (options: Options<PostChaincodeProjectsByIdStartData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postChaincodeProjectsByIdStart({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postChaincodeProjectsByIdStartQueryKey(options)
    });
};

/**
 * Start the server for a project
 * Start the server process for a given project using its boilerplate
 */
export const postChaincodeProjectsByIdStartMutation = (options?: Partial<Options<PostChaincodeProjectsByIdStartData>>): UseMutationOptions<PostChaincodeProjectsByIdStartResponse, PostChaincodeProjectsByIdStartError, Options<PostChaincodeProjectsByIdStartData>> => {
    const mutationOptions: UseMutationOptions<PostChaincodeProjectsByIdStartResponse, PostChaincodeProjectsByIdStartError, Options<PostChaincodeProjectsByIdStartData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postChaincodeProjectsByIdStart({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postChaincodeProjectsByIdStopQueryKey = (options: Options<PostChaincodeProjectsByIdStopData>) => createQueryKey('postChaincodeProjectsByIdStop', options);

/**
 * Stop the server for a project
 * Stop the server process for a given project
 */
export const postChaincodeProjectsByIdStopOptions = (options: Options<PostChaincodeProjectsByIdStopData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postChaincodeProjectsByIdStop({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postChaincodeProjectsByIdStopQueryKey(options)
    });
};

/**
 * Stop the server for a project
 * Stop the server process for a given project
 */
export const postChaincodeProjectsByIdStopMutation = (options?: Partial<Options<PostChaincodeProjectsByIdStopData>>): UseMutationOptions<PostChaincodeProjectsByIdStopResponse, PostChaincodeProjectsByIdStopError, Options<PostChaincodeProjectsByIdStopData>> => {
    const mutationOptions: UseMutationOptions<PostChaincodeProjectsByIdStopResponse, PostChaincodeProjectsByIdStopError, Options<PostChaincodeProjectsByIdStopData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postChaincodeProjectsByIdStop({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postDummyQueryKey = (options: Options<PostDummyData>) => createQueryKey('postDummy', options);

/**
 * Submit config update proposal
 * Submit a signed config update proposal for execution
 */
export const postDummyOptions = (options: Options<PostDummyData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postDummy({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postDummyQueryKey(options)
    });
};

/**
 * Submit config update proposal
 * Submit a signed config update proposal for execution
 */
export const postDummyMutation = (options?: Partial<Options<PostDummyData>>): UseMutationOptions<PostDummyResponse, DefaultError, Options<PostDummyData>> => {
    const mutationOptions: UseMutationOptions<PostDummyResponse, DefaultError, Options<PostDummyData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postDummy({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getKeyProvidersQueryKey = (options?: Options<GetKeyProvidersData>) => createQueryKey('getKeyProviders', options);

/**
 * List all key providers
 * Get a list of all configured key providers
 */
export const getKeyProvidersOptions = (options?: Options<GetKeyProvidersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getKeyProviders({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getKeyProvidersQueryKey(options)
    });
};

export const postKeyProvidersQueryKey = (options: Options<PostKeyProvidersData>) => createQueryKey('postKeyProviders', options);

/**
 * Create a new key provider
 * Create a new provider for key management
 */
export const postKeyProvidersOptions = (options: Options<PostKeyProvidersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postKeyProviders({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postKeyProvidersQueryKey(options)
    });
};

/**
 * Create a new key provider
 * Create a new provider for key management
 */
export const postKeyProvidersMutation = (options?: Partial<Options<PostKeyProvidersData>>): UseMutationOptions<PostKeyProvidersResponse, PostKeyProvidersError, Options<PostKeyProvidersData>> => {
    const mutationOptions: UseMutationOptions<PostKeyProvidersResponse, PostKeyProvidersError, Options<PostKeyProvidersData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postKeyProviders({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a provider
 * Delete a specific key provider
 */
export const deleteKeyProvidersByIdMutation = (options?: Partial<Options<DeleteKeyProvidersByIdData>>): UseMutationOptions<unknown, DeleteKeyProvidersByIdError, Options<DeleteKeyProvidersByIdData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteKeyProvidersByIdError, Options<DeleteKeyProvidersByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteKeyProvidersById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getKeyProvidersByIdQueryKey = (options: Options<GetKeyProvidersByIdData>) => createQueryKey('getKeyProvidersById', options);

/**
 * Get a specific provider
 * Get detailed information about a specific key provider
 */
export const getKeyProvidersByIdOptions = (options: Options<GetKeyProvidersByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getKeyProvidersById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getKeyProvidersByIdQueryKey(options)
    });
};

export const getKeysQueryKey = (options?: Options<GetKeysData>) => createQueryKey('getKeys', options);

/**
 * Get paginated keys
 * Get a paginated list of keys
 */
export const getKeysOptions = (options?: Options<GetKeysData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getKeys({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getKeysQueryKey(options)
    });
};

export const getKeysInfiniteQueryKey = (options?: Options<GetKeysData>): QueryKey<Options<GetKeysData>> => createQueryKey('getKeys', options, true);

/**
 * Get paginated keys
 * Get a paginated list of keys
 */
export const getKeysInfiniteOptions = (options?: Options<GetKeysData>) => {
    return infiniteQueryOptions<GetKeysResponse, GetKeysError, InfiniteData<GetKeysResponse>, QueryKey<Options<GetKeysData>>, number | Pick<QueryKey<Options<GetKeysData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetKeysData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getKeys({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getKeysInfiniteQueryKey(options)
    });
};

export const postKeysQueryKey = (options: Options<PostKeysData>) => createQueryKey('postKeys', options);

/**
 * Create a new key
 * Create a new key pair with specified algorithm and parameters
 */
export const postKeysOptions = (options: Options<PostKeysData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postKeys({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postKeysQueryKey(options)
    });
};

/**
 * Create a new key
 * Create a new key pair with specified algorithm and parameters
 */
export const postKeysMutation = (options?: Partial<Options<PostKeysData>>): UseMutationOptions<PostKeysResponse, PostKeysError, Options<PostKeysData>> => {
    const mutationOptions: UseMutationOptions<PostKeysResponse, PostKeysError, Options<PostKeysData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postKeys({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getKeysAllQueryKey = (options?: Options<GetKeysAllData>) => createQueryKey('getKeysAll', options);

/**
 * Get all keys
 * Get all keys with their certificates and metadata
 */
export const getKeysAllOptions = (options?: Options<GetKeysAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getKeysAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getKeysAllQueryKey(options)
    });
};

export const getKeysFilterQueryKey = (options?: Options<GetKeysFilterData>) => createQueryKey('getKeysFilter', options);

/**
 * Filter keys by algorithm and curve
 * Get keys filtered by algorithm type and/or curve type
 */
export const getKeysFilterOptions = (options?: Options<GetKeysFilterData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getKeysFilter({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getKeysFilterQueryKey(options)
    });
};

export const getKeysFilterInfiniteQueryKey = (options?: Options<GetKeysFilterData>): QueryKey<Options<GetKeysFilterData>> => createQueryKey('getKeysFilter', options, true);

/**
 * Filter keys by algorithm and curve
 * Get keys filtered by algorithm type and/or curve type
 */
export const getKeysFilterInfiniteOptions = (options?: Options<GetKeysFilterData>) => {
    return infiniteQueryOptions<GetKeysFilterResponse, GetKeysFilterError, InfiniteData<GetKeysFilterResponse>, QueryKey<Options<GetKeysFilterData>>, number | Pick<QueryKey<Options<GetKeysFilterData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetKeysFilterData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getKeysFilter({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getKeysFilterInfiniteQueryKey(options)
    });
};

/**
 * Delete a key
 * Delete a specific key by ID
 */
export const deleteKeysByIdMutation = (options?: Partial<Options<DeleteKeysByIdData>>): UseMutationOptions<unknown, DeleteKeysByIdError, Options<DeleteKeysByIdData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteKeysByIdError, Options<DeleteKeysByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteKeysById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getKeysByIdQueryKey = (options: Options<GetKeysByIdData>) => createQueryKey('getKeysById', options);

/**
 * Get a specific key by ID
 * Get detailed information about a specific key
 */
export const getKeysByIdOptions = (options: Options<GetKeysByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getKeysById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getKeysByIdQueryKey(options)
    });
};

export const postKeysByKeyIdSignQueryKey = (options: Options<PostKeysByKeyIdSignData>) => createQueryKey('postKeysByKeyIdSign', options);

/**
 * Sign a certificate
 * Sign a certificate for a key using a CA key
 */
export const postKeysByKeyIdSignOptions = (options: Options<PostKeysByKeyIdSignData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postKeysByKeyIdSign({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postKeysByKeyIdSignQueryKey(options)
    });
};

/**
 * Sign a certificate
 * Sign a certificate for a key using a CA key
 */
export const postKeysByKeyIdSignMutation = (options?: Partial<Options<PostKeysByKeyIdSignData>>): UseMutationOptions<PostKeysByKeyIdSignResponse, PostKeysByKeyIdSignError, Options<PostKeysByKeyIdSignData>> => {
    const mutationOptions: UseMutationOptions<PostKeysByKeyIdSignResponse, PostKeysByKeyIdSignError, Options<PostKeysByKeyIdSignData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postKeysByKeyIdSign({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postKeysByKeyIdSignDataQueryKey = (options: Options<PostKeysByKeyIdSignDataData>) => createQueryKey('postKeysByKeyIdSignData', options);

/**
 * Sign data using a key
 * Sign data using a specific key with configurable parameters
 */
export const postKeysByKeyIdSignDataOptions = (options: Options<PostKeysByKeyIdSignDataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postKeysByKeyIdSignData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postKeysByKeyIdSignDataQueryKey(options)
    });
};

/**
 * Sign data using a key
 * Sign data using a specific key with configurable parameters
 */
export const postKeysByKeyIdSignDataMutation = (options?: Partial<Options<PostKeysByKeyIdSignDataData>>): UseMutationOptions<PostKeysByKeyIdSignDataResponse, PostKeysByKeyIdSignDataError, Options<PostKeysByKeyIdSignDataData>> => {
    const mutationOptions: UseMutationOptions<PostKeysByKeyIdSignDataResponse, PostKeysByKeyIdSignDataError, Options<PostKeysByKeyIdSignDataData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postKeysByKeyIdSignData({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMetricsDefaultsQueryKey = (options?: Options<GetMetricsDefaultsData>) => createQueryKey('getMetricsDefaults', options);

/**
 * Get default values for Prometheus deployment
 * Returns default configuration values including available ports for Prometheus deployment
 */
export const getMetricsDefaultsOptions = (options?: Options<GetMetricsDefaultsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMetricsDefaults({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMetricsDefaultsQueryKey(options)
    });
};

export const postMetricsDeployQueryKey = (options: Options<PostMetricsDeployData>) => createQueryKey('postMetricsDeploy', options);

/**
 * Deploy a new Prometheus instance
 * Deploys a new Prometheus instance with the specified configuration
 */
export const postMetricsDeployOptions = (options: Options<PostMetricsDeployData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postMetricsDeploy({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postMetricsDeployQueryKey(options)
    });
};

/**
 * Deploy a new Prometheus instance
 * Deploys a new Prometheus instance with the specified configuration
 */
export const postMetricsDeployMutation = (options?: Partial<Options<PostMetricsDeployData>>): UseMutationOptions<PostMetricsDeployResponse, PostMetricsDeployError, Options<PostMetricsDeployData>> => {
    const mutationOptions: UseMutationOptions<PostMetricsDeployResponse, PostMetricsDeployError, Options<PostMetricsDeployData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postMetricsDeploy({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMetricsLogsQueryKey = (options?: Options<GetMetricsLogsData>) => createQueryKey('getMetricsLogs', options);

/**
 * Tail Prometheus logs
 * Streams Prometheus logs with optional tail and follow functionality
 */
export const getMetricsLogsOptions = (options?: Options<GetMetricsLogsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMetricsLogs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMetricsLogsQueryKey(options)
    });
};

export const getMetricsNodeByIdQueryKey = (options: Options<GetMetricsNodeByIdData>) => createQueryKey('getMetricsNodeById', options);

/**
 * Get metrics for a specific node
 * Retrieves metrics for a specific node by ID and optional PromQL query
 */
export const getMetricsNodeByIdOptions = (options: Options<GetMetricsNodeByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMetricsNodeById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMetricsNodeByIdQueryKey(options)
    });
};

export const getMetricsNodeByIdLabelByLabelValuesQueryKey = (options: Options<GetMetricsNodeByIdLabelByLabelValuesData>) => createQueryKey('getMetricsNodeByIdLabelByLabelValues', options);

/**
 * Get label values for a specific label
 * Retrieves all values for a specific label, optionally filtered by metric matches and node ID
 */
export const getMetricsNodeByIdLabelByLabelValuesOptions = (options: Options<GetMetricsNodeByIdLabelByLabelValuesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMetricsNodeByIdLabelByLabelValues({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMetricsNodeByIdLabelByLabelValuesQueryKey(options)
    });
};

export const postMetricsNodeByIdQueryQueryKey = (options: Options<PostMetricsNodeByIdQueryData>) => createQueryKey('postMetricsNodeByIdQuery', options);

/**
 * Execute custom Prometheus query
 * Execute a custom Prometheus query with optional time range
 */
export const postMetricsNodeByIdQueryOptions = (options: Options<PostMetricsNodeByIdQueryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postMetricsNodeByIdQuery({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postMetricsNodeByIdQueryQueryKey(options)
    });
};

export const postMetricsNodeByIdQueryInfiniteQueryKey = (options: Options<PostMetricsNodeByIdQueryData>): QueryKey<Options<PostMetricsNodeByIdQueryData>> => createQueryKey('postMetricsNodeByIdQuery', options, true);

/**
 * Execute custom Prometheus query
 * Execute a custom Prometheus query with optional time range
 */
export const postMetricsNodeByIdQueryInfiniteOptions = (options: Options<PostMetricsNodeByIdQueryData>) => {
    return infiniteQueryOptions<PostMetricsNodeByIdQueryResponse, PostMetricsNodeByIdQueryError, InfiniteData<PostMetricsNodeByIdQueryResponse>, QueryKey<Options<PostMetricsNodeByIdQueryData>>, string | Pick<QueryKey<Options<PostMetricsNodeByIdQueryData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<PostMetricsNodeByIdQueryData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                body: {
                    start: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await postMetricsNodeByIdQuery({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postMetricsNodeByIdQueryInfiniteQueryKey(options)
    });
};

/**
 * Execute custom Prometheus query
 * Execute a custom Prometheus query with optional time range
 */
export const postMetricsNodeByIdQueryMutation = (options?: Partial<Options<PostMetricsNodeByIdQueryData>>): UseMutationOptions<PostMetricsNodeByIdQueryResponse, PostMetricsNodeByIdQueryError, Options<PostMetricsNodeByIdQueryData>> => {
    const mutationOptions: UseMutationOptions<PostMetricsNodeByIdQueryResponse, PostMetricsNodeByIdQueryError, Options<PostMetricsNodeByIdQueryData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postMetricsNodeByIdQuery({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMetricsNodeByIdRangeQueryKey = (options: Options<GetMetricsNodeByIdRangeData>) => createQueryKey('getMetricsNodeByIdRange', options);

/**
 * Get metrics for a specific node with time range
 * Retrieves metrics for a specific node within a specified time range
 */
export const getMetricsNodeByIdRangeOptions = (options: Options<GetMetricsNodeByIdRangeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMetricsNodeByIdRange({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMetricsNodeByIdRangeQueryKey(options)
    });
};

export const getMetricsNodeByIdRangeInfiniteQueryKey = (options: Options<GetMetricsNodeByIdRangeData>): QueryKey<Options<GetMetricsNodeByIdRangeData>> => createQueryKey('getMetricsNodeByIdRange', options, true);

/**
 * Get metrics for a specific node with time range
 * Retrieves metrics for a specific node within a specified time range
 */
export const getMetricsNodeByIdRangeInfiniteOptions = (options: Options<GetMetricsNodeByIdRangeData>) => {
    return infiniteQueryOptions<GetMetricsNodeByIdRangeResponse, GetMetricsNodeByIdRangeError, InfiniteData<GetMetricsNodeByIdRangeResponse>, QueryKey<Options<GetMetricsNodeByIdRangeData>>, string | Pick<QueryKey<Options<GetMetricsNodeByIdRangeData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetMetricsNodeByIdRangeData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    start: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getMetricsNodeByIdRange({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMetricsNodeByIdRangeInfiniteQueryKey(options)
    });
};

export const getMetricsPortByPortCheckQueryKey = (options: Options<GetMetricsPortByPortCheckData>) => createQueryKey('getMetricsPortByPortCheck', options);

/**
 * Check port availability
 * Checks if a specific port is available for Prometheus deployment
 */
export const getMetricsPortByPortCheckOptions = (options: Options<GetMetricsPortByPortCheckData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMetricsPortByPortCheck({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMetricsPortByPortCheckQueryKey(options)
    });
};

export const postMetricsRefreshQueryKey = (options: Options<PostMetricsRefreshData>) => createQueryKey('postMetricsRefresh', options);

/**
 * Refresh Prometheus deployment
 * Refreshes the Prometheus deployment with new configuration parameters
 */
export const postMetricsRefreshOptions = (options: Options<PostMetricsRefreshData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postMetricsRefresh({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postMetricsRefreshQueryKey(options)
    });
};

/**
 * Refresh Prometheus deployment
 * Refreshes the Prometheus deployment with new configuration parameters
 */
export const postMetricsRefreshMutation = (options?: Partial<Options<PostMetricsRefreshData>>): UseMutationOptions<PostMetricsRefreshResponse, PostMetricsRefreshError, Options<PostMetricsRefreshData>> => {
    const mutationOptions: UseMutationOptions<PostMetricsRefreshResponse, PostMetricsRefreshError, Options<PostMetricsRefreshData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postMetricsRefresh({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postMetricsReloadQueryKey = (options?: Options<PostMetricsReloadData>) => createQueryKey('postMetricsReload', options);

/**
 * Reload Prometheus configuration
 * Triggers a reload of the Prometheus configuration to pick up any changes
 */
export const postMetricsReloadOptions = (options?: Options<PostMetricsReloadData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postMetricsReload({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postMetricsReloadQueryKey(options)
    });
};

/**
 * Reload Prometheus configuration
 * Triggers a reload of the Prometheus configuration to pick up any changes
 */
export const postMetricsReloadMutation = (options?: Partial<Options<PostMetricsReloadData>>): UseMutationOptions<PostMetricsReloadResponse, PostMetricsReloadError, Options<PostMetricsReloadData>> => {
    const mutationOptions: UseMutationOptions<PostMetricsReloadResponse, PostMetricsReloadError, Options<PostMetricsReloadData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postMetricsReload({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postMetricsStartQueryKey = (options?: Options<PostMetricsStartData>) => createQueryKey('postMetricsStart', options);

/**
 * Start Prometheus instance
 * Starts the Prometheus instance if it's currently stopped
 */
export const postMetricsStartOptions = (options?: Options<PostMetricsStartData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postMetricsStart({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postMetricsStartQueryKey(options)
    });
};

/**
 * Start Prometheus instance
 * Starts the Prometheus instance if it's currently stopped
 */
export const postMetricsStartMutation = (options?: Partial<Options<PostMetricsStartData>>): UseMutationOptions<PostMetricsStartResponse, PostMetricsStartError, Options<PostMetricsStartData>> => {
    const mutationOptions: UseMutationOptions<PostMetricsStartResponse, PostMetricsStartError, Options<PostMetricsStartData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postMetricsStart({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMetricsStatusQueryKey = (options?: Options<GetMetricsStatusData>) => createQueryKey('getMetricsStatus', options);

/**
 * Get Prometheus status
 * Returns the current status of the Prometheus instance including version, port, and configuration
 */
export const getMetricsStatusOptions = (options?: Options<GetMetricsStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMetricsStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMetricsStatusQueryKey(options)
    });
};

export const postMetricsStopQueryKey = (options?: Options<PostMetricsStopData>) => createQueryKey('postMetricsStop', options);

/**
 * Stop Prometheus instance
 * Stops the Prometheus instance if it's currently running
 */
export const postMetricsStopOptions = (options?: Options<PostMetricsStopData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postMetricsStop({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postMetricsStopQueryKey(options)
    });
};

/**
 * Stop Prometheus instance
 * Stops the Prometheus instance if it's currently running
 */
export const postMetricsStopMutation = (options?: Partial<Options<PostMetricsStopData>>): UseMutationOptions<PostMetricsStopResponse, PostMetricsStopError, Options<PostMetricsStopData>> => {
    const mutationOptions: UseMutationOptions<PostMetricsStopResponse, PostMetricsStopError, Options<PostMetricsStopData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postMetricsStop({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postMetricsUndeployQueryKey = (options?: Options<PostMetricsUndeployData>) => createQueryKey('postMetricsUndeploy', options);

/**
 * Undeploy Prometheus instance
 * Stops and removes the Prometheus instance
 */
export const postMetricsUndeployOptions = (options?: Options<PostMetricsUndeployData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postMetricsUndeploy({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postMetricsUndeployQueryKey(options)
    });
};

/**
 * Undeploy Prometheus instance
 * Stops and removes the Prometheus instance
 */
export const postMetricsUndeployMutation = (options?: Partial<Options<PostMetricsUndeployData>>): UseMutationOptions<PostMetricsUndeployResponse, PostMetricsUndeployError, Options<PostMetricsUndeployData>> => {
    const mutationOptions: UseMutationOptions<PostMetricsUndeployResponse, PostMetricsUndeployError, Options<PostMetricsUndeployData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postMetricsUndeploy({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNetworksBesuQueryKey = (options?: Options<GetNetworksBesuData>) => createQueryKey('getNetworksBesu', options);

/**
 * List Besu networks
 * Get a paginated list of Besu networks
 */
export const getNetworksBesuOptions = (options?: Options<GetNetworksBesuData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNetworksBesu({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNetworksBesuQueryKey(options)
    });
};

export const getNetworksBesuInfiniteQueryKey = (options?: Options<GetNetworksBesuData>): QueryKey<Options<GetNetworksBesuData>> => createQueryKey('getNetworksBesu', options, true);

/**
 * List Besu networks
 * Get a paginated list of Besu networks
 */
export const getNetworksBesuInfiniteOptions = (options?: Options<GetNetworksBesuData>) => {
    return infiniteQueryOptions<GetNetworksBesuResponse, GetNetworksBesuError, InfiniteData<GetNetworksBesuResponse>, QueryKey<Options<GetNetworksBesuData>>, number | Pick<QueryKey<Options<GetNetworksBesuData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetNetworksBesuData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getNetworksBesu({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNetworksBesuInfiniteQueryKey(options)
    });
};

export const postNetworksBesuQueryKey = (options: Options<PostNetworksBesuData>) => createQueryKey('postNetworksBesu', options);

/**
 * Create a new Besu network
 * Create a new Besu network with the specified configuration
 */
export const postNetworksBesuOptions = (options: Options<PostNetworksBesuData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNetworksBesu({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNetworksBesuQueryKey(options)
    });
};

/**
 * Create a new Besu network
 * Create a new Besu network with the specified configuration
 */
export const postNetworksBesuMutation = (options?: Partial<Options<PostNetworksBesuData>>): UseMutationOptions<PostNetworksBesuResponse, PostNetworksBesuError, Options<PostNetworksBesuData>> => {
    const mutationOptions: UseMutationOptions<PostNetworksBesuResponse, PostNetworksBesuError, Options<PostNetworksBesuData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNetworksBesu({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postNetworksBesuImportQueryKey = (options: Options<PostNetworksBesuImportData>) => createQueryKey('postNetworksBesuImport', options);

/**
 * Import a Besu network
 * Import an existing Besu network using its genesis file
 */
export const postNetworksBesuImportOptions = (options: Options<PostNetworksBesuImportData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNetworksBesuImport({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNetworksBesuImportQueryKey(options)
    });
};

/**
 * Import a Besu network
 * Import an existing Besu network using its genesis file
 */
export const postNetworksBesuImportMutation = (options?: Partial<Options<PostNetworksBesuImportData>>): UseMutationOptions<PostNetworksBesuImportResponse, PostNetworksBesuImportError, Options<PostNetworksBesuImportData>> => {
    const mutationOptions: UseMutationOptions<PostNetworksBesuImportResponse, PostNetworksBesuImportError, Options<PostNetworksBesuImportData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNetworksBesuImport({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a Besu network
 * Delete an existing Besu network and all its resources
 */
export const deleteNetworksBesuByIdMutation = (options?: Partial<Options<DeleteNetworksBesuByIdData>>): UseMutationOptions<unknown, DeleteNetworksBesuByIdError, Options<DeleteNetworksBesuByIdData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteNetworksBesuByIdError, Options<DeleteNetworksBesuByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteNetworksBesuById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNetworksBesuByIdQueryKey = (options: Options<GetNetworksBesuByIdData>) => createQueryKey('getNetworksBesuById', options);

/**
 * Get a Besu network by ID
 * Get details of a specific Besu network
 */
export const getNetworksBesuByIdOptions = (options: Options<GetNetworksBesuByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNetworksBesuById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNetworksBesuByIdQueryKey(options)
    });
};

export const getNetworksBesuByIdMapQueryKey = (options: Options<GetNetworksBesuByIdMapData>) => createQueryKey('getNetworksBesuByIdMap', options);

/**
 * Get network map
 * Get a map of all nodes (peers/orderers/validators) for a network, including endpoints and optionally health status.
 */
export const getNetworksBesuByIdMapOptions = (options: Options<GetNetworksBesuByIdMapData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNetworksBesuByIdMap({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNetworksBesuByIdMapQueryKey(options)
    });
};

export const getNetworksFabricQueryKey = (options?: Options<GetNetworksFabricData>) => createQueryKey('getNetworksFabric', options);

/**
 * List Fabric networks
 * Get a paginated list of Fabric networks
 */
export const getNetworksFabricOptions = (options?: Options<GetNetworksFabricData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNetworksFabric({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNetworksFabricQueryKey(options)
    });
};

export const getNetworksFabricInfiniteQueryKey = (options?: Options<GetNetworksFabricData>): QueryKey<Options<GetNetworksFabricData>> => createQueryKey('getNetworksFabric', options, true);

/**
 * List Fabric networks
 * Get a paginated list of Fabric networks
 */
export const getNetworksFabricInfiniteOptions = (options?: Options<GetNetworksFabricData>) => {
    return infiniteQueryOptions<GetNetworksFabricResponse, GetNetworksFabricError, InfiniteData<GetNetworksFabricResponse>, QueryKey<Options<GetNetworksFabricData>>, number | Pick<QueryKey<Options<GetNetworksFabricData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetNetworksFabricData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getNetworksFabric({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNetworksFabricInfiniteQueryKey(options)
    });
};

export const postNetworksFabricQueryKey = (options: Options<PostNetworksFabricData>) => createQueryKey('postNetworksFabric', options);

/**
 * Create a new Fabric network
 * Create a new Hyperledger Fabric network with the specified configuration
 */
export const postNetworksFabricOptions = (options: Options<PostNetworksFabricData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNetworksFabric({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNetworksFabricQueryKey(options)
    });
};

/**
 * Create a new Fabric network
 * Create a new Hyperledger Fabric network with the specified configuration
 */
export const postNetworksFabricMutation = (options?: Partial<Options<PostNetworksFabricData>>): UseMutationOptions<PostNetworksFabricResponse, PostNetworksFabricError, Options<PostNetworksFabricData>> => {
    const mutationOptions: UseMutationOptions<PostNetworksFabricResponse, PostNetworksFabricError, Options<PostNetworksFabricData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNetworksFabric({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNetworksFabricByNameByNameQueryKey = (options: Options<GetNetworksFabricByNameByNameData>) => createQueryKey('getNetworksFabricByNameByName', options);

/**
 * Get a Fabric network by slug
 * Get details of a specific Fabric network using its slug
 */
export const getNetworksFabricByNameByNameOptions = (options: Options<GetNetworksFabricByNameByNameData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNetworksFabricByNameByName({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNetworksFabricByNameByNameQueryKey(options)
    });
};

export const postNetworksFabricImportQueryKey = (options: Options<PostNetworksFabricImportData>) => createQueryKey('postNetworksFabricImport', options);

/**
 * Import a Fabric network
 * Import an existing Fabric network using its genesis block
 */
export const postNetworksFabricImportOptions = (options: Options<PostNetworksFabricImportData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNetworksFabricImport({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNetworksFabricImportQueryKey(options)
    });
};

/**
 * Import a Fabric network
 * Import an existing Fabric network using its genesis block
 */
export const postNetworksFabricImportMutation = (options?: Partial<Options<PostNetworksFabricImportData>>): UseMutationOptions<PostNetworksFabricImportResponse, PostNetworksFabricImportError, Options<PostNetworksFabricImportData>> => {
    const mutationOptions: UseMutationOptions<PostNetworksFabricImportResponse, PostNetworksFabricImportError, Options<PostNetworksFabricImportData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNetworksFabricImport({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postNetworksFabricImportWithOrgQueryKey = (options: Options<PostNetworksFabricImportWithOrgData>) => createQueryKey('postNetworksFabricImportWithOrg', options);

/**
 * Import a Fabric network with organization
 * Import an existing Fabric network using organization details
 */
export const postNetworksFabricImportWithOrgOptions = (options: Options<PostNetworksFabricImportWithOrgData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNetworksFabricImportWithOrg({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNetworksFabricImportWithOrgQueryKey(options)
    });
};

/**
 * Import a Fabric network with organization
 * Import an existing Fabric network using organization details
 */
export const postNetworksFabricImportWithOrgMutation = (options?: Partial<Options<PostNetworksFabricImportWithOrgData>>): UseMutationOptions<PostNetworksFabricImportWithOrgResponse, PostNetworksFabricImportWithOrgError, Options<PostNetworksFabricImportWithOrgData>> => {
    const mutationOptions: UseMutationOptions<PostNetworksFabricImportWithOrgResponse, PostNetworksFabricImportWithOrgError, Options<PostNetworksFabricImportWithOrgData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNetworksFabricImportWithOrg({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a Fabric network
 * Delete an existing Fabric network and all its resources
 */
export const deleteNetworksFabricByIdMutation = (options?: Partial<Options<DeleteNetworksFabricByIdData>>): UseMutationOptions<unknown, DeleteNetworksFabricByIdError, Options<DeleteNetworksFabricByIdData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteNetworksFabricByIdError, Options<DeleteNetworksFabricByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteNetworksFabricById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNetworksFabricByIdQueryKey = (options: Options<GetNetworksFabricByIdData>) => createQueryKey('getNetworksFabricById', options);

/**
 * Get a Fabric network by ID
 * Get details of a specific Fabric network
 */
export const getNetworksFabricByIdOptions = (options: Options<GetNetworksFabricByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNetworksFabricById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNetworksFabricByIdQueryKey(options)
    });
};

export const postNetworksFabricByIdAnchorPeersQueryKey = (options: Options<PostNetworksFabricByIdAnchorPeersData>) => createQueryKey('postNetworksFabricByIdAnchorPeers', options);

/**
 * Set anchor peers for an organization
 * Set the anchor peers for an organization in a Fabric network
 */
export const postNetworksFabricByIdAnchorPeersOptions = (options: Options<PostNetworksFabricByIdAnchorPeersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNetworksFabricByIdAnchorPeers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNetworksFabricByIdAnchorPeersQueryKey(options)
    });
};

/**
 * Set anchor peers for an organization
 * Set the anchor peers for an organization in a Fabric network
 */
export const postNetworksFabricByIdAnchorPeersMutation = (options?: Partial<Options<PostNetworksFabricByIdAnchorPeersData>>): UseMutationOptions<PostNetworksFabricByIdAnchorPeersResponse, PostNetworksFabricByIdAnchorPeersError, Options<PostNetworksFabricByIdAnchorPeersData>> => {
    const mutationOptions: UseMutationOptions<PostNetworksFabricByIdAnchorPeersResponse, PostNetworksFabricByIdAnchorPeersError, Options<PostNetworksFabricByIdAnchorPeersData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNetworksFabricByIdAnchorPeers({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNetworksFabricByIdBlocksQueryKey = (options: Options<GetNetworksFabricByIdBlocksData>) => createQueryKey('getNetworksFabricByIdBlocks', options);

/**
 * Get list of blocks from Fabric network
 * Get a paginated list of blocks from a Fabric network
 */
export const getNetworksFabricByIdBlocksOptions = (options: Options<GetNetworksFabricByIdBlocksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNetworksFabricByIdBlocks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNetworksFabricByIdBlocksQueryKey(options)
    });
};

export const getNetworksFabricByIdBlocksInfiniteQueryKey = (options: Options<GetNetworksFabricByIdBlocksData>): QueryKey<Options<GetNetworksFabricByIdBlocksData>> => createQueryKey('getNetworksFabricByIdBlocks', options, true);

/**
 * Get list of blocks from Fabric network
 * Get a paginated list of blocks from a Fabric network
 */
export const getNetworksFabricByIdBlocksInfiniteOptions = (options: Options<GetNetworksFabricByIdBlocksData>) => {
    return infiniteQueryOptions<GetNetworksFabricByIdBlocksResponse, GetNetworksFabricByIdBlocksError, InfiniteData<GetNetworksFabricByIdBlocksResponse>, QueryKey<Options<GetNetworksFabricByIdBlocksData>>, number | Pick<QueryKey<Options<GetNetworksFabricByIdBlocksData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetNetworksFabricByIdBlocksData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getNetworksFabricByIdBlocks({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNetworksFabricByIdBlocksInfiniteQueryKey(options)
    });
};

export const getNetworksFabricByIdBlocksByBlockNumQueryKey = (options: Options<GetNetworksFabricByIdBlocksByBlockNumData>) => createQueryKey('getNetworksFabricByIdBlocksByBlockNum', options);

/**
 * Get transactions from a specific block
 * Get all transactions from a specific block in a Fabric network
 */
export const getNetworksFabricByIdBlocksByBlockNumOptions = (options: Options<GetNetworksFabricByIdBlocksByBlockNumData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNetworksFabricByIdBlocksByBlockNum({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNetworksFabricByIdBlocksByBlockNumQueryKey(options)
    });
};

export const getNetworksFabricByIdChannelConfigQueryKey = (options: Options<GetNetworksFabricByIdChannelConfigData>) => createQueryKey('getNetworksFabricByIdChannelConfig', options);

/**
 * Get Fabric network channel configuration
 * Retrieve the channel configuration for a Fabric network
 */
export const getNetworksFabricByIdChannelConfigOptions = (options: Options<GetNetworksFabricByIdChannelConfigData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNetworksFabricByIdChannelConfig({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNetworksFabricByIdChannelConfigQueryKey(options)
    });
};

export const getNetworksFabricByIdCurrentChannelConfigQueryKey = (options: Options<GetNetworksFabricByIdCurrentChannelConfigData>) => createQueryKey('getNetworksFabricByIdCurrentChannelConfig', options);

/**
 * Get Fabric network current channel configuration
 * Retrieve the current channel configuration for a Fabric network
 */
export const getNetworksFabricByIdCurrentChannelConfigOptions = (options: Options<GetNetworksFabricByIdCurrentChannelConfigData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNetworksFabricByIdCurrentChannelConfig({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNetworksFabricByIdCurrentChannelConfigQueryKey(options)
    });
};

export const getNetworksFabricByIdInfoQueryKey = (options: Options<GetNetworksFabricByIdInfoData>) => createQueryKey('getNetworksFabricByIdInfo', options);

/**
 * Get Fabric chain information
 * Retrieve detailed information about the Fabric blockchain including height and block hashes
 */
export const getNetworksFabricByIdInfoOptions = (options: Options<GetNetworksFabricByIdInfoData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNetworksFabricByIdInfo({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNetworksFabricByIdInfoQueryKey(options)
    });
};

export const getNetworksFabricByIdMapQueryKey = (options: Options<GetNetworksFabricByIdMapData>) => createQueryKey('getNetworksFabricByIdMap', options);

/**
 * Get network map
 * Get a map of all nodes (peers/orderers/validators) for a network, including endpoints and optionally health status.
 */
export const getNetworksFabricByIdMapOptions = (options: Options<GetNetworksFabricByIdMapData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNetworksFabricByIdMap({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNetworksFabricByIdMapQueryKey(options)
    });
};

export const getNetworksFabricByIdNodesQueryKey = (options: Options<GetNetworksFabricByIdNodesData>) => createQueryKey('getNetworksFabricByIdNodes', options);

/**
 * Get network nodes
 * Get all nodes associated with a network
 */
export const getNetworksFabricByIdNodesOptions = (options: Options<GetNetworksFabricByIdNodesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNetworksFabricByIdNodes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNetworksFabricByIdNodesQueryKey(options)
    });
};

export const postNetworksFabricByIdNodesQueryKey = (options: Options<PostNetworksFabricByIdNodesData>) => createQueryKey('postNetworksFabricByIdNodes', options);

/**
 * Add node to network
 * Add a node (peer or orderer) to an existing network
 */
export const postNetworksFabricByIdNodesOptions = (options: Options<PostNetworksFabricByIdNodesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNetworksFabricByIdNodes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNetworksFabricByIdNodesQueryKey(options)
    });
};

/**
 * Add node to network
 * Add a node (peer or orderer) to an existing network
 */
export const postNetworksFabricByIdNodesMutation = (options?: Partial<Options<PostNetworksFabricByIdNodesData>>): UseMutationOptions<PostNetworksFabricByIdNodesResponse, PostNetworksFabricByIdNodesError, Options<PostNetworksFabricByIdNodesData>> => {
    const mutationOptions: UseMutationOptions<PostNetworksFabricByIdNodesResponse, PostNetworksFabricByIdNodesError, Options<PostNetworksFabricByIdNodesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNetworksFabricByIdNodes({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove orderer from Fabric network
 * Remove an orderer node from an existing Fabric network
 */
export const deleteNetworksFabricByIdOrderersByOrdererIdMutation = (options?: Partial<Options<DeleteNetworksFabricByIdOrderersByOrdererIdData>>): UseMutationOptions<DeleteNetworksFabricByIdOrderersByOrdererIdResponse, DeleteNetworksFabricByIdOrderersByOrdererIdError, Options<DeleteNetworksFabricByIdOrderersByOrdererIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteNetworksFabricByIdOrderersByOrdererIdResponse, DeleteNetworksFabricByIdOrderersByOrdererIdError, Options<DeleteNetworksFabricByIdOrderersByOrdererIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteNetworksFabricByIdOrderersByOrdererId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postNetworksFabricByIdOrderersByOrdererIdJoinQueryKey = (options: Options<PostNetworksFabricByIdOrderersByOrdererIdJoinData>) => createQueryKey('postNetworksFabricByIdOrderersByOrdererIdJoin', options);

/**
 * Join orderer to Fabric network
 * Join an orderer node to an existing Fabric network
 */
export const postNetworksFabricByIdOrderersByOrdererIdJoinOptions = (options: Options<PostNetworksFabricByIdOrderersByOrdererIdJoinData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNetworksFabricByIdOrderersByOrdererIdJoin({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNetworksFabricByIdOrderersByOrdererIdJoinQueryKey(options)
    });
};

/**
 * Join orderer to Fabric network
 * Join an orderer node to an existing Fabric network
 */
export const postNetworksFabricByIdOrderersByOrdererIdJoinMutation = (options?: Partial<Options<PostNetworksFabricByIdOrderersByOrdererIdJoinData>>): UseMutationOptions<PostNetworksFabricByIdOrderersByOrdererIdJoinResponse, PostNetworksFabricByIdOrderersByOrdererIdJoinError, Options<PostNetworksFabricByIdOrderersByOrdererIdJoinData>> => {
    const mutationOptions: UseMutationOptions<PostNetworksFabricByIdOrderersByOrdererIdJoinResponse, PostNetworksFabricByIdOrderersByOrdererIdJoinError, Options<PostNetworksFabricByIdOrderersByOrdererIdJoinData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNetworksFabricByIdOrderersByOrdererIdJoin({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postNetworksFabricByIdOrderersByOrdererIdUnjoinQueryKey = (options: Options<PostNetworksFabricByIdOrderersByOrdererIdUnjoinData>) => createQueryKey('postNetworksFabricByIdOrderersByOrdererIdUnjoin', options);

/**
 * Unjoin orderer from Fabric network
 * Remove an orderer node from a channel but keep it in the network
 */
export const postNetworksFabricByIdOrderersByOrdererIdUnjoinOptions = (options: Options<PostNetworksFabricByIdOrderersByOrdererIdUnjoinData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNetworksFabricByIdOrderersByOrdererIdUnjoin({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNetworksFabricByIdOrderersByOrdererIdUnjoinQueryKey(options)
    });
};

/**
 * Unjoin orderer from Fabric network
 * Remove an orderer node from a channel but keep it in the network
 */
export const postNetworksFabricByIdOrderersByOrdererIdUnjoinMutation = (options?: Partial<Options<PostNetworksFabricByIdOrderersByOrdererIdUnjoinData>>): UseMutationOptions<PostNetworksFabricByIdOrderersByOrdererIdUnjoinResponse, PostNetworksFabricByIdOrderersByOrdererIdUnjoinError, Options<PostNetworksFabricByIdOrderersByOrdererIdUnjoinData>> => {
    const mutationOptions: UseMutationOptions<PostNetworksFabricByIdOrderersByOrdererIdUnjoinResponse, PostNetworksFabricByIdOrderersByOrdererIdUnjoinError, Options<PostNetworksFabricByIdOrderersByOrdererIdUnjoinData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNetworksFabricByIdOrderersByOrdererIdUnjoin({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postNetworksFabricByIdOrganizationCrlQueryKey = (options: Options<PostNetworksFabricByIdOrganizationCrlData>) => createQueryKey('postNetworksFabricByIdOrganizationCrl', options);

/**
 * Update organization CRL
 * Update the Certificate Revocation List (CRL) for an organization in the network
 */
export const postNetworksFabricByIdOrganizationCrlOptions = (options: Options<PostNetworksFabricByIdOrganizationCrlData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNetworksFabricByIdOrganizationCrl({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNetworksFabricByIdOrganizationCrlQueryKey(options)
    });
};

/**
 * Update organization CRL
 * Update the Certificate Revocation List (CRL) for an organization in the network
 */
export const postNetworksFabricByIdOrganizationCrlMutation = (options?: Partial<Options<PostNetworksFabricByIdOrganizationCrlData>>): UseMutationOptions<PostNetworksFabricByIdOrganizationCrlResponse, PostNetworksFabricByIdOrganizationCrlError, Options<PostNetworksFabricByIdOrganizationCrlData>> => {
    const mutationOptions: UseMutationOptions<PostNetworksFabricByIdOrganizationCrlResponse, PostNetworksFabricByIdOrganizationCrlError, Options<PostNetworksFabricByIdOrganizationCrlData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNetworksFabricByIdOrganizationCrl({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNetworksFabricByIdOrganizationsByOrgIdConfigQueryKey = (options: Options<GetNetworksFabricByIdOrganizationsByOrgIdConfigData>) => createQueryKey('getNetworksFabricByIdOrganizationsByOrgIdConfig', options);

/**
 * Get network configuration
 * Get the network configuration as YAML
 */
export const getNetworksFabricByIdOrganizationsByOrgIdConfigOptions = (options: Options<GetNetworksFabricByIdOrganizationsByOrgIdConfigData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNetworksFabricByIdOrganizationsByOrgIdConfig({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNetworksFabricByIdOrganizationsByOrgIdConfigQueryKey(options)
    });
};

/**
 * Remove peer from Fabric network
 * Remove a peer node from an existing Fabric network
 */
export const deleteNetworksFabricByIdPeersByPeerIdMutation = (options?: Partial<Options<DeleteNetworksFabricByIdPeersByPeerIdData>>): UseMutationOptions<DeleteNetworksFabricByIdPeersByPeerIdResponse, DeleteNetworksFabricByIdPeersByPeerIdError, Options<DeleteNetworksFabricByIdPeersByPeerIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteNetworksFabricByIdPeersByPeerIdResponse, DeleteNetworksFabricByIdPeersByPeerIdError, Options<DeleteNetworksFabricByIdPeersByPeerIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteNetworksFabricByIdPeersByPeerId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postNetworksFabricByIdPeersByPeerIdJoinQueryKey = (options: Options<PostNetworksFabricByIdPeersByPeerIdJoinData>) => createQueryKey('postNetworksFabricByIdPeersByPeerIdJoin', options);

/**
 * Join peer to Fabric network
 * Join a peer node to an existing Fabric network
 */
export const postNetworksFabricByIdPeersByPeerIdJoinOptions = (options: Options<PostNetworksFabricByIdPeersByPeerIdJoinData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNetworksFabricByIdPeersByPeerIdJoin({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNetworksFabricByIdPeersByPeerIdJoinQueryKey(options)
    });
};

/**
 * Join peer to Fabric network
 * Join a peer node to an existing Fabric network
 */
export const postNetworksFabricByIdPeersByPeerIdJoinMutation = (options?: Partial<Options<PostNetworksFabricByIdPeersByPeerIdJoinData>>): UseMutationOptions<PostNetworksFabricByIdPeersByPeerIdJoinResponse, PostNetworksFabricByIdPeersByPeerIdJoinError, Options<PostNetworksFabricByIdPeersByPeerIdJoinData>> => {
    const mutationOptions: UseMutationOptions<PostNetworksFabricByIdPeersByPeerIdJoinResponse, PostNetworksFabricByIdPeersByPeerIdJoinError, Options<PostNetworksFabricByIdPeersByPeerIdJoinData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNetworksFabricByIdPeersByPeerIdJoin({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postNetworksFabricByIdPeersByPeerIdUnjoinQueryKey = (options: Options<PostNetworksFabricByIdPeersByPeerIdUnjoinData>) => createQueryKey('postNetworksFabricByIdPeersByPeerIdUnjoin', options);

/**
 * Unjoin peer from Fabric network
 * Remove a peer node from a channel but keep it in the network
 */
export const postNetworksFabricByIdPeersByPeerIdUnjoinOptions = (options: Options<PostNetworksFabricByIdPeersByPeerIdUnjoinData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNetworksFabricByIdPeersByPeerIdUnjoin({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNetworksFabricByIdPeersByPeerIdUnjoinQueryKey(options)
    });
};

/**
 * Unjoin peer from Fabric network
 * Remove a peer node from a channel but keep it in the network
 */
export const postNetworksFabricByIdPeersByPeerIdUnjoinMutation = (options?: Partial<Options<PostNetworksFabricByIdPeersByPeerIdUnjoinData>>): UseMutationOptions<PostNetworksFabricByIdPeersByPeerIdUnjoinResponse, PostNetworksFabricByIdPeersByPeerIdUnjoinError, Options<PostNetworksFabricByIdPeersByPeerIdUnjoinData>> => {
    const mutationOptions: UseMutationOptions<PostNetworksFabricByIdPeersByPeerIdUnjoinResponse, PostNetworksFabricByIdPeersByPeerIdUnjoinError, Options<PostNetworksFabricByIdPeersByPeerIdUnjoinData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNetworksFabricByIdPeersByPeerIdUnjoin({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postNetworksFabricByIdReloadBlockQueryKey = (options: Options<PostNetworksFabricByIdReloadBlockData>) => createQueryKey('postNetworksFabricByIdReloadBlock', options);

/**
 * Reload network config block
 * Reloads the current config block for a network
 */
export const postNetworksFabricByIdReloadBlockOptions = (options: Options<PostNetworksFabricByIdReloadBlockData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNetworksFabricByIdReloadBlock({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNetworksFabricByIdReloadBlockQueryKey(options)
    });
};

/**
 * Reload network config block
 * Reloads the current config block for a network
 */
export const postNetworksFabricByIdReloadBlockMutation = (options?: Partial<Options<PostNetworksFabricByIdReloadBlockData>>): UseMutationOptions<PostNetworksFabricByIdReloadBlockResponse, PostNetworksFabricByIdReloadBlockError, Options<PostNetworksFabricByIdReloadBlockData>> => {
    const mutationOptions: UseMutationOptions<PostNetworksFabricByIdReloadBlockResponse, PostNetworksFabricByIdReloadBlockError, Options<PostNetworksFabricByIdReloadBlockData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNetworksFabricByIdReloadBlock({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNetworksFabricByIdTransactionsByTxIdQueryKey = (options: Options<GetNetworksFabricByIdTransactionsByTxIdData>) => createQueryKey('getNetworksFabricByIdTransactionsByTxId', options);

/**
 * Get transaction details by transaction ID
 * Get detailed information about a specific transaction in a Fabric network
 */
export const getNetworksFabricByIdTransactionsByTxIdOptions = (options: Options<GetNetworksFabricByIdTransactionsByTxIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNetworksFabricByIdTransactionsByTxId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNetworksFabricByIdTransactionsByTxIdQueryKey(options)
    });
};

export const postNetworksFabricByIdUpdateConfigQueryKey = (options: Options<PostNetworksFabricByIdUpdateConfigData>) => createQueryKey('postNetworksFabricByIdUpdateConfig', options);

/**
 * Prepare a config update for a Fabric network
 * Prepare a config update proposal for a Fabric network using the provided operations.
 * The following operation types are supported:
 * - add_org: Add a new organization to the channel
 * - remove_org: Remove an organization from the channel
 * - update_org_msp: Update an organization's MSP configuration
 * - set_anchor_peers: Set anchor peers for an organization
 * - add_consenter: Add a new consenter to the orderer
 * - remove_consenter: Remove a consenter from the orderer
 * - update_consenter: Update a consenter in the orderer
 * - update_etcd_raft_options: Update etcd raft options for the orderer
 * - update_batch_size: Update batch size for the orderer
 * - update_batch_timeout: Update batch timeout for the orderer
 * - update_application_policy: Update application policy for the channel
 * - update_orderer_policy: Update orderer policy for the channel
 * - update_channel_policy: Update channel policy for the channel
 * - update_channel_capability: Update channel capability for the channel
 * - update_orderer_capability: Update orderer capability for the channel
 * - update_application_capability: Update application capability for the channel
 * - add_orderer_org: Add a new orderer organization to the channel
 * - remove_orderer_org: Remove an orderer organization from the channel
 * - update_orderer_org_msp: Update an orderer organization's MSP configuration
 * - update_application_acl: Update application ACL for the channel
 */
export const postNetworksFabricByIdUpdateConfigOptions = (options: Options<PostNetworksFabricByIdUpdateConfigData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNetworksFabricByIdUpdateConfig({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNetworksFabricByIdUpdateConfigQueryKey(options)
    });
};

/**
 * Prepare a config update for a Fabric network
 * Prepare a config update proposal for a Fabric network using the provided operations.
 * The following operation types are supported:
 * - add_org: Add a new organization to the channel
 * - remove_org: Remove an organization from the channel
 * - update_org_msp: Update an organization's MSP configuration
 * - set_anchor_peers: Set anchor peers for an organization
 * - add_consenter: Add a new consenter to the orderer
 * - remove_consenter: Remove a consenter from the orderer
 * - update_consenter: Update a consenter in the orderer
 * - update_etcd_raft_options: Update etcd raft options for the orderer
 * - update_batch_size: Update batch size for the orderer
 * - update_batch_timeout: Update batch timeout for the orderer
 * - update_application_policy: Update application policy for the channel
 * - update_orderer_policy: Update orderer policy for the channel
 * - update_channel_policy: Update channel policy for the channel
 * - update_channel_capability: Update channel capability for the channel
 * - update_orderer_capability: Update orderer capability for the channel
 * - update_application_capability: Update application capability for the channel
 * - add_orderer_org: Add a new orderer organization to the channel
 * - remove_orderer_org: Remove an orderer organization from the channel
 * - update_orderer_org_msp: Update an orderer organization's MSP configuration
 * - update_application_acl: Update application ACL for the channel
 */
export const postNetworksFabricByIdUpdateConfigMutation = (options?: Partial<Options<PostNetworksFabricByIdUpdateConfigData>>): UseMutationOptions<PostNetworksFabricByIdUpdateConfigResponse, PostNetworksFabricByIdUpdateConfigError, Options<PostNetworksFabricByIdUpdateConfigData>> => {
    const mutationOptions: UseMutationOptions<PostNetworksFabricByIdUpdateConfigResponse, PostNetworksFabricByIdUpdateConfigError, Options<PostNetworksFabricByIdUpdateConfigData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNetworksFabricByIdUpdateConfig({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update genesis block for a network
 * Update the genesis block for a network with change tracking
 */
export const putNetworksByIdGenesisMutation = (options?: Partial<Options<PutNetworksByIdGenesisData>>): UseMutationOptions<PutNetworksByIdGenesisResponse, PutNetworksByIdGenesisError, Options<PutNetworksByIdGenesisData>> => {
    const mutationOptions: UseMutationOptions<PutNetworksByIdGenesisResponse, PutNetworksByIdGenesisError, Options<PutNetworksByIdGenesisData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putNetworksByIdGenesis({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNodesQueryKey = (options?: Options<GetNodesData>) => createQueryKey('getNodes', options);

/**
 * List all nodes
 * Get a paginated list of nodes with optional platform filter
 */
export const getNodesOptions = (options?: Options<GetNodesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesQueryKey(options)
    });
};

export const getNodesInfiniteQueryKey = (options?: Options<GetNodesData>): QueryKey<Options<GetNodesData>> => createQueryKey('getNodes', options, true);

/**
 * List all nodes
 * Get a paginated list of nodes with optional platform filter
 */
export const getNodesInfiniteOptions = (options?: Options<GetNodesData>) => {
    return infiniteQueryOptions<GetNodesResponse, GetNodesError, InfiniteData<GetNodesResponse>, QueryKey<Options<GetNodesData>>, number | Pick<QueryKey<Options<GetNodesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetNodesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getNodes({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesInfiniteQueryKey(options)
    });
};

export const postNodesQueryKey = (options: Options<PostNodesData>) => createQueryKey('postNodes', options);

/**
 * Create a new node
 * Create a new node with the specified configuration
 */
export const postNodesOptions = (options: Options<PostNodesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNodes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNodesQueryKey(options)
    });
};

/**
 * Create a new node
 * Create a new node with the specified configuration
 */
export const postNodesMutation = (options?: Partial<Options<PostNodesData>>): UseMutationOptions<PostNodesResponse, PostNodesError, Options<PostNodesData>> => {
    const mutationOptions: UseMutationOptions<PostNodesResponse, PostNodesError, Options<PostNodesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNodes({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNodesDefaultsBesuNodeQueryKey = (options?: Options<GetNodesDefaultsBesuNodeData>) => createQueryKey('getNodesDefaultsBesuNode', options);

/**
 * Get default values for Besu node
 * Get default configuration values for a Besu node
 */
export const getNodesDefaultsBesuNodeOptions = (options?: Options<GetNodesDefaultsBesuNodeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesDefaultsBesuNode({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesDefaultsBesuNodeQueryKey(options)
    });
};

export const getNodesDefaultsFabricQueryKey = (options?: Options<GetNodesDefaultsFabricData>) => createQueryKey('getNodesDefaultsFabric', options);

/**
 * Get default values for multiple Fabric nodes
 * Get default configuration values for multiple Fabric nodes
 */
export const getNodesDefaultsFabricOptions = (options?: Options<GetNodesDefaultsFabricData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesDefaultsFabric({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesDefaultsFabricQueryKey(options)
    });
};

export const getNodesDefaultsFabricOrdererQueryKey = (options?: Options<GetNodesDefaultsFabricOrdererData>) => createQueryKey('getNodesDefaultsFabricOrderer', options);

/**
 * Get default values for Fabric orderer node
 * Get default configuration values for a Fabric orderer node
 */
export const getNodesDefaultsFabricOrdererOptions = (options?: Options<GetNodesDefaultsFabricOrdererData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesDefaultsFabricOrderer({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesDefaultsFabricOrdererQueryKey(options)
    });
};

export const getNodesDefaultsFabricPeerQueryKey = (options?: Options<GetNodesDefaultsFabricPeerData>) => createQueryKey('getNodesDefaultsFabricPeer', options);

/**
 * Get default values for Fabric peer node
 * Get default configuration values for a Fabric peer node
 */
export const getNodesDefaultsFabricPeerOptions = (options?: Options<GetNodesDefaultsFabricPeerData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesDefaultsFabricPeer({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesDefaultsFabricPeerQueryKey(options)
    });
};

export const getNodesPlatformByPlatformQueryKey = (options: Options<GetNodesPlatformByPlatformData>) => createQueryKey('getNodesPlatformByPlatform', options);

/**
 * List nodes by platform
 * Get a paginated list of nodes filtered by blockchain platform
 */
export const getNodesPlatformByPlatformOptions = (options: Options<GetNodesPlatformByPlatformData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesPlatformByPlatform({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesPlatformByPlatformQueryKey(options)
    });
};

export const getNodesPlatformByPlatformInfiniteQueryKey = (options: Options<GetNodesPlatformByPlatformData>): QueryKey<Options<GetNodesPlatformByPlatformData>> => createQueryKey('getNodesPlatformByPlatform', options, true);

/**
 * List nodes by platform
 * Get a paginated list of nodes filtered by blockchain platform
 */
export const getNodesPlatformByPlatformInfiniteOptions = (options: Options<GetNodesPlatformByPlatformData>) => {
    return infiniteQueryOptions<GetNodesPlatformByPlatformResponse, GetNodesPlatformByPlatformError, InfiniteData<GetNodesPlatformByPlatformResponse>, QueryKey<Options<GetNodesPlatformByPlatformData>>, number | Pick<QueryKey<Options<GetNodesPlatformByPlatformData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetNodesPlatformByPlatformData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getNodesPlatformByPlatform({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesPlatformByPlatformInfiniteQueryKey(options)
    });
};

/**
 * Delete a node
 * Delete a node by ID
 */
export const deleteNodesByIdMutation = (options?: Partial<Options<DeleteNodesByIdData>>): UseMutationOptions<unknown, DeleteNodesByIdError, Options<DeleteNodesByIdData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteNodesByIdError, Options<DeleteNodesByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteNodesById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNodesByIdQueryKey = (options: Options<GetNodesByIdData>) => createQueryKey('getNodesById', options);

/**
 * Get a node
 * Get a node by ID
 */
export const getNodesByIdOptions = (options: Options<GetNodesByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdQueryKey(options)
    });
};

/**
 * Update a node
 * Updates an existing node's configuration based on its type
 */
export const putNodesByIdMutation = (options?: Partial<Options<PutNodesByIdData>>): UseMutationOptions<PutNodesByIdResponse, PutNodesByIdError, Options<PutNodesByIdData>> => {
    const mutationOptions: UseMutationOptions<PutNodesByIdResponse, PutNodesByIdError, Options<PutNodesByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putNodesById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postNodesByIdCertificatesRenewQueryKey = (options: Options<PostNodesByIdCertificatesRenewData>) => createQueryKey('postNodesByIdCertificatesRenew', options);

/**
 * Renew node certificates
 * Renews the TLS and signing certificates for a Fabric node
 */
export const postNodesByIdCertificatesRenewOptions = (options: Options<PostNodesByIdCertificatesRenewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNodesByIdCertificatesRenew({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNodesByIdCertificatesRenewQueryKey(options)
    });
};

/**
 * Renew node certificates
 * Renews the TLS and signing certificates for a Fabric node
 */
export const postNodesByIdCertificatesRenewMutation = (options?: Partial<Options<PostNodesByIdCertificatesRenewData>>): UseMutationOptions<PostNodesByIdCertificatesRenewResponse, PostNodesByIdCertificatesRenewError, Options<PostNodesByIdCertificatesRenewData>> => {
    const mutationOptions: UseMutationOptions<PostNodesByIdCertificatesRenewResponse, PostNodesByIdCertificatesRenewError, Options<PostNodesByIdCertificatesRenewData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNodesByIdCertificatesRenew({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNodesByIdChannelsQueryKey = (options: Options<GetNodesByIdChannelsData>) => createQueryKey('getNodesByIdChannels', options);

/**
 * Get channels for a Fabric node
 * Retrieves all channels for a specific Fabric node
 */
export const getNodesByIdChannelsOptions = (options: Options<GetNodesByIdChannelsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdChannels({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdChannelsQueryKey(options)
    });
};

export const getNodesByIdChannelsByChannelIdChaincodesQueryKey = (options: Options<GetNodesByIdChannelsByChannelIdChaincodesData>) => createQueryKey('getNodesByIdChannelsByChannelIdChaincodes', options);

/**
 * Get committed chaincodes for a Fabric peer
 * Retrieves all committed chaincodes for a specific channel on a Fabric peer node
 */
export const getNodesByIdChannelsByChannelIdChaincodesOptions = (options: Options<GetNodesByIdChannelsByChannelIdChaincodesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdChannelsByChannelIdChaincodes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdChannelsByChannelIdChaincodesQueryKey(options)
    });
};

export const getNodesByIdEventsQueryKey = (options: Options<GetNodesByIdEventsData>) => createQueryKey('getNodesByIdEvents', options);

/**
 * Get node events
 * Get a paginated list of events for a specific node
 */
export const getNodesByIdEventsOptions = (options: Options<GetNodesByIdEventsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdEvents({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdEventsQueryKey(options)
    });
};

export const getNodesByIdEventsInfiniteQueryKey = (options: Options<GetNodesByIdEventsData>): QueryKey<Options<GetNodesByIdEventsData>> => createQueryKey('getNodesByIdEvents', options, true);

/**
 * Get node events
 * Get a paginated list of events for a specific node
 */
export const getNodesByIdEventsInfiniteOptions = (options: Options<GetNodesByIdEventsData>) => {
    return infiniteQueryOptions<GetNodesByIdEventsResponse, GetNodesByIdEventsError, InfiniteData<GetNodesByIdEventsResponse>, QueryKey<Options<GetNodesByIdEventsData>>, number | Pick<QueryKey<Options<GetNodesByIdEventsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetNodesByIdEventsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getNodesByIdEvents({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdEventsInfiniteQueryKey(options)
    });
};

export const getNodesByIdLogsQueryKey = (options: Options<GetNodesByIdLogsData>) => createQueryKey('getNodesByIdLogs', options);

/**
 * Tail node logs
 * Stream logs from a specific node
 */
export const getNodesByIdLogsOptions = (options: Options<GetNodesByIdLogsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdLogs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdLogsQueryKey(options)
    });
};

export const postNodesByIdRestartQueryKey = (options: Options<PostNodesByIdRestartData>) => createQueryKey('postNodesByIdRestart', options);

/**
 * Restart a node
 * Restart a node by ID (stops and starts the node)
 */
export const postNodesByIdRestartOptions = (options: Options<PostNodesByIdRestartData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNodesByIdRestart({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNodesByIdRestartQueryKey(options)
    });
};

/**
 * Restart a node
 * Restart a node by ID (stops and starts the node)
 */
export const postNodesByIdRestartMutation = (options?: Partial<Options<PostNodesByIdRestartData>>): UseMutationOptions<PostNodesByIdRestartResponse, PostNodesByIdRestartError, Options<PostNodesByIdRestartData>> => {
    const mutationOptions: UseMutationOptions<PostNodesByIdRestartResponse, PostNodesByIdRestartError, Options<PostNodesByIdRestartData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNodesByIdRestart({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNodesByIdRpcAccountsQueryKey = (options: Options<GetNodesByIdRpcAccountsData>) => createQueryKey('getNodesByIdRpcAccounts', options);

/**
 * Get accounts managed by the Besu node
 * Lists accounts managed by the node
 */
export const getNodesByIdRpcAccountsOptions = (options: Options<GetNodesByIdRpcAccountsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcAccounts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcAccountsQueryKey(options)
    });
};

export const getNodesByIdRpcBalanceQueryKey = (options: Options<GetNodesByIdRpcBalanceData>) => createQueryKey('getNodesByIdRpcBalance', options);

/**
 * Get balance of an address
 * Gets balance of an address in Wei
 */
export const getNodesByIdRpcBalanceOptions = (options: Options<GetNodesByIdRpcBalanceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcBalance({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcBalanceQueryKey(options)
    });
};

export const getNodesByIdRpcBlockByHashQueryKey = (options: Options<GetNodesByIdRpcBlockByHashData>) => createQueryKey('getNodesByIdRpcBlockByHash', options);

/**
 * Get block by hash
 * Gets block details by hash
 */
export const getNodesByIdRpcBlockByHashOptions = (options: Options<GetNodesByIdRpcBlockByHashData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcBlockByHash({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcBlockByHashQueryKey(options)
    });
};

export const getNodesByIdRpcBlockByNumberQueryKey = (options: Options<GetNodesByIdRpcBlockByNumberData>) => createQueryKey('getNodesByIdRpcBlockByNumber', options);

/**
 * Get block by number
 * Gets block by number or tag
 */
export const getNodesByIdRpcBlockByNumberOptions = (options: Options<GetNodesByIdRpcBlockByNumberData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcBlockByNumber({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcBlockByNumberQueryKey(options)
    });
};

export const getNodesByIdRpcBlockNumberQueryKey = (options: Options<GetNodesByIdRpcBlockNumberData>) => createQueryKey('getNodesByIdRpcBlockNumber', options);

/**
 * Get latest block number
 * Gets the latest block number
 */
export const getNodesByIdRpcBlockNumberOptions = (options: Options<GetNodesByIdRpcBlockNumberData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcBlockNumber({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcBlockNumberQueryKey(options)
    });
};

export const getNodesByIdRpcBlockTransactionCountByHashQueryKey = (options: Options<GetNodesByIdRpcBlockTransactionCountByHashData>) => createQueryKey('getNodesByIdRpcBlockTransactionCountByHash', options);

/**
 * Get transaction count in block by hash
 * Gets transaction count in a block by hash
 */
export const getNodesByIdRpcBlockTransactionCountByHashOptions = (options: Options<GetNodesByIdRpcBlockTransactionCountByHashData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcBlockTransactionCountByHash({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcBlockTransactionCountByHashQueryKey(options)
    });
};

export const getNodesByIdRpcBlockTransactionCountByNumberQueryKey = (options: Options<GetNodesByIdRpcBlockTransactionCountByNumberData>) => createQueryKey('getNodesByIdRpcBlockTransactionCountByNumber', options);

/**
 * Get transaction count in block by number
 * Gets transaction count by block number
 */
export const getNodesByIdRpcBlockTransactionCountByNumberOptions = (options: Options<GetNodesByIdRpcBlockTransactionCountByNumberData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcBlockTransactionCountByNumber({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcBlockTransactionCountByNumberQueryKey(options)
    });
};

export const getNodesByIdRpcChainIdQueryKey = (options: Options<GetNodesByIdRpcChainIdData>) => createQueryKey('getNodesByIdRpcChainId', options);

/**
 * Get chain ID
 * Gets the chain ID
 */
export const getNodesByIdRpcChainIdOptions = (options: Options<GetNodesByIdRpcChainIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcChainId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcChainIdQueryKey(options)
    });
};

export const getNodesByIdRpcCodeQueryKey = (options: Options<GetNodesByIdRpcCodeData>) => createQueryKey('getNodesByIdRpcCode', options);

/**
 * Get bytecode at an address
 * Gets bytecode at an address (e.g., contract code)
 */
export const getNodesByIdRpcCodeOptions = (options: Options<GetNodesByIdRpcCodeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcCode({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcCodeQueryKey(options)
    });
};

export const getNodesByIdRpcFeeHistoryQueryKey = (options: Options<GetNodesByIdRpcFeeHistoryData>) => createQueryKey('getNodesByIdRpcFeeHistory', options);

/**
 * Get fee history
 * Gets historical gas fees
 */
export const getNodesByIdRpcFeeHistoryOptions = (options: Options<GetNodesByIdRpcFeeHistoryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcFeeHistory({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcFeeHistoryQueryKey(options)
    });
};

export const postNodesByIdRpcLogsQueryKey = (options: Options<PostNodesByIdRpcLogsData>) => createQueryKey('postNodesByIdRpcLogs', options);

/**
 * Get event logs
 * Gets event logs based on filter criteria
 */
export const postNodesByIdRpcLogsOptions = (options: Options<PostNodesByIdRpcLogsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNodesByIdRpcLogs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNodesByIdRpcLogsQueryKey(options)
    });
};

/**
 * Get event logs
 * Gets event logs based on filter criteria
 */
export const postNodesByIdRpcLogsMutation = (options?: Partial<Options<PostNodesByIdRpcLogsData>>): UseMutationOptions<PostNodesByIdRpcLogsResponse, PostNodesByIdRpcLogsError, Options<PostNodesByIdRpcLogsData>> => {
    const mutationOptions: UseMutationOptions<PostNodesByIdRpcLogsResponse, PostNodesByIdRpcLogsError, Options<PostNodesByIdRpcLogsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNodesByIdRpcLogs({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNodesByIdRpcPendingTransactionsQueryKey = (options: Options<GetNodesByIdRpcPendingTransactionsData>) => createQueryKey('getNodesByIdRpcPendingTransactions', options);

/**
 * Get pending transactions
 * Gets pending transactions in the mempool
 */
export const getNodesByIdRpcPendingTransactionsOptions = (options: Options<GetNodesByIdRpcPendingTransactionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcPendingTransactions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcPendingTransactionsQueryKey(options)
    });
};

export const getNodesByIdRpcProtocolVersionQueryKey = (options: Options<GetNodesByIdRpcProtocolVersionData>) => createQueryKey('getNodesByIdRpcProtocolVersion', options);

/**
 * Get protocol version
 * Gets Ethereum protocol version
 */
export const getNodesByIdRpcProtocolVersionOptions = (options: Options<GetNodesByIdRpcProtocolVersionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcProtocolVersion({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcProtocolVersionQueryKey(options)
    });
};

export const postNodesByIdRpcQbftDiscardValidatorVoteQueryKey = (options: Options<PostNodesByIdRpcQbftDiscardValidatorVoteData>) => createQueryKey('postNodesByIdRpcQbftDiscardValidatorVote', options);

/**
 * Discard QBFT validator vote
 * Discards a pending vote for a validator proposal
 */
export const postNodesByIdRpcQbftDiscardValidatorVoteOptions = (options: Options<PostNodesByIdRpcQbftDiscardValidatorVoteData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNodesByIdRpcQbftDiscardValidatorVote({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNodesByIdRpcQbftDiscardValidatorVoteQueryKey(options)
    });
};

/**
 * Discard QBFT validator vote
 * Discards a pending vote for a validator proposal
 */
export const postNodesByIdRpcQbftDiscardValidatorVoteMutation = (options?: Partial<Options<PostNodesByIdRpcQbftDiscardValidatorVoteData>>): UseMutationOptions<PostNodesByIdRpcQbftDiscardValidatorVoteResponse, PostNodesByIdRpcQbftDiscardValidatorVoteError, Options<PostNodesByIdRpcQbftDiscardValidatorVoteData>> => {
    const mutationOptions: UseMutationOptions<PostNodesByIdRpcQbftDiscardValidatorVoteResponse, PostNodesByIdRpcQbftDiscardValidatorVoteError, Options<PostNodesByIdRpcQbftDiscardValidatorVoteData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNodesByIdRpcQbftDiscardValidatorVote({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNodesByIdRpcQbftPendingVotesQueryKey = (options: Options<GetNodesByIdRpcQbftPendingVotesData>) => createQueryKey('getNodesByIdRpcQbftPendingVotes', options);

/**
 * Get QBFT pending votes
 * Retrieves a map of pending validator proposals where keys are validator addresses and values are boolean (true indicates pending vote)
 */
export const getNodesByIdRpcQbftPendingVotesOptions = (options: Options<GetNodesByIdRpcQbftPendingVotesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcQbftPendingVotes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcQbftPendingVotesQueryKey(options)
    });
};

export const postNodesByIdRpcQbftProposeValidatorVoteQueryKey = (options: Options<PostNodesByIdRpcQbftProposeValidatorVoteData>) => createQueryKey('postNodesByIdRpcQbftProposeValidatorVote', options);

/**
 * Propose QBFT validator vote
 * Proposes a vote to add (true) or remove (false) a validator
 */
export const postNodesByIdRpcQbftProposeValidatorVoteOptions = (options: Options<PostNodesByIdRpcQbftProposeValidatorVoteData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNodesByIdRpcQbftProposeValidatorVote({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNodesByIdRpcQbftProposeValidatorVoteQueryKey(options)
    });
};

/**
 * Propose QBFT validator vote
 * Proposes a vote to add (true) or remove (false) a validator
 */
export const postNodesByIdRpcQbftProposeValidatorVoteMutation = (options?: Partial<Options<PostNodesByIdRpcQbftProposeValidatorVoteData>>): UseMutationOptions<PostNodesByIdRpcQbftProposeValidatorVoteResponse, PostNodesByIdRpcQbftProposeValidatorVoteError, Options<PostNodesByIdRpcQbftProposeValidatorVoteData>> => {
    const mutationOptions: UseMutationOptions<PostNodesByIdRpcQbftProposeValidatorVoteResponse, PostNodesByIdRpcQbftProposeValidatorVoteError, Options<PostNodesByIdRpcQbftProposeValidatorVoteData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNodesByIdRpcQbftProposeValidatorVote({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNodesByIdRpcQbftRequestTimeoutQueryKey = (options: Options<GetNodesByIdRpcQbftRequestTimeoutData>) => createQueryKey('getNodesByIdRpcQbftRequestTimeout', options);

/**
 * Get QBFT request timeout
 * Gets QBFT request timeout in seconds
 */
export const getNodesByIdRpcQbftRequestTimeoutOptions = (options: Options<GetNodesByIdRpcQbftRequestTimeoutData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcQbftRequestTimeout({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcQbftRequestTimeoutQueryKey(options)
    });
};

export const getNodesByIdRpcQbftSignerMetricsQueryKey = (options: Options<GetNodesByIdRpcQbftSignerMetricsData>) => createQueryKey('getNodesByIdRpcQbftSignerMetrics', options);

/**
 * Get QBFT signer metrics
 * Gets QBFT signer metrics
 */
export const getNodesByIdRpcQbftSignerMetricsOptions = (options: Options<GetNodesByIdRpcQbftSignerMetricsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcQbftSignerMetrics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcQbftSignerMetricsQueryKey(options)
    });
};

export const getNodesByIdRpcQbftValidatorsByBlockHashQueryKey = (options: Options<GetNodesByIdRpcQbftValidatorsByBlockHashData>) => createQueryKey('getNodesByIdRpcQbftValidatorsByBlockHash', options);

/**
 * Get QBFT validators by block hash
 * Retrieves the list of validators for a specific block by its hash
 */
export const getNodesByIdRpcQbftValidatorsByBlockHashOptions = (options: Options<GetNodesByIdRpcQbftValidatorsByBlockHashData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcQbftValidatorsByBlockHash({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcQbftValidatorsByBlockHashQueryKey(options)
    });
};

export const getNodesByIdRpcQbftValidatorsByBlockNumberQueryKey = (options: Options<GetNodesByIdRpcQbftValidatorsByBlockNumberData>) => createQueryKey('getNodesByIdRpcQbftValidatorsByBlockNumber', options);

/**
 * Get QBFT validators by block number
 * Retrieves the list of validators for a specific block by its number
 */
export const getNodesByIdRpcQbftValidatorsByBlockNumberOptions = (options: Options<GetNodesByIdRpcQbftValidatorsByBlockNumberData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcQbftValidatorsByBlockNumber({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcQbftValidatorsByBlockNumberQueryKey(options)
    });
};

export const getNodesByIdRpcStorageQueryKey = (options: Options<GetNodesByIdRpcStorageData>) => createQueryKey('getNodesByIdRpcStorage', options);

/**
 * Get storage value at a position
 * Gets storage value at a position for an address
 */
export const getNodesByIdRpcStorageOptions = (options: Options<GetNodesByIdRpcStorageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcStorage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcStorageQueryKey(options)
    });
};

export const getNodesByIdRpcSyncingQueryKey = (options: Options<GetNodesByIdRpcSyncingData>) => createQueryKey('getNodesByIdRpcSyncing', options);

/**
 * Get sync status
 * Gets sync status
 */
export const getNodesByIdRpcSyncingOptions = (options: Options<GetNodesByIdRpcSyncingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcSyncing({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcSyncingQueryKey(options)
    });
};

export const getNodesByIdRpcTransactionByBlockHashAndIndexQueryKey = (options: Options<GetNodesByIdRpcTransactionByBlockHashAndIndexData>) => createQueryKey('getNodesByIdRpcTransactionByBlockHashAndIndex', options);

/**
 * Get transaction by block hash and index
 * Gets transaction by block hash and index
 */
export const getNodesByIdRpcTransactionByBlockHashAndIndexOptions = (options: Options<GetNodesByIdRpcTransactionByBlockHashAndIndexData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcTransactionByBlockHashAndIndex({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcTransactionByBlockHashAndIndexQueryKey(options)
    });
};

export const getNodesByIdRpcTransactionByBlockNumberAndIndexQueryKey = (options: Options<GetNodesByIdRpcTransactionByBlockNumberAndIndexData>) => createQueryKey('getNodesByIdRpcTransactionByBlockNumberAndIndex', options);

/**
 * Get transaction by block number and index
 * Gets transaction by block number and index
 */
export const getNodesByIdRpcTransactionByBlockNumberAndIndexOptions = (options: Options<GetNodesByIdRpcTransactionByBlockNumberAndIndexData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcTransactionByBlockNumberAndIndex({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcTransactionByBlockNumberAndIndexQueryKey(options)
    });
};

export const getNodesByIdRpcTransactionByHashQueryKey = (options: Options<GetNodesByIdRpcTransactionByHashData>) => createQueryKey('getNodesByIdRpcTransactionByHash', options);

/**
 * Get transaction by hash
 * Gets transaction details by hash
 */
export const getNodesByIdRpcTransactionByHashOptions = (options: Options<GetNodesByIdRpcTransactionByHashData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcTransactionByHash({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcTransactionByHashQueryKey(options)
    });
};

export const getNodesByIdRpcTransactionCountQueryKey = (options: Options<GetNodesByIdRpcTransactionCountData>) => createQueryKey('getNodesByIdRpcTransactionCount', options);

/**
 * Get transaction count for an address
 * Gets nonce (tx count) for an address
 */
export const getNodesByIdRpcTransactionCountOptions = (options: Options<GetNodesByIdRpcTransactionCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcTransactionCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcTransactionCountQueryKey(options)
    });
};

export const getNodesByIdRpcTransactionReceiptQueryKey = (options: Options<GetNodesByIdRpcTransactionReceiptData>) => createQueryKey('getNodesByIdRpcTransactionReceipt', options);

/**
 * Get transaction receipt
 * Gets receipt for a transaction
 */
export const getNodesByIdRpcTransactionReceiptOptions = (options: Options<GetNodesByIdRpcTransactionReceiptData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNodesByIdRpcTransactionReceipt({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNodesByIdRpcTransactionReceiptQueryKey(options)
    });
};

export const postNodesByIdStartQueryKey = (options: Options<PostNodesByIdStartData>) => createQueryKey('postNodesByIdStart', options);

/**
 * Start a node
 * Start a node by ID
 */
export const postNodesByIdStartOptions = (options: Options<PostNodesByIdStartData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNodesByIdStart({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNodesByIdStartQueryKey(options)
    });
};

/**
 * Start a node
 * Start a node by ID
 */
export const postNodesByIdStartMutation = (options?: Partial<Options<PostNodesByIdStartData>>): UseMutationOptions<PostNodesByIdStartResponse, PostNodesByIdStartError, Options<PostNodesByIdStartData>> => {
    const mutationOptions: UseMutationOptions<PostNodesByIdStartResponse, PostNodesByIdStartError, Options<PostNodesByIdStartData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNodesByIdStart({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postNodesByIdStopQueryKey = (options: Options<PostNodesByIdStopData>) => createQueryKey('postNodesByIdStop', options);

/**
 * Stop a node
 * Stop a node by ID
 */
export const postNodesByIdStopOptions = (options: Options<PostNodesByIdStopData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNodesByIdStop({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNodesByIdStopQueryKey(options)
    });
};

/**
 * Stop a node
 * Stop a node by ID
 */
export const postNodesByIdStopMutation = (options?: Partial<Options<PostNodesByIdStopData>>): UseMutationOptions<PostNodesByIdStopResponse, PostNodesByIdStopError, Options<PostNodesByIdStopData>> => {
    const mutationOptions: UseMutationOptions<PostNodesByIdStopResponse, PostNodesByIdStopError, Options<PostNodesByIdStopData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNodesByIdStop({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNotificationsProvidersQueryKey = (options?: Options<GetNotificationsProvidersData>) => createQueryKey('getNotificationsProviders', options);

/**
 * List notification providers
 * Get a list of all notification providers
 */
export const getNotificationsProvidersOptions = (options?: Options<GetNotificationsProvidersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNotificationsProviders({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNotificationsProvidersQueryKey(options)
    });
};

export const postNotificationsProvidersQueryKey = (options: Options<PostNotificationsProvidersData>) => createQueryKey('postNotificationsProviders', options);

/**
 * Create a notification provider
 * Create a new notification provider with the specified configuration
 */
export const postNotificationsProvidersOptions = (options: Options<PostNotificationsProvidersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNotificationsProviders({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNotificationsProvidersQueryKey(options)
    });
};

/**
 * Create a notification provider
 * Create a new notification provider with the specified configuration
 */
export const postNotificationsProvidersMutation = (options?: Partial<Options<PostNotificationsProvidersData>>): UseMutationOptions<PostNotificationsProvidersResponse, PostNotificationsProvidersError, Options<PostNotificationsProvidersData>> => {
    const mutationOptions: UseMutationOptions<PostNotificationsProvidersResponse, PostNotificationsProvidersError, Options<PostNotificationsProvidersData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNotificationsProviders({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a notification provider
 * Delete a notification provider
 */
export const deleteNotificationsProvidersByIdMutation = (options?: Partial<Options<DeleteNotificationsProvidersByIdData>>): UseMutationOptions<unknown, DeleteNotificationsProvidersByIdError, Options<DeleteNotificationsProvidersByIdData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteNotificationsProvidersByIdError, Options<DeleteNotificationsProvidersByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteNotificationsProvidersById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNotificationsProvidersByIdQueryKey = (options: Options<GetNotificationsProvidersByIdData>) => createQueryKey('getNotificationsProvidersById', options);

/**
 * Get a notification provider
 * Get detailed information about a specific notification provider
 */
export const getNotificationsProvidersByIdOptions = (options: Options<GetNotificationsProvidersByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNotificationsProvidersById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNotificationsProvidersByIdQueryKey(options)
    });
};

/**
 * Update a notification provider
 * Update an existing notification provider with new configuration
 */
export const putNotificationsProvidersByIdMutation = (options?: Partial<Options<PutNotificationsProvidersByIdData>>): UseMutationOptions<PutNotificationsProvidersByIdResponse, PutNotificationsProvidersByIdError, Options<PutNotificationsProvidersByIdData>> => {
    const mutationOptions: UseMutationOptions<PutNotificationsProvidersByIdResponse, PutNotificationsProvidersByIdError, Options<PutNotificationsProvidersByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putNotificationsProvidersById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postNotificationsProvidersByIdTestQueryKey = (options: Options<PostNotificationsProvidersByIdTestData>) => createQueryKey('postNotificationsProvidersByIdTest', options);

/**
 * Test a notification provider
 * Test a notification provider
 */
export const postNotificationsProvidersByIdTestOptions = (options: Options<PostNotificationsProvidersByIdTestData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postNotificationsProvidersByIdTest({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postNotificationsProvidersByIdTestQueryKey(options)
    });
};

/**
 * Test a notification provider
 * Test a notification provider
 */
export const postNotificationsProvidersByIdTestMutation = (options?: Partial<Options<PostNotificationsProvidersByIdTestData>>): UseMutationOptions<PostNotificationsProvidersByIdTestResponse, PostNotificationsProvidersByIdTestError, Options<PostNotificationsProvidersByIdTestData>> => {
    const mutationOptions: UseMutationOptions<PostNotificationsProvidersByIdTestResponse, PostNotificationsProvidersByIdTestError, Options<PostNotificationsProvidersByIdTestData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postNotificationsProvidersByIdTest({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOrganizationsQueryKey = (options?: Options<GetOrganizationsData>) => createQueryKey('getOrganizations', options);

/**
 * List all Fabric organizations
 * Get a list of all Fabric organizations
 */
export const getOrganizationsOptions = (options?: Options<GetOrganizationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOrganizations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOrganizationsQueryKey(options)
    });
};

export const getOrganizationsInfiniteQueryKey = (options?: Options<GetOrganizationsData>): QueryKey<Options<GetOrganizationsData>> => createQueryKey('getOrganizations', options, true);

/**
 * List all Fabric organizations
 * Get a list of all Fabric organizations
 */
export const getOrganizationsInfiniteOptions = (options?: Options<GetOrganizationsData>) => {
    return infiniteQueryOptions<GetOrganizationsResponse, GetOrganizationsError, InfiniteData<GetOrganizationsResponse>, QueryKey<Options<GetOrganizationsData>>, number | Pick<QueryKey<Options<GetOrganizationsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetOrganizationsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    offset: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getOrganizations({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOrganizationsInfiniteQueryKey(options)
    });
};

export const postOrganizationsQueryKey = (options: Options<PostOrganizationsData>) => createQueryKey('postOrganizations', options);

/**
 * Create a new Fabric organization
 * Create a new Fabric organization with the specified configuration
 */
export const postOrganizationsOptions = (options: Options<PostOrganizationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postOrganizations({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postOrganizationsQueryKey(options)
    });
};

/**
 * Create a new Fabric organization
 * Create a new Fabric organization with the specified configuration
 */
export const postOrganizationsMutation = (options?: Partial<Options<PostOrganizationsData>>): UseMutationOptions<PostOrganizationsResponse, PostOrganizationsError, Options<PostOrganizationsData>> => {
    const mutationOptions: UseMutationOptions<PostOrganizationsResponse, PostOrganizationsError, Options<PostOrganizationsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postOrganizations({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOrganizationsByMspidByMspidQueryKey = (options: Options<GetOrganizationsByMspidByMspidData>) => createQueryKey('getOrganizationsByMspidByMspid', options);

/**
 * Get a Fabric organization by MSP ID
 * Get a Fabric organization by MSP ID
 */
export const getOrganizationsByMspidByMspidOptions = (options: Options<GetOrganizationsByMspidByMspidData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOrganizationsByMspidByMspid({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOrganizationsByMspidByMspidQueryKey(options)
    });
};

/**
 * Delete a Fabric organization
 * Delete a Fabric organization by ID
 */
export const deleteOrganizationsByIdMutation = (options?: Partial<Options<DeleteOrganizationsByIdData>>): UseMutationOptions<unknown, DeleteOrganizationsByIdError, Options<DeleteOrganizationsByIdData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteOrganizationsByIdError, Options<DeleteOrganizationsByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteOrganizationsById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOrganizationsByIdQueryKey = (options: Options<GetOrganizationsByIdData>) => createQueryKey('getOrganizationsById', options);

/**
 * Get a Fabric organization
 * Get a Fabric organization by ID
 */
export const getOrganizationsByIdOptions = (options: Options<GetOrganizationsByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOrganizationsById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOrganizationsByIdQueryKey(options)
    });
};

/**
 * Update a Fabric organization
 * Update an existing Fabric organization
 */
export const putOrganizationsByIdMutation = (options?: Partial<Options<PutOrganizationsByIdData>>): UseMutationOptions<PutOrganizationsByIdResponse, PutOrganizationsByIdError, Options<PutOrganizationsByIdData>> => {
    const mutationOptions: UseMutationOptions<PutOrganizationsByIdResponse, PutOrganizationsByIdError, Options<PutOrganizationsByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putOrganizationsById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOrganizationsByIdCrlQueryKey = (options: Options<GetOrganizationsByIdCrlData>) => createQueryKey('getOrganizationsByIdCrl', options);

/**
 * Get organization's CRL
 * Get the current Certificate Revocation List for the organization
 */
export const getOrganizationsByIdCrlOptions = (options: Options<GetOrganizationsByIdCrlData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOrganizationsByIdCrl({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOrganizationsByIdCrlQueryKey(options)
    });
};

export const postOrganizationsByIdCrlRevokePemQueryKey = (options: Options<PostOrganizationsByIdCrlRevokePemData>) => createQueryKey('postOrganizationsByIdCrlRevokePem', options);

/**
 * Revoke a certificate using PEM data
 * Add a certificate to the organization's CRL using its PEM encoded data
 */
export const postOrganizationsByIdCrlRevokePemOptions = (options: Options<PostOrganizationsByIdCrlRevokePemData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postOrganizationsByIdCrlRevokePem({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postOrganizationsByIdCrlRevokePemQueryKey(options)
    });
};

/**
 * Revoke a certificate using PEM data
 * Add a certificate to the organization's CRL using its PEM encoded data
 */
export const postOrganizationsByIdCrlRevokePemMutation = (options?: Partial<Options<PostOrganizationsByIdCrlRevokePemData>>): UseMutationOptions<PostOrganizationsByIdCrlRevokePemResponse, PostOrganizationsByIdCrlRevokePemError, Options<PostOrganizationsByIdCrlRevokePemData>> => {
    const mutationOptions: UseMutationOptions<PostOrganizationsByIdCrlRevokePemResponse, PostOrganizationsByIdCrlRevokePemError, Options<PostOrganizationsByIdCrlRevokePemData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postOrganizationsByIdCrlRevokePem({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a revoked certificate using its serial number
 * Remove a certificate from the organization's CRL using its serial number
 */
export const deleteOrganizationsByIdCrlRevokeSerialMutation = (options?: Partial<Options<DeleteOrganizationsByIdCrlRevokeSerialData>>): UseMutationOptions<DeleteOrganizationsByIdCrlRevokeSerialResponse, DeleteOrganizationsByIdCrlRevokeSerialError, Options<DeleteOrganizationsByIdCrlRevokeSerialData>> => {
    const mutationOptions: UseMutationOptions<DeleteOrganizationsByIdCrlRevokeSerialResponse, DeleteOrganizationsByIdCrlRevokeSerialError, Options<DeleteOrganizationsByIdCrlRevokeSerialData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteOrganizationsByIdCrlRevokeSerial({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postOrganizationsByIdCrlRevokeSerialQueryKey = (options: Options<PostOrganizationsByIdCrlRevokeSerialData>) => createQueryKey('postOrganizationsByIdCrlRevokeSerial', options);

/**
 * Revoke a certificate using its serial number
 * Add a certificate to the organization's CRL using its serial number
 */
export const postOrganizationsByIdCrlRevokeSerialOptions = (options: Options<PostOrganizationsByIdCrlRevokeSerialData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postOrganizationsByIdCrlRevokeSerial({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postOrganizationsByIdCrlRevokeSerialQueryKey(options)
    });
};

/**
 * Revoke a certificate using its serial number
 * Add a certificate to the organization's CRL using its serial number
 */
export const postOrganizationsByIdCrlRevokeSerialMutation = (options?: Partial<Options<PostOrganizationsByIdCrlRevokeSerialData>>): UseMutationOptions<PostOrganizationsByIdCrlRevokeSerialResponse, PostOrganizationsByIdCrlRevokeSerialError, Options<PostOrganizationsByIdCrlRevokeSerialData>> => {
    const mutationOptions: UseMutationOptions<PostOrganizationsByIdCrlRevokeSerialResponse, PostOrganizationsByIdCrlRevokeSerialError, Options<PostOrganizationsByIdCrlRevokeSerialData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postOrganizationsByIdCrlRevokeSerial({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOrganizationsByIdKeysQueryKey = (options: Options<GetOrganizationsByIdKeysData>) => createQueryKey('getOrganizationsByIdKeys', options);

/**
 * List all keys for an organization
 * Get all keys associated with an organization
 */
export const getOrganizationsByIdKeysOptions = (options: Options<GetOrganizationsByIdKeysData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOrganizationsByIdKeys({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOrganizationsByIdKeysQueryKey(options)
    });
};

export const postOrganizationsByIdKeysQueryKey = (options: Options<PostOrganizationsByIdKeysData>) => createQueryKey('postOrganizationsByIdKeys', options);

/**
 * Create a new key for an organization
 * Create a new key with a specific role (admin or client) for an organization
 */
export const postOrganizationsByIdKeysOptions = (options: Options<PostOrganizationsByIdKeysData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postOrganizationsByIdKeys({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postOrganizationsByIdKeysQueryKey(options)
    });
};

/**
 * Create a new key for an organization
 * Create a new key with a specific role (admin or client) for an organization
 */
export const postOrganizationsByIdKeysMutation = (options?: Partial<Options<PostOrganizationsByIdKeysData>>): UseMutationOptions<PostOrganizationsByIdKeysResponse, PostOrganizationsByIdKeysError, Options<PostOrganizationsByIdKeysData>> => {
    const mutationOptions: UseMutationOptions<PostOrganizationsByIdKeysResponse, PostOrganizationsByIdKeysError, Options<PostOrganizationsByIdKeysData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postOrganizationsByIdKeys({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postOrganizationsByIdKeysRenewQueryKey = (options: Options<PostOrganizationsByIdKeysRenewData>) => createQueryKey('postOrganizationsByIdKeysRenew', options);

/**
 * Renew a certificate for a key
 * Renew a certificate for a specific key in an organization
 */
export const postOrganizationsByIdKeysRenewOptions = (options: Options<PostOrganizationsByIdKeysRenewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postOrganizationsByIdKeysRenew({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postOrganizationsByIdKeysRenewQueryKey(options)
    });
};

/**
 * Renew a certificate for a key
 * Renew a certificate for a specific key in an organization
 */
export const postOrganizationsByIdKeysRenewMutation = (options?: Partial<Options<PostOrganizationsByIdKeysRenewData>>): UseMutationOptions<PostOrganizationsByIdKeysRenewResponse, PostOrganizationsByIdKeysRenewError, Options<PostOrganizationsByIdKeysRenewData>> => {
    const mutationOptions: UseMutationOptions<PostOrganizationsByIdKeysRenewResponse, PostOrganizationsByIdKeysRenewError, Options<PostOrganizationsByIdKeysRenewData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postOrganizationsByIdKeysRenew({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a key
 * Delete a key and its associated certificate
 */
export const deleteOrganizationsByIdKeysByKeyIdMutation = (options?: Partial<Options<DeleteOrganizationsByIdKeysByKeyIdData>>): UseMutationOptions<unknown, DeleteOrganizationsByIdKeysByKeyIdError, Options<DeleteOrganizationsByIdKeysByKeyIdData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteOrganizationsByIdKeysByKeyIdError, Options<DeleteOrganizationsByIdKeysByKeyIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteOrganizationsByIdKeysByKeyId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOrganizationsByIdKeysByKeyIdQueryKey = (options: Options<GetOrganizationsByIdKeysByKeyIdData>) => createQueryKey('getOrganizationsByIdKeysByKeyId', options);

/**
 * Get a specific key by ID
 * Get a specific key by its ID
 */
export const getOrganizationsByIdKeysByKeyIdOptions = (options: Options<GetOrganizationsByIdKeysByKeyIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOrganizationsByIdKeysByKeyId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOrganizationsByIdKeysByKeyIdQueryKey(options)
    });
};

export const getOrganizationsByIdRevokedCertificatesQueryKey = (options: Options<GetOrganizationsByIdRevokedCertificatesData>) => createQueryKey('getOrganizationsByIdRevokedCertificates', options);

/**
 * Get organization's revoked certificates
 * Get all revoked certificates for the organization
 */
export const getOrganizationsByIdRevokedCertificatesOptions = (options: Options<GetOrganizationsByIdRevokedCertificatesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOrganizationsByIdRevokedCertificates({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOrganizationsByIdRevokedCertificatesQueryKey(options)
    });
};

export const getPluginsQueryKey = (options?: Options<GetPluginsData>) => createQueryKey('getPlugins', options);

/**
 * List all plugins
 * Get a list of all available plugins
 */
export const getPluginsOptions = (options?: Options<GetPluginsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPlugins({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPluginsQueryKey(options)
    });
};

export const postPluginsQueryKey = (options: Options<PostPluginsData>) => createQueryKey('postPlugins', options);

/**
 * Create a plugin
 * Create a new plugin
 */
export const postPluginsOptions = (options: Options<PostPluginsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postPlugins({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postPluginsQueryKey(options)
    });
};

/**
 * Create a plugin
 * Create a new plugin
 */
export const postPluginsMutation = (options?: Partial<Options<PostPluginsData>>): UseMutationOptions<PostPluginsResponse, PostPluginsError, Options<PostPluginsData>> => {
    const mutationOptions: UseMutationOptions<PostPluginsResponse, PostPluginsError, Options<PostPluginsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postPlugins({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPluginsAvailableQueryKey = (options?: Options<GetPluginsAvailableData>) => createQueryKey('getPluginsAvailable', options);

/**
 * List available plugins from GitHub sources
 * Get a list of all available plugins from configured GitHub repositories
 */
export const getPluginsAvailableOptions = (options?: Options<GetPluginsAvailableData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPluginsAvailable({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPluginsAvailableQueryKey(options)
    });
};

export const postPluginsAvailableRefreshQueryKey = (options?: Options<PostPluginsAvailableRefreshData>) => createQueryKey('postPluginsAvailableRefresh', options);

/**
 * Refresh available plugins
 * Triggers a refresh of the available plugins cache from GitHub sources
 */
export const postPluginsAvailableRefreshOptions = (options?: Options<PostPluginsAvailableRefreshData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postPluginsAvailableRefresh({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postPluginsAvailableRefreshQueryKey(options)
    });
};

/**
 * Refresh available plugins
 * Triggers a refresh of the available plugins cache from GitHub sources
 */
export const postPluginsAvailableRefreshMutation = (options?: Partial<Options<PostPluginsAvailableRefreshData>>): UseMutationOptions<PostPluginsAvailableRefreshResponse, PostPluginsAvailableRefreshError, Options<PostPluginsAvailableRefreshData>> => {
    const mutationOptions: UseMutationOptions<PostPluginsAvailableRefreshResponse, PostPluginsAvailableRefreshError, Options<PostPluginsAvailableRefreshData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postPluginsAvailableRefresh({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a plugin
 * Delete a plugin (will stop it first if running)
 */
export const deletePluginsByNameMutation = (options?: Partial<Options<DeletePluginsByNameData>>): UseMutationOptions<unknown, DeletePluginsByNameError, Options<DeletePluginsByNameData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeletePluginsByNameError, Options<DeletePluginsByNameData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deletePluginsByName({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPluginsByNameQueryKey = (options: Options<GetPluginsByNameData>) => createQueryKey('getPluginsByName', options);

/**
 * Get a plugin
 * Get a specific plugin by name
 */
export const getPluginsByNameOptions = (options: Options<GetPluginsByNameData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPluginsByName({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPluginsByNameQueryKey(options)
    });
};

/**
 * Update a plugin
 * Update an existing plugin
 */
export const putPluginsByNameMutation = (options?: Partial<Options<PutPluginsByNameData>>): UseMutationOptions<PutPluginsByNameResponse, PutPluginsByNameError, Options<PutPluginsByNameData>> => {
    const mutationOptions: UseMutationOptions<PutPluginsByNameResponse, PutPluginsByNameError, Options<PutPluginsByNameData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putPluginsByName({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postPluginsByNameDeployQueryKey = (options: Options<PostPluginsByNameDeployData>) => createQueryKey('postPluginsByNameDeploy', options);

/**
 * Deploy a plugin
 * Deploy a plugin with the given parameters
 */
export const postPluginsByNameDeployOptions = (options: Options<PostPluginsByNameDeployData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postPluginsByNameDeploy({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postPluginsByNameDeployQueryKey(options)
    });
};

/**
 * Deploy a plugin
 * Deploy a plugin with the given parameters
 */
export const postPluginsByNameDeployMutation = (options?: Partial<Options<PostPluginsByNameDeployData>>): UseMutationOptions<unknown, PostPluginsByNameDeployError, Options<PostPluginsByNameDeployData>> => {
    const mutationOptions: UseMutationOptions<unknown, PostPluginsByNameDeployError, Options<PostPluginsByNameDeployData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postPluginsByNameDeploy({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPluginsByNameDeploymentStatusQueryKey = (options: Options<GetPluginsByNameDeploymentStatusData>) => createQueryKey('getPluginsByNameDeploymentStatus', options);

/**
 * Get detailed deployment status
 * Get detailed information about a plugin deployment including service status, logs, and metrics
 */
export const getPluginsByNameDeploymentStatusOptions = (options: Options<GetPluginsByNameDeploymentStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPluginsByNameDeploymentStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPluginsByNameDeploymentStatusQueryKey(options)
    });
};

export const postPluginsByNameResumeQueryKey = (options: Options<PostPluginsByNameResumeData>) => createQueryKey('postPluginsByNameResume', options);

/**
 * Resume a plugin deployment
 * Resume a previously deployed plugin
 */
export const postPluginsByNameResumeOptions = (options: Options<PostPluginsByNameResumeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postPluginsByNameResume({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postPluginsByNameResumeQueryKey(options)
    });
};

/**
 * Resume a plugin deployment
 * Resume a previously deployed plugin
 */
export const postPluginsByNameResumeMutation = (options?: Partial<Options<PostPluginsByNameResumeData>>): UseMutationOptions<PostPluginsByNameResumeResponse, PostPluginsByNameResumeError, Options<PostPluginsByNameResumeData>> => {
    const mutationOptions: UseMutationOptions<PostPluginsByNameResumeResponse, PostPluginsByNameResumeError, Options<PostPluginsByNameResumeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postPluginsByNameResume({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPluginsByNameServicesQueryKey = (options: Options<GetPluginsByNameServicesData>) => createQueryKey('getPluginsByNameServices', options);

/**
 * Get Docker Compose services
 * Get all services defined in the plugin's docker-compose configuration
 */
export const getPluginsByNameServicesOptions = (options: Options<GetPluginsByNameServicesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPluginsByNameServices({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPluginsByNameServicesQueryKey(options)
    });
};

export const getPluginsByNameStatusQueryKey = (options: Options<GetPluginsByNameStatusData>) => createQueryKey('getPluginsByNameStatus', options);

/**
 * Get plugin deployment status
 * Get the current status of a plugin deployment
 */
export const getPluginsByNameStatusOptions = (options: Options<GetPluginsByNameStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPluginsByNameStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPluginsByNameStatusQueryKey(options)
    });
};

export const postPluginsByNameStopQueryKey = (options: Options<PostPluginsByNameStopData>) => createQueryKey('postPluginsByNameStop', options);

/**
 * Stop a plugin deployment
 * Stop a running plugin deployment
 */
export const postPluginsByNameStopOptions = (options: Options<PostPluginsByNameStopData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postPluginsByNameStop({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postPluginsByNameStopQueryKey(options)
    });
};

/**
 * Stop a plugin deployment
 * Stop a running plugin deployment
 */
export const postPluginsByNameStopMutation = (options?: Partial<Options<PostPluginsByNameStopData>>): UseMutationOptions<unknown, PostPluginsByNameStopError, Options<PostPluginsByNameStopData>> => {
    const mutationOptions: UseMutationOptions<unknown, PostPluginsByNameStopError, Options<PostPluginsByNameStopData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postPluginsByNameStop({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postProjectsByProjectIdDirsCreateQueryKey = (options: Options<PostProjectsByProjectIdDirsCreateData>) => createQueryKey('postProjectsByProjectIdDirsCreate', options);

/**
 * Create a directory
 * Create a new directory in a project
 */
export const postProjectsByProjectIdDirsCreateOptions = (options: Options<PostProjectsByProjectIdDirsCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postProjectsByProjectIdDirsCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postProjectsByProjectIdDirsCreateQueryKey(options)
    });
};

/**
 * Create a directory
 * Create a new directory in a project
 */
export const postProjectsByProjectIdDirsCreateMutation = (options?: Partial<Options<PostProjectsByProjectIdDirsCreateData>>): UseMutationOptions<PostProjectsByProjectIdDirsCreateResponse, PostProjectsByProjectIdDirsCreateError, Options<PostProjectsByProjectIdDirsCreateData>> => {
    const mutationOptions: UseMutationOptions<PostProjectsByProjectIdDirsCreateResponse, PostProjectsByProjectIdDirsCreateError, Options<PostProjectsByProjectIdDirsCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postProjectsByProjectIdDirsCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a directory
 * Delete a directory in a project
 */
export const deleteProjectsByProjectIdDirsDeleteMutation = (options?: Partial<Options<DeleteProjectsByProjectIdDirsDeleteData>>): UseMutationOptions<DeleteProjectsByProjectIdDirsDeleteResponse, DeleteProjectsByProjectIdDirsDeleteError, Options<DeleteProjectsByProjectIdDirsDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteProjectsByProjectIdDirsDeleteResponse, DeleteProjectsByProjectIdDirsDeleteError, Options<DeleteProjectsByProjectIdDirsDeleteData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteProjectsByProjectIdDirsDelete({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getProjectsByProjectIdDirsListQueryKey = (options: Options<GetProjectsByProjectIdDirsListData>) => createQueryKey('getProjectsByProjectIdDirsList', options);

/**
 * List files and directories
 * List files and directories in a given project and directory. Large directories (e.g., node_modules) are summarized/skipped.
 */
export const getProjectsByProjectIdDirsListOptions = (options: Options<GetProjectsByProjectIdDirsListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProjectsByProjectIdDirsList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProjectsByProjectIdDirsListQueryKey(options)
    });
};

/**
 * Delete a file
 * Delete a file in a project
 */
export const deleteProjectsByProjectIdFilesDeleteMutation = (options?: Partial<Options<DeleteProjectsByProjectIdFilesDeleteData>>): UseMutationOptions<DeleteProjectsByProjectIdFilesDeleteResponse, DeleteProjectsByProjectIdFilesDeleteError, Options<DeleteProjectsByProjectIdFilesDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteProjectsByProjectIdFilesDeleteResponse, DeleteProjectsByProjectIdFilesDeleteError, Options<DeleteProjectsByProjectIdFilesDeleteData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteProjectsByProjectIdFilesDelete({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getProjectsByProjectIdFilesEntriesQueryKey = (options: Options<GetProjectsByProjectIdFilesEntriesData>) => createQueryKey('getProjectsByProjectIdFilesEntries', options);

/**
 * List full project directory tree
 * List the full directory tree for a project, excluding large/ignored folders (e.g., node_modules, .git)
 */
export const getProjectsByProjectIdFilesEntriesOptions = (options: Options<GetProjectsByProjectIdFilesEntriesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProjectsByProjectIdFilesEntries({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProjectsByProjectIdFilesEntriesQueryKey(options)
    });
};

export const getProjectsByProjectIdFilesListQueryKey = (options: Options<GetProjectsByProjectIdFilesListData>) => createQueryKey('getProjectsByProjectIdFilesList', options);

/**
 * List files
 * List files in a given project and directory
 */
export const getProjectsByProjectIdFilesListOptions = (options: Options<GetProjectsByProjectIdFilesListData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProjectsByProjectIdFilesList({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProjectsByProjectIdFilesListQueryKey(options)
    });
};

export const getProjectsByProjectIdFilesReadQueryKey = (options: Options<GetProjectsByProjectIdFilesReadData>) => createQueryKey('getProjectsByProjectIdFilesRead', options);

/**
 * Read file contents
 * Get the contents of a file in a project
 */
export const getProjectsByProjectIdFilesReadOptions = (options: Options<GetProjectsByProjectIdFilesReadData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getProjectsByProjectIdFilesRead({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getProjectsByProjectIdFilesReadQueryKey(options)
    });
};

export const postProjectsByProjectIdFilesWriteQueryKey = (options: Options<PostProjectsByProjectIdFilesWriteData>) => createQueryKey('postProjectsByProjectIdFilesWrite', options);

/**
 * Write file contents
 * Write or modify the contents of a file in a project
 */
export const postProjectsByProjectIdFilesWriteOptions = (options: Options<PostProjectsByProjectIdFilesWriteData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postProjectsByProjectIdFilesWrite({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postProjectsByProjectIdFilesWriteQueryKey(options)
    });
};

/**
 * Write file contents
 * Write or modify the contents of a file in a project
 */
export const postProjectsByProjectIdFilesWriteMutation = (options?: Partial<Options<PostProjectsByProjectIdFilesWriteData>>): UseMutationOptions<PostProjectsByProjectIdFilesWriteResponse, PostProjectsByProjectIdFilesWriteError, Options<PostProjectsByProjectIdFilesWriteData>> => {
    const mutationOptions: UseMutationOptions<PostProjectsByProjectIdFilesWriteResponse, PostProjectsByProjectIdFilesWriteError, Options<PostProjectsByProjectIdFilesWriteData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postProjectsByProjectIdFilesWrite({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postScBesuDeployQueryKey = (options: Options<PostScBesuDeployData>) => createQueryKey('postScBesuDeploy', options);

/**
 * Deploy Besu smart contract
 * Deploy a smart contract to a Besu (EVM) network
 */
export const postScBesuDeployOptions = (options: Options<PostScBesuDeployData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postScBesuDeploy({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postScBesuDeployQueryKey(options)
    });
};

/**
 * Deploy Besu smart contract
 * Deploy a smart contract to a Besu (EVM) network
 */
export const postScBesuDeployMutation = (options?: Partial<Options<PostScBesuDeployData>>): UseMutationOptions<PostScBesuDeployResponse, PostScBesuDeployError, Options<PostScBesuDeployData>> => {
    const mutationOptions: UseMutationOptions<PostScBesuDeployResponse, PostScBesuDeployError, Options<PostScBesuDeployData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postScBesuDeploy({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getScFabricChaincodesQueryKey = (options?: Options<GetScFabricChaincodesData>) => createQueryKey('getScFabricChaincodes', options);

/**
 * List deployed Fabric chaincodes
 * List all Fabric chaincodes deployed via Docker
 */
export const getScFabricChaincodesOptions = (options?: Options<GetScFabricChaincodesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getScFabricChaincodes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getScFabricChaincodesQueryKey(options)
    });
};

export const postScFabricChaincodesQueryKey = (options: Options<PostScFabricChaincodesData>) => createQueryKey('postScFabricChaincodes', options);

/**
 * Create a chaincode
 * Create a new chaincode
 */
export const postScFabricChaincodesOptions = (options: Options<PostScFabricChaincodesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postScFabricChaincodes({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postScFabricChaincodesQueryKey(options)
    });
};

/**
 * Create a chaincode
 * Create a new chaincode
 */
export const postScFabricChaincodesMutation = (options?: Partial<Options<PostScFabricChaincodesData>>): UseMutationOptions<PostScFabricChaincodesResponse, PostScFabricChaincodesError, Options<PostScFabricChaincodesData>> => {
    const mutationOptions: UseMutationOptions<PostScFabricChaincodesResponse, PostScFabricChaincodesError, Options<PostScFabricChaincodesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postScFabricChaincodes({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getScFabricChaincodesByChaincodeIdDefinitionsQueryKey = (options: Options<GetScFabricChaincodesByChaincodeIdDefinitionsData>) => createQueryKey('getScFabricChaincodesByChaincodeIdDefinitions', options);

/**
 * List chaincode definitions for a chaincode
 * List all definitions for a given chaincode
 */
export const getScFabricChaincodesByChaincodeIdDefinitionsOptions = (options: Options<GetScFabricChaincodesByChaincodeIdDefinitionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getScFabricChaincodesByChaincodeIdDefinitions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getScFabricChaincodesByChaincodeIdDefinitionsQueryKey(options)
    });
};

export const postScFabricChaincodesByChaincodeIdDefinitionsQueryKey = (options: Options<PostScFabricChaincodesByChaincodeIdDefinitionsData>) => createQueryKey('postScFabricChaincodesByChaincodeIdDefinitions', options);

/**
 * Create a chaincode definition
 * Create a new chaincode definition for a chaincode
 */
export const postScFabricChaincodesByChaincodeIdDefinitionsOptions = (options: Options<PostScFabricChaincodesByChaincodeIdDefinitionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postScFabricChaincodesByChaincodeIdDefinitions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postScFabricChaincodesByChaincodeIdDefinitionsQueryKey(options)
    });
};

/**
 * Create a chaincode definition
 * Create a new chaincode definition for a chaincode
 */
export const postScFabricChaincodesByChaincodeIdDefinitionsMutation = (options?: Partial<Options<PostScFabricChaincodesByChaincodeIdDefinitionsData>>): UseMutationOptions<PostScFabricChaincodesByChaincodeIdDefinitionsResponse, PostScFabricChaincodesByChaincodeIdDefinitionsError, Options<PostScFabricChaincodesByChaincodeIdDefinitionsData>> => {
    const mutationOptions: UseMutationOptions<PostScFabricChaincodesByChaincodeIdDefinitionsResponse, PostScFabricChaincodesByChaincodeIdDefinitionsError, Options<PostScFabricChaincodesByChaincodeIdDefinitionsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postScFabricChaincodesByChaincodeIdDefinitions({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getScFabricChaincodesByChaincodeIdDefinitionsByDefinitionIdQueryKey = (options: Options<GetScFabricChaincodesByChaincodeIdDefinitionsByDefinitionIdData>) => createQueryKey('getScFabricChaincodesByChaincodeIdDefinitionsByDefinitionId', options);

/**
 * Get chaincode definition details by ID
 * Get detailed information about a specific chaincode definition including its events
 */
export const getScFabricChaincodesByChaincodeIdDefinitionsByDefinitionIdOptions = (options: Options<GetScFabricChaincodesByChaincodeIdDefinitionsByDefinitionIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getScFabricChaincodesByChaincodeIdDefinitionsByDefinitionId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getScFabricChaincodesByChaincodeIdDefinitionsByDefinitionIdQueryKey(options)
    });
};

export const postScFabricChaincodesByChaincodeIdInvokeQueryKey = (options: Options<PostScFabricChaincodesByChaincodeIdInvokeData>) => createQueryKey('postScFabricChaincodesByChaincodeIdInvoke', options);

/**
 * Invoke a chaincode
 * Invoke a transaction on a specific chaincode
 */
export const postScFabricChaincodesByChaincodeIdInvokeOptions = (options: Options<PostScFabricChaincodesByChaincodeIdInvokeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postScFabricChaincodesByChaincodeIdInvoke({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postScFabricChaincodesByChaincodeIdInvokeQueryKey(options)
    });
};

/**
 * Invoke a chaincode
 * Invoke a transaction on a specific chaincode
 */
export const postScFabricChaincodesByChaincodeIdInvokeMutation = (options?: Partial<Options<PostScFabricChaincodesByChaincodeIdInvokeData>>): UseMutationOptions<PostScFabricChaincodesByChaincodeIdInvokeResponse, PostScFabricChaincodesByChaincodeIdInvokeError, Options<PostScFabricChaincodesByChaincodeIdInvokeData>> => {
    const mutationOptions: UseMutationOptions<PostScFabricChaincodesByChaincodeIdInvokeResponse, PostScFabricChaincodesByChaincodeIdInvokeError, Options<PostScFabricChaincodesByChaincodeIdInvokeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postScFabricChaincodesByChaincodeIdInvoke({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getScFabricChaincodesByChaincodeIdMetadataQueryKey = (options: Options<GetScFabricChaincodesByChaincodeIdMetadataData>) => createQueryKey('getScFabricChaincodesByChaincodeIdMetadata', options);

/**
 * Get chaincode metadata
 * Get metadata for a specific chaincode by executing org.hyperledger.fabric:GetMetadata
 */
export const getScFabricChaincodesByChaincodeIdMetadataOptions = (options: Options<GetScFabricChaincodesByChaincodeIdMetadataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getScFabricChaincodesByChaincodeIdMetadata({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getScFabricChaincodesByChaincodeIdMetadataQueryKey(options)
    });
};

export const postScFabricChaincodesByChaincodeIdQueryQueryKey = (options: Options<PostScFabricChaincodesByChaincodeIdQueryData>) => createQueryKey('postScFabricChaincodesByChaincodeIdQuery', options);

/**
 * Query a chaincode
 * Query a specific chaincode
 */
export const postScFabricChaincodesByChaincodeIdQueryOptions = (options: Options<PostScFabricChaincodesByChaincodeIdQueryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postScFabricChaincodesByChaincodeIdQuery({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postScFabricChaincodesByChaincodeIdQueryQueryKey(options)
    });
};

/**
 * Query a chaincode
 * Query a specific chaincode
 */
export const postScFabricChaincodesByChaincodeIdQueryMutation = (options?: Partial<Options<PostScFabricChaincodesByChaincodeIdQueryData>>): UseMutationOptions<PostScFabricChaincodesByChaincodeIdQueryResponse, PostScFabricChaincodesByChaincodeIdQueryError, Options<PostScFabricChaincodesByChaincodeIdQueryData>> => {
    const mutationOptions: UseMutationOptions<PostScFabricChaincodesByChaincodeIdQueryResponse, PostScFabricChaincodesByChaincodeIdQueryError, Options<PostScFabricChaincodesByChaincodeIdQueryData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postScFabricChaincodesByChaincodeIdQuery({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a chaincode
 * Delete a chaincode by ID
 */
export const deleteScFabricChaincodesByIdMutation = (options?: Partial<Options<DeleteScFabricChaincodesByIdData>>): UseMutationOptions<DeleteScFabricChaincodesByIdResponse, DeleteScFabricChaincodesByIdError, Options<DeleteScFabricChaincodesByIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteScFabricChaincodesByIdResponse, DeleteScFabricChaincodesByIdError, Options<DeleteScFabricChaincodesByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteScFabricChaincodesById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getScFabricChaincodesByIdQueryKey = (options: Options<GetScFabricChaincodesByIdData>) => createQueryKey('getScFabricChaincodesById', options);

/**
 * Get Fabric chaincode details by ID
 * Get a specific Fabric chaincode and its Docker/runtime info by ID
 */
export const getScFabricChaincodesByIdOptions = (options: Options<GetScFabricChaincodesByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getScFabricChaincodesById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getScFabricChaincodesByIdQueryKey(options)
    });
};

/**
 * Delete a chaincode definition
 * Delete a chaincode definition by ID
 */
export const deleteScFabricDefinitionsByDefinitionIdMutation = (options?: Partial<Options<DeleteScFabricDefinitionsByDefinitionIdData>>): UseMutationOptions<DeleteScFabricDefinitionsByDefinitionIdResponse, DeleteScFabricDefinitionsByDefinitionIdError, Options<DeleteScFabricDefinitionsByDefinitionIdData>> => {
    const mutationOptions: UseMutationOptions<DeleteScFabricDefinitionsByDefinitionIdResponse, DeleteScFabricDefinitionsByDefinitionIdError, Options<DeleteScFabricDefinitionsByDefinitionIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteScFabricDefinitionsByDefinitionId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update a chaincode definition
 * Update an existing chaincode definition by ID
 */
export const putScFabricDefinitionsByDefinitionIdMutation = (options?: Partial<Options<PutScFabricDefinitionsByDefinitionIdData>>): UseMutationOptions<PutScFabricDefinitionsByDefinitionIdResponse, PutScFabricDefinitionsByDefinitionIdError, Options<PutScFabricDefinitionsByDefinitionIdData>> => {
    const mutationOptions: UseMutationOptions<PutScFabricDefinitionsByDefinitionIdResponse, PutScFabricDefinitionsByDefinitionIdError, Options<PutScFabricDefinitionsByDefinitionIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putScFabricDefinitionsByDefinitionId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postScFabricDefinitionsByDefinitionIdApproveQueryKey = (options: Options<PostScFabricDefinitionsByDefinitionIdApproveData>) => createQueryKey('postScFabricDefinitionsByDefinitionIdApprove', options);

/**
 * Approve chaincode based on chaincode definition
 * Approve chaincode for a given definition
 */
export const postScFabricDefinitionsByDefinitionIdApproveOptions = (options: Options<PostScFabricDefinitionsByDefinitionIdApproveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postScFabricDefinitionsByDefinitionIdApprove({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postScFabricDefinitionsByDefinitionIdApproveQueryKey(options)
    });
};

/**
 * Approve chaincode based on chaincode definition
 * Approve chaincode for a given definition
 */
export const postScFabricDefinitionsByDefinitionIdApproveMutation = (options?: Partial<Options<PostScFabricDefinitionsByDefinitionIdApproveData>>): UseMutationOptions<PostScFabricDefinitionsByDefinitionIdApproveResponse, PostScFabricDefinitionsByDefinitionIdApproveError, Options<PostScFabricDefinitionsByDefinitionIdApproveData>> => {
    const mutationOptions: UseMutationOptions<PostScFabricDefinitionsByDefinitionIdApproveResponse, PostScFabricDefinitionsByDefinitionIdApproveError, Options<PostScFabricDefinitionsByDefinitionIdApproveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postScFabricDefinitionsByDefinitionIdApprove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postScFabricDefinitionsByDefinitionIdCommitQueryKey = (options: Options<PostScFabricDefinitionsByDefinitionIdCommitData>) => createQueryKey('postScFabricDefinitionsByDefinitionIdCommit', options);

/**
 * Commit chaincode based on chaincode definition
 * Commit chaincode for a given definition
 */
export const postScFabricDefinitionsByDefinitionIdCommitOptions = (options: Options<PostScFabricDefinitionsByDefinitionIdCommitData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postScFabricDefinitionsByDefinitionIdCommit({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postScFabricDefinitionsByDefinitionIdCommitQueryKey(options)
    });
};

/**
 * Commit chaincode based on chaincode definition
 * Commit chaincode for a given definition
 */
export const postScFabricDefinitionsByDefinitionIdCommitMutation = (options?: Partial<Options<PostScFabricDefinitionsByDefinitionIdCommitData>>): UseMutationOptions<PostScFabricDefinitionsByDefinitionIdCommitResponse, PostScFabricDefinitionsByDefinitionIdCommitError, Options<PostScFabricDefinitionsByDefinitionIdCommitData>> => {
    const mutationOptions: UseMutationOptions<PostScFabricDefinitionsByDefinitionIdCommitResponse, PostScFabricDefinitionsByDefinitionIdCommitError, Options<PostScFabricDefinitionsByDefinitionIdCommitData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postScFabricDefinitionsByDefinitionIdCommit({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postScFabricDefinitionsByDefinitionIdDeployQueryKey = (options: Options<PostScFabricDefinitionsByDefinitionIdDeployData>) => createQueryKey('postScFabricDefinitionsByDefinitionIdDeploy', options);

/**
 * Deploy chaincode based on chaincode definition (Docker)
 * Deploy chaincode for a given definition using Docker image
 */
export const postScFabricDefinitionsByDefinitionIdDeployOptions = (options: Options<PostScFabricDefinitionsByDefinitionIdDeployData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postScFabricDefinitionsByDefinitionIdDeploy({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postScFabricDefinitionsByDefinitionIdDeployQueryKey(options)
    });
};

/**
 * Deploy chaincode based on chaincode definition (Docker)
 * Deploy chaincode for a given definition using Docker image
 */
export const postScFabricDefinitionsByDefinitionIdDeployMutation = (options?: Partial<Options<PostScFabricDefinitionsByDefinitionIdDeployData>>): UseMutationOptions<PostScFabricDefinitionsByDefinitionIdDeployResponse, PostScFabricDefinitionsByDefinitionIdDeployError, Options<PostScFabricDefinitionsByDefinitionIdDeployData>> => {
    const mutationOptions: UseMutationOptions<PostScFabricDefinitionsByDefinitionIdDeployResponse, PostScFabricDefinitionsByDefinitionIdDeployError, Options<PostScFabricDefinitionsByDefinitionIdDeployData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postScFabricDefinitionsByDefinitionIdDeploy({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getScFabricDefinitionsByDefinitionIdDockerInfoQueryKey = (options: Options<GetScFabricDefinitionsByDefinitionIdDockerInfoData>) => createQueryKey('getScFabricDefinitionsByDefinitionIdDockerInfo', options);

/**
 * Get Docker info for a chaincode definition
 * Get Docker container info for a specific chaincode definition by ID
 */
export const getScFabricDefinitionsByDefinitionIdDockerInfoOptions = (options: Options<GetScFabricDefinitionsByDefinitionIdDockerInfoData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getScFabricDefinitionsByDefinitionIdDockerInfo({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getScFabricDefinitionsByDefinitionIdDockerInfoQueryKey(options)
    });
};

export const postScFabricDefinitionsByDefinitionIdInstallQueryKey = (options: Options<PostScFabricDefinitionsByDefinitionIdInstallData>) => createQueryKey('postScFabricDefinitionsByDefinitionIdInstall', options);

/**
 * Install chaincode based on chaincode definition
 * Install chaincode on peers for a given definition
 */
export const postScFabricDefinitionsByDefinitionIdInstallOptions = (options: Options<PostScFabricDefinitionsByDefinitionIdInstallData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postScFabricDefinitionsByDefinitionIdInstall({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postScFabricDefinitionsByDefinitionIdInstallQueryKey(options)
    });
};

/**
 * Install chaincode based on chaincode definition
 * Install chaincode on peers for a given definition
 */
export const postScFabricDefinitionsByDefinitionIdInstallMutation = (options?: Partial<Options<PostScFabricDefinitionsByDefinitionIdInstallData>>): UseMutationOptions<PostScFabricDefinitionsByDefinitionIdInstallResponse, PostScFabricDefinitionsByDefinitionIdInstallError, Options<PostScFabricDefinitionsByDefinitionIdInstallData>> => {
    const mutationOptions: UseMutationOptions<PostScFabricDefinitionsByDefinitionIdInstallResponse, PostScFabricDefinitionsByDefinitionIdInstallError, Options<PostScFabricDefinitionsByDefinitionIdInstallData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postScFabricDefinitionsByDefinitionIdInstall({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getScFabricDefinitionsByDefinitionIdTimelineQueryKey = (options: Options<GetScFabricDefinitionsByDefinitionIdTimelineData>) => createQueryKey('getScFabricDefinitionsByDefinitionIdTimeline', options);

/**
 * Get timeline of events for a chaincode definition
 * Get the timeline of install/approve/commit/deploy events for a chaincode definition
 */
export const getScFabricDefinitionsByDefinitionIdTimelineOptions = (options: Options<GetScFabricDefinitionsByDefinitionIdTimelineData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getScFabricDefinitionsByDefinitionIdTimeline({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getScFabricDefinitionsByDefinitionIdTimelineQueryKey(options)
    });
};

export const postScFabricDefinitionsByDefinitionIdUndeployQueryKey = (options: Options<PostScFabricDefinitionsByDefinitionIdUndeployData>) => createQueryKey('postScFabricDefinitionsByDefinitionIdUndeploy', options);

/**
 * Remove deployment for a chaincode definition
 * Remove the deployment (e.g., Docker container) for a given chaincode definition
 */
export const postScFabricDefinitionsByDefinitionIdUndeployOptions = (options: Options<PostScFabricDefinitionsByDefinitionIdUndeployData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postScFabricDefinitionsByDefinitionIdUndeploy({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postScFabricDefinitionsByDefinitionIdUndeployQueryKey(options)
    });
};

/**
 * Remove deployment for a chaincode definition
 * Remove the deployment (e.g., Docker container) for a given chaincode definition
 */
export const postScFabricDefinitionsByDefinitionIdUndeployMutation = (options?: Partial<Options<PostScFabricDefinitionsByDefinitionIdUndeployData>>): UseMutationOptions<PostScFabricDefinitionsByDefinitionIdUndeployResponse, PostScFabricDefinitionsByDefinitionIdUndeployError, Options<PostScFabricDefinitionsByDefinitionIdUndeployData>> => {
    const mutationOptions: UseMutationOptions<PostScFabricDefinitionsByDefinitionIdUndeployResponse, PostScFabricDefinitionsByDefinitionIdUndeployError, Options<PostScFabricDefinitionsByDefinitionIdUndeployData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postScFabricDefinitionsByDefinitionIdUndeploy({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postScFabricDeployQueryKey = (options: Options<PostScFabricDeployData>) => createQueryKey('postScFabricDeploy', options);

/**
 * Deploy Fabric chaincode
 * Deploy a chaincode to a Fabric network (install, approve, commit)
 */
export const postScFabricDeployOptions = (options: Options<PostScFabricDeployData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postScFabricDeploy({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postScFabricDeployQueryKey(options)
    });
};

/**
 * Deploy Fabric chaincode
 * Deploy a chaincode to a Fabric network (install, approve, commit)
 */
export const postScFabricDeployMutation = (options?: Partial<Options<PostScFabricDeployData>>): UseMutationOptions<PostScFabricDeployResponse, PostScFabricDeployError, Options<PostScFabricDeployData>> => {
    const mutationOptions: UseMutationOptions<PostScFabricDeployResponse, PostScFabricDeployError, Options<PostScFabricDeployData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postScFabricDeploy({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postScFabricPeerByPeerIdChaincodeApproveQueryKey = (options: Options<PostScFabricPeerByPeerIdChaincodeApproveData>) => createQueryKey('postScFabricPeerByPeerIdChaincodeApprove', options);

/**
 * Approve Fabric chaincode
 * Approve a chaincode definition for an organization
 */
export const postScFabricPeerByPeerIdChaincodeApproveOptions = (options: Options<PostScFabricPeerByPeerIdChaincodeApproveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postScFabricPeerByPeerIdChaincodeApprove({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postScFabricPeerByPeerIdChaincodeApproveQueryKey(options)
    });
};

/**
 * Approve Fabric chaincode
 * Approve a chaincode definition for an organization
 */
export const postScFabricPeerByPeerIdChaincodeApproveMutation = (options?: Partial<Options<PostScFabricPeerByPeerIdChaincodeApproveData>>): UseMutationOptions<PostScFabricPeerByPeerIdChaincodeApproveResponse, PostScFabricPeerByPeerIdChaincodeApproveError, Options<PostScFabricPeerByPeerIdChaincodeApproveData>> => {
    const mutationOptions: UseMutationOptions<PostScFabricPeerByPeerIdChaincodeApproveResponse, PostScFabricPeerByPeerIdChaincodeApproveError, Options<PostScFabricPeerByPeerIdChaincodeApproveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postScFabricPeerByPeerIdChaincodeApprove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postScFabricPeerByPeerIdChaincodeCommitQueryKey = (options: Options<PostScFabricPeerByPeerIdChaincodeCommitData>) => createQueryKey('postScFabricPeerByPeerIdChaincodeCommit', options);

/**
 * Commit Fabric chaincode
 * Commit a chaincode definition to the channel
 */
export const postScFabricPeerByPeerIdChaincodeCommitOptions = (options: Options<PostScFabricPeerByPeerIdChaincodeCommitData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postScFabricPeerByPeerIdChaincodeCommit({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postScFabricPeerByPeerIdChaincodeCommitQueryKey(options)
    });
};

/**
 * Commit Fabric chaincode
 * Commit a chaincode definition to the channel
 */
export const postScFabricPeerByPeerIdChaincodeCommitMutation = (options?: Partial<Options<PostScFabricPeerByPeerIdChaincodeCommitData>>): UseMutationOptions<PostScFabricPeerByPeerIdChaincodeCommitResponse, PostScFabricPeerByPeerIdChaincodeCommitError, Options<PostScFabricPeerByPeerIdChaincodeCommitData>> => {
    const mutationOptions: UseMutationOptions<PostScFabricPeerByPeerIdChaincodeCommitResponse, PostScFabricPeerByPeerIdChaincodeCommitError, Options<PostScFabricPeerByPeerIdChaincodeCommitData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postScFabricPeerByPeerIdChaincodeCommit({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postScFabricPeerByPeerIdChaincodeInstallQueryKey = (options: Options<PostScFabricPeerByPeerIdChaincodeInstallData>) => createQueryKey('postScFabricPeerByPeerIdChaincodeInstall', options);

/**
 * Install Fabric chaincode
 * Install a chaincode package on a Fabric peer
 */
export const postScFabricPeerByPeerIdChaincodeInstallOptions = (options: Options<PostScFabricPeerByPeerIdChaincodeInstallData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postScFabricPeerByPeerIdChaincodeInstall({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postScFabricPeerByPeerIdChaincodeInstallQueryKey(options)
    });
};

/**
 * Install Fabric chaincode
 * Install a chaincode package on a Fabric peer
 */
export const postScFabricPeerByPeerIdChaincodeInstallMutation = (options?: Partial<Options<PostScFabricPeerByPeerIdChaincodeInstallData>>): UseMutationOptions<PostScFabricPeerByPeerIdChaincodeInstallResponse, PostScFabricPeerByPeerIdChaincodeInstallError, Options<PostScFabricPeerByPeerIdChaincodeInstallData>> => {
    const mutationOptions: UseMutationOptions<PostScFabricPeerByPeerIdChaincodeInstallResponse, PostScFabricPeerByPeerIdChaincodeInstallError, Options<PostScFabricPeerByPeerIdChaincodeInstallData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postScFabricPeerByPeerIdChaincodeInstall({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getScFabricPeerByPeerIdChaincodeSequenceQueryKey = (options: Options<GetScFabricPeerByPeerIdChaincodeSequenceData>) => createQueryKey('getScFabricPeerByPeerIdChaincodeSequence', options);

/**
 * Get Fabric chaincode sequence
 * Get the current sequence number for a chaincode
 */
export const getScFabricPeerByPeerIdChaincodeSequenceOptions = (options: Options<GetScFabricPeerByPeerIdChaincodeSequenceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getScFabricPeerByPeerIdChaincodeSequence({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getScFabricPeerByPeerIdChaincodeSequenceQueryKey(options)
    });
};

export const getSettingsQueryKey = (options?: Options<GetSettingsData>) => createQueryKey('getSettings', options);

/**
 * Get the default setting
 * Get the default setting's details
 */
export const getSettingsOptions = (options?: Options<GetSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSettingsQueryKey(options)
    });
};

export const postSettingsQueryKey = (options: Options<PostSettingsData>) => createQueryKey('postSettings', options);

/**
 * Create or update the default setting
 * Create or update the default setting with the provided configuration
 */
export const postSettingsOptions = (options: Options<PostSettingsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postSettings({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postSettingsQueryKey(options)
    });
};

/**
 * Create or update the default setting
 * Create or update the default setting with the provided configuration
 */
export const postSettingsMutation = (options?: Partial<Options<PostSettingsData>>): UseMutationOptions<PostSettingsResponse, DefaultError, Options<PostSettingsData>> => {
    const mutationOptions: UseMutationOptions<PostSettingsResponse, DefaultError, Options<PostSettingsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postSettings({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUsersQueryKey = (options?: Options<GetUsersData>) => createQueryKey('getUsers', options);

/**
 * List users
 * Returns a list of all users (admin only)
 */
export const getUsersOptions = (options?: Options<GetUsersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUsers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUsersQueryKey(options)
    });
};

export const postUsersQueryKey = (options: Options<PostUsersData>) => createQueryKey('postUsers', options);

/**
 * Create new user
 * Creates a new user with specified role (admin only)
 */
export const postUsersOptions = (options: Options<PostUsersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postUsers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postUsersQueryKey(options)
    });
};

/**
 * Create new user
 * Creates a new user with specified role (admin only)
 */
export const postUsersMutation = (options?: Partial<Options<PostUsersData>>): UseMutationOptions<PostUsersResponse, PostUsersError, Options<PostUsersData>> => {
    const mutationOptions: UseMutationOptions<PostUsersResponse, PostUsersError, Options<PostUsersData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postUsers({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete user
 * Deletes a user (admin only)
 */
export const deleteUsersByIdMutation = (options?: Partial<Options<DeleteUsersByIdData>>): UseMutationOptions<unknown, DeleteUsersByIdError, Options<DeleteUsersByIdData>> => {
    const mutationOptions: UseMutationOptions<unknown, DeleteUsersByIdError, Options<DeleteUsersByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteUsersById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUsersByIdQueryKey = (options: Options<GetUsersByIdData>) => createQueryKey('getUsersById', options);

/**
 * Get user by ID
 * Get a user's details by ID (admin only)
 */
export const getUsersByIdOptions = (options: Options<GetUsersByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUsersById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUsersByIdQueryKey(options)
    });
};

/**
 * Update user
 * Updates an existing user (admin only)
 */
export const putUsersByIdMutation = (options?: Partial<Options<PutUsersByIdData>>): UseMutationOptions<PutUsersByIdResponse, PutUsersByIdError, Options<PutUsersByIdData>> => {
    const mutationOptions: UseMutationOptions<PutUsersByIdResponse, PutUsersByIdError, Options<PutUsersByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putUsersById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update user password
 * Update a user's password (admin only)
 */
export const putUsersByIdPasswordMutation = (options?: Partial<Options<PutUsersByIdPasswordData>>): UseMutationOptions<PutUsersByIdPasswordResponse, PutUsersByIdPasswordError, Options<PutUsersByIdPasswordData>> => {
    const mutationOptions: UseMutationOptions<PutUsersByIdPasswordResponse, PutUsersByIdPasswordError, Options<PutUsersByIdPasswordData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putUsersByIdPassword({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update user role
 * Update a user's role (admin only)
 */
export const putUsersByIdRoleMutation = (options?: Partial<Options<PutUsersByIdRoleData>>): UseMutationOptions<PutUsersByIdRoleResponse, PutUsersByIdRoleError, Options<PutUsersByIdRoleData>> => {
    const mutationOptions: UseMutationOptions<PutUsersByIdRoleResponse, PutUsersByIdRoleError, Options<PutUsersByIdRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putUsersByIdRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};