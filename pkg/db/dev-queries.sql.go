// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: dev-queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const CreateConversation = `-- name: CreateConversation :one
INSERT INTO conversations (project_id) VALUES (?) RETURNING id, project_id, started_at
`

func (q *Queries) CreateConversation(ctx context.Context, projectID int64) (*Conversation, error) {
	row := q.db.QueryRowContext(ctx, CreateConversation, projectID)
	var i Conversation
	err := row.Scan(&i.ID, &i.ProjectID, &i.StartedAt)
	return &i, err
}

const CreateProject = `-- name: CreateProject :one
INSERT INTO chaincode_projects (name, description, boilerplate, slug, network_id, endorsement_policy) VALUES (?, ?, ?, ?, ?, ?) RETURNING id, name, description, boilerplate, created_at, updated_at, slug, container_id, container_name, status, last_started_at, last_stopped_at, container_port, network_id, endorsement_policy
`

type CreateProjectParams struct {
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Boilerplate       sql.NullString `json:"boilerplate"`
	Slug              string         `json:"slug"`
	NetworkID         sql.NullInt64  `json:"networkId"`
	EndorsementPolicy sql.NullString `json:"endorsementPolicy"`
}

func (q *Queries) CreateProject(ctx context.Context, arg *CreateProjectParams) (*ChaincodeProject, error) {
	row := q.db.QueryRowContext(ctx, CreateProject,
		arg.Name,
		arg.Description,
		arg.Boilerplate,
		arg.Slug,
		arg.NetworkID,
		arg.EndorsementPolicy,
	)
	var i ChaincodeProject
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Boilerplate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Slug,
		&i.ContainerID,
		&i.ContainerName,
		&i.Status,
		&i.LastStartedAt,
		&i.LastStoppedAt,
		&i.ContainerPort,
		&i.NetworkID,
		&i.EndorsementPolicy,
	)
	return &i, err
}

const DeleteProject = `-- name: DeleteProject :exec
DELETE FROM chaincode_projects WHERE id = ?
`

func (q *Queries) DeleteProject(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, DeleteProject, id)
	return err
}

const GetConversation = `-- name: GetConversation :one
SELECT id, project_id, started_at FROM conversations WHERE id = ? LIMIT 1
`

func (q *Queries) GetConversation(ctx context.Context, id int64) (*Conversation, error) {
	row := q.db.QueryRowContext(ctx, GetConversation, id)
	var i Conversation
	err := row.Scan(&i.ID, &i.ProjectID, &i.StartedAt)
	return &i, err
}

const GetDefaultConversationForProject = `-- name: GetDefaultConversationForProject :one
SELECT id, project_id, started_at FROM conversations WHERE project_id = ? ORDER BY started_at ASC LIMIT 1
`

func (q *Queries) GetDefaultConversationForProject(ctx context.Context, projectID int64) (*Conversation, error) {
	row := q.db.QueryRowContext(ctx, GetDefaultConversationForProject, projectID)
	var i Conversation
	err := row.Scan(&i.ID, &i.ProjectID, &i.StartedAt)
	return &i, err
}

const GetProject = `-- name: GetProject :one
SELECT cp.id, cp.name, cp.description, cp.boilerplate, cp.created_at, cp.updated_at, cp.slug, cp.container_id, cp.container_name, cp.status, cp.last_started_at, cp.last_stopped_at, cp.container_port, cp.network_id, cp.endorsement_policy, n.name as network_name, n.platform as network_platform 
FROM chaincode_projects cp 
LEFT JOIN networks n ON cp.network_id = n.id 
WHERE cp.id = ?
`

type GetProjectRow struct {
	ID                int64          `json:"id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Boilerplate       sql.NullString `json:"boilerplate"`
	CreatedAt         time.Time      `json:"createdAt"`
	UpdatedAt         time.Time      `json:"updatedAt"`
	Slug              string         `json:"slug"`
	ContainerID       sql.NullString `json:"containerId"`
	ContainerName     sql.NullString `json:"containerName"`
	Status            sql.NullString `json:"status"`
	LastStartedAt     sql.NullTime   `json:"lastStartedAt"`
	LastStoppedAt     sql.NullTime   `json:"lastStoppedAt"`
	ContainerPort     sql.NullInt64  `json:"containerPort"`
	NetworkID         sql.NullInt64  `json:"networkId"`
	EndorsementPolicy sql.NullString `json:"endorsementPolicy"`
	NetworkName       sql.NullString `json:"networkName"`
	NetworkPlatform   sql.NullString `json:"networkPlatform"`
}

func (q *Queries) GetProject(ctx context.Context, id int64) (*GetProjectRow, error) {
	row := q.db.QueryRowContext(ctx, GetProject, id)
	var i GetProjectRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Boilerplate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Slug,
		&i.ContainerID,
		&i.ContainerName,
		&i.Status,
		&i.LastStartedAt,
		&i.LastStoppedAt,
		&i.ContainerPort,
		&i.NetworkID,
		&i.EndorsementPolicy,
		&i.NetworkName,
		&i.NetworkPlatform,
	)
	return &i, err
}

const GetProjectBySlug = `-- name: GetProjectBySlug :one
SELECT cp.id, cp.name, cp.description, cp.boilerplate, cp.created_at, cp.updated_at, cp.slug, cp.container_id, cp.container_name, cp.status, cp.last_started_at, cp.last_stopped_at, cp.container_port, cp.network_id, cp.endorsement_policy, n.name as network_name, n.platform as network_platform 
FROM chaincode_projects cp 
LEFT JOIN networks n ON cp.network_id = n.id 
WHERE cp.slug = ?
`

type GetProjectBySlugRow struct {
	ID                int64          `json:"id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Boilerplate       sql.NullString `json:"boilerplate"`
	CreatedAt         time.Time      `json:"createdAt"`
	UpdatedAt         time.Time      `json:"updatedAt"`
	Slug              string         `json:"slug"`
	ContainerID       sql.NullString `json:"containerId"`
	ContainerName     sql.NullString `json:"containerName"`
	Status            sql.NullString `json:"status"`
	LastStartedAt     sql.NullTime   `json:"lastStartedAt"`
	LastStoppedAt     sql.NullTime   `json:"lastStoppedAt"`
	ContainerPort     sql.NullInt64  `json:"containerPort"`
	NetworkID         sql.NullInt64  `json:"networkId"`
	EndorsementPolicy sql.NullString `json:"endorsementPolicy"`
	NetworkName       sql.NullString `json:"networkName"`
	NetworkPlatform   sql.NullString `json:"networkPlatform"`
}

func (q *Queries) GetProjectBySlug(ctx context.Context, slug string) (*GetProjectBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, GetProjectBySlug, slug)
	var i GetProjectBySlugRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Boilerplate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Slug,
		&i.ContainerID,
		&i.ContainerName,
		&i.Status,
		&i.LastStartedAt,
		&i.LastStoppedAt,
		&i.ContainerPort,
		&i.NetworkID,
		&i.EndorsementPolicy,
		&i.NetworkName,
		&i.NetworkPlatform,
	)
	return &i, err
}

const InsertMessage = `-- name: InsertMessage :one
INSERT INTO messages (conversation_id, parent_id, sender, content, enhanced_content, tool_arguments, is_internal) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, conversation_id, parent_id, sender, content, enhanced_content, tool_arguments, is_internal, created_at
`

type InsertMessageParams struct {
	ConversationID  int64          `json:"conversationId"`
	ParentID        sql.NullInt64  `json:"parentId"`
	Sender          string         `json:"sender"`
	Content         string         `json:"content"`
	EnhancedContent sql.NullString `json:"enhancedContent"`
	ToolArguments   sql.NullString `json:"toolArguments"`
	IsInternal      bool           `json:"isInternal"`
}

func (q *Queries) InsertMessage(ctx context.Context, arg *InsertMessageParams) (*Message, error) {
	row := q.db.QueryRowContext(ctx, InsertMessage,
		arg.ConversationID,
		arg.ParentID,
		arg.Sender,
		arg.Content,
		arg.EnhancedContent,
		arg.ToolArguments,
		arg.IsInternal,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.ParentID,
		&i.Sender,
		&i.Content,
		&i.EnhancedContent,
		&i.ToolArguments,
		&i.IsInternal,
		&i.CreatedAt,
	)
	return &i, err
}

const InsertToolCall = `-- name: InsertToolCall :one
INSERT INTO tool_calls (message_id, tool_name, arguments, result, error)
VALUES (?, ?, ?, ?, ?) RETURNING id, message_id, tool_name, arguments, result, error, created_at
`

type InsertToolCallParams struct {
	MessageID int64          `json:"messageId"`
	ToolName  string         `json:"toolName"`
	Arguments string         `json:"arguments"`
	Result    sql.NullString `json:"result"`
	Error     sql.NullString `json:"error"`
}

func (q *Queries) InsertToolCall(ctx context.Context, arg *InsertToolCallParams) (*ToolCall, error) {
	row := q.db.QueryRowContext(ctx, InsertToolCall,
		arg.MessageID,
		arg.ToolName,
		arg.Arguments,
		arg.Result,
		arg.Error,
	)
	var i ToolCall
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.ToolName,
		&i.Arguments,
		&i.Result,
		&i.Error,
		&i.CreatedAt,
	)
	return &i, err
}

const ListConversationsForProject = `-- name: ListConversationsForProject :many
SELECT id, project_id, started_at FROM conversations WHERE project_id = ? ORDER BY started_at ASC
`

func (q *Queries) ListConversationsForProject(ctx context.Context, projectID int64) ([]*Conversation, error) {
	rows, err := q.db.QueryContext(ctx, ListConversationsForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Conversation{}
	for rows.Next() {
		var i Conversation
		if err := rows.Scan(&i.ID, &i.ProjectID, &i.StartedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListMessagesForConversation = `-- name: ListMessagesForConversation :many
SELECT id, conversation_id, parent_id, sender, content, enhanced_content, tool_arguments, is_internal, created_at FROM messages WHERE conversation_id = ? ORDER BY created_at ASC
`

func (q *Queries) ListMessagesForConversation(ctx context.Context, conversationID int64) ([]*Message, error) {
	rows, err := q.db.QueryContext(ctx, ListMessagesForConversation, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.ParentID,
			&i.Sender,
			&i.Content,
			&i.EnhancedContent,
			&i.ToolArguments,
			&i.IsInternal,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListProjects = `-- name: ListProjects :many
SELECT cp.id, cp.name, cp.description, cp.boilerplate, cp.created_at, cp.updated_at, cp.slug, cp.container_id, cp.container_name, cp.status, cp.last_started_at, cp.last_stopped_at, cp.container_port, cp.network_id, cp.endorsement_policy, n.name as network_name, n.platform as network_platform 
FROM chaincode_projects cp 
LEFT JOIN networks n ON cp.network_id = n.id 
ORDER BY cp.created_at DESC
`

type ListProjectsRow struct {
	ID                int64          `json:"id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Boilerplate       sql.NullString `json:"boilerplate"`
	CreatedAt         time.Time      `json:"createdAt"`
	UpdatedAt         time.Time      `json:"updatedAt"`
	Slug              string         `json:"slug"`
	ContainerID       sql.NullString `json:"containerId"`
	ContainerName     sql.NullString `json:"containerName"`
	Status            sql.NullString `json:"status"`
	LastStartedAt     sql.NullTime   `json:"lastStartedAt"`
	LastStoppedAt     sql.NullTime   `json:"lastStoppedAt"`
	ContainerPort     sql.NullInt64  `json:"containerPort"`
	NetworkID         sql.NullInt64  `json:"networkId"`
	EndorsementPolicy sql.NullString `json:"endorsementPolicy"`
	NetworkName       sql.NullString `json:"networkName"`
	NetworkPlatform   sql.NullString `json:"networkPlatform"`
}

func (q *Queries) ListProjects(ctx context.Context) ([]*ListProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, ListProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListProjectsRow{}
	for rows.Next() {
		var i ListProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Boilerplate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Slug,
			&i.ContainerID,
			&i.ContainerName,
			&i.Status,
			&i.LastStartedAt,
			&i.LastStoppedAt,
			&i.ContainerPort,
			&i.NetworkID,
			&i.EndorsementPolicy,
			&i.NetworkName,
			&i.NetworkPlatform,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListToolCallsForConversation = `-- name: ListToolCallsForConversation :many
SELECT tc.id, tc.message_id, tc.tool_name, tc.arguments, tc.result, tc.error, tc.created_at FROM tool_calls tc
JOIN messages m ON tc.message_id = m.id
WHERE m.conversation_id = ?
ORDER BY tc.created_at ASC
`

func (q *Queries) ListToolCallsForConversation(ctx context.Context, conversationID int64) ([]*ToolCall, error) {
	rows, err := q.db.QueryContext(ctx, ListToolCallsForConversation, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ToolCall{}
	for rows.Next() {
		var i ToolCall
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.ToolName,
			&i.Arguments,
			&i.Result,
			&i.Error,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListToolCallsForMessage = `-- name: ListToolCallsForMessage :many
SELECT id, message_id, tool_name, arguments, result, error, created_at FROM tool_calls WHERE message_id = ? ORDER BY created_at ASC
`

func (q *Queries) ListToolCallsForMessage(ctx context.Context, messageID int64) ([]*ToolCall, error) {
	rows, err := q.db.QueryContext(ctx, ListToolCallsForMessage, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ToolCall{}
	for rows.Next() {
		var i ToolCall
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.ToolName,
			&i.Arguments,
			&i.Result,
			&i.Error,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateMessageEnhancedContent = `-- name: UpdateMessageEnhancedContent :one
UPDATE messages SET enhanced_content = ? WHERE id = ? RETURNING id, conversation_id, parent_id, sender, content, enhanced_content, tool_arguments, is_internal, created_at
`

type UpdateMessageEnhancedContentParams struct {
	EnhancedContent sql.NullString `json:"enhancedContent"`
	ID              int64          `json:"id"`
}

func (q *Queries) UpdateMessageEnhancedContent(ctx context.Context, arg *UpdateMessageEnhancedContentParams) (*Message, error) {
	row := q.db.QueryRowContext(ctx, UpdateMessageEnhancedContent, arg.EnhancedContent, arg.ID)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.ParentID,
		&i.Sender,
		&i.Content,
		&i.EnhancedContent,
		&i.ToolArguments,
		&i.IsInternal,
		&i.CreatedAt,
	)
	return &i, err
}

const UpdateProjectContainerInfo = `-- name: UpdateProjectContainerInfo :exec
UPDATE chaincode_projects
SET
  container_id = ?,
  container_name = ?,
  status = ?,
  last_started_at = ?,
  last_stopped_at = ?,
  container_port = ?
WHERE id = ?
`

type UpdateProjectContainerInfoParams struct {
	ContainerID   sql.NullString `json:"containerId"`
	ContainerName sql.NullString `json:"containerName"`
	Status        sql.NullString `json:"status"`
	LastStartedAt sql.NullTime   `json:"lastStartedAt"`
	LastStoppedAt sql.NullTime   `json:"lastStoppedAt"`
	ContainerPort sql.NullInt64  `json:"containerPort"`
	ID            int64          `json:"id"`
}

func (q *Queries) UpdateProjectContainerInfo(ctx context.Context, arg *UpdateProjectContainerInfoParams) error {
	_, err := q.db.ExecContext(ctx, UpdateProjectContainerInfo,
		arg.ContainerID,
		arg.ContainerName,
		arg.Status,
		arg.LastStartedAt,
		arg.LastStoppedAt,
		arg.ContainerPort,
		arg.ID,
	)
	return err
}

const UpdateProjectEndorsementPolicy = `-- name: UpdateProjectEndorsementPolicy :one
UPDATE chaincode_projects
SET endorsement_policy = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, description, boilerplate, created_at, updated_at, slug, container_id, container_name, status, last_started_at, last_stopped_at, container_port, network_id, endorsement_policy
`

type UpdateProjectEndorsementPolicyParams struct {
	EndorsementPolicy sql.NullString `json:"endorsementPolicy"`
	ID                int64          `json:"id"`
}

func (q *Queries) UpdateProjectEndorsementPolicy(ctx context.Context, arg *UpdateProjectEndorsementPolicyParams) (*ChaincodeProject, error) {
	row := q.db.QueryRowContext(ctx, UpdateProjectEndorsementPolicy, arg.EndorsementPolicy, arg.ID)
	var i ChaincodeProject
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Boilerplate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Slug,
		&i.ContainerID,
		&i.ContainerName,
		&i.Status,
		&i.LastStartedAt,
		&i.LastStoppedAt,
		&i.ContainerPort,
		&i.NetworkID,
		&i.EndorsementPolicy,
	)
	return &i, err
}
