// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addRevokedCertificate = `-- name: AddRevokedCertificate :exec
INSERT INTO fabric_revoked_certificates (
    fabric_organization_id,
    serial_number,
    revocation_time,
    reason,
    issuer_certificate_id
) VALUES (?, ?, ?, ?, ?)
`

type AddRevokedCertificateParams struct {
	FabricOrganizationID int64         `json:"fabric_organization_id"`
	SerialNumber         string        `json:"serial_number"`
	RevocationTime       time.Time     `json:"revocation_time"`
	Reason               int64         `json:"reason"`
	IssuerCertificateID  sql.NullInt64 `json:"issuer_certificate_id"`
}

func (q *Queries) AddRevokedCertificate(ctx context.Context, arg AddRevokedCertificateParams) error {
	_, err := q.exec(ctx, q.addRevokedCertificateStmt, addRevokedCertificate,
		arg.FabricOrganizationID,
		arg.SerialNumber,
		arg.RevocationTime,
		arg.Reason,
		arg.IssuerCertificateID,
	)
	return err
}

const checkNetworkNodeExists = `-- name: CheckNetworkNodeExists :one
SELECT EXISTS(SELECT 1 FROM network_nodes WHERE network_id = ? AND node_id = ?)
`

type CheckNetworkNodeExistsParams struct {
	NetworkID int64 `json:"network_id"`
	NodeID    int64 `json:"node_id"`
}

func (q *Queries) CheckNetworkNodeExists(ctx context.Context, arg CheckNetworkNodeExistsParams) (int64, error) {
	row := q.queryRow(ctx, q.checkNetworkNodeExistsStmt, checkNetworkNodeExists, arg.NetworkID, arg.NodeID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const countBackupsBySchedule = `-- name: CountBackupsBySchedule :one
SELECT COUNT(*) FROM backups
WHERE schedule_id = ?
`

func (q *Queries) CountBackupsBySchedule(ctx context.Context, scheduleID sql.NullInt64) (int64, error) {
	row := q.queryRow(ctx, q.countBackupsByScheduleStmt, countBackupsBySchedule, scheduleID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBackupsByTarget = `-- name: CountBackupsByTarget :one
SELECT COUNT(*) FROM backups
WHERE target_id = ?
`

func (q *Queries) CountBackupsByTarget(ctx context.Context, targetID int64) (int64, error) {
	row := q.queryRow(ctx, q.countBackupsByTargetStmt, countBackupsByTarget, targetID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countNetworks = `-- name: CountNetworks :one
SELECT COUNT(*) FROM networks
`

func (q *Queries) CountNetworks(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countNetworksStmt, countNetworks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countNodeEvents = `-- name: CountNodeEvents :one
SELECT COUNT(*) FROM node_events
WHERE node_id = ?
`

func (q *Queries) CountNodeEvents(ctx context.Context, nodeID int64) (int64, error) {
	row := q.queryRow(ctx, q.countNodeEventsStmt, countNodeEvents, nodeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countNodes = `-- name: CountNodes :one
SELECT COUNT(*) FROM nodes
`

func (q *Queries) CountNodes(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countNodesStmt, countNodes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countNodesByPlatform = `-- name: CountNodesByPlatform :one
SELECT COUNT(*) FROM nodes
WHERE platform = ?
`

func (q *Queries) CountNodesByPlatform(ctx context.Context, platform string) (int64, error) {
	row := q.queryRow(ctx, q.countNodesByPlatformStmt, countNodesByPlatform, platform)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countUsersStmt, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBackup = `-- name: CreateBackup :one
INSERT INTO backups (
    schedule_id,
    target_id,
    status,
    started_at,
    created_at
) VALUES (
    ?,
    ?,
    ?,
    ?,
    CURRENT_TIMESTAMP
) RETURNING id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent
`

type CreateBackupParams struct {
	ScheduleID sql.NullInt64 `json:"schedule_id"`
	TargetID   int64         `json:"target_id"`
	Status     string        `json:"status"`
	StartedAt  time.Time     `json:"started_at"`
}

func (q *Queries) CreateBackup(ctx context.Context, arg CreateBackupParams) (Backup, error) {
	row := q.queryRow(ctx, q.createBackupStmt, createBackup,
		arg.ScheduleID,
		arg.TargetID,
		arg.Status,
		arg.StartedAt,
	)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.ScheduleID,
		&i.TargetID,
		&i.Status,
		&i.SizeBytes,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.NotificationSent,
	)
	return i, err
}

const createBackupSchedule = `-- name: CreateBackupSchedule :one
INSERT INTO backup_schedules (
    name,
    description,
    cron_expression,
    target_id,
    retention_days,
    enabled,
    created_at,
    updated_at
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP
) RETURNING id, name, description, cron_expression, target_id, retention_days, enabled, created_at, updated_at, last_run_at, next_run_at
`

type CreateBackupScheduleParams struct {
	Name           string         `json:"name"`
	Description    sql.NullString `json:"description"`
	CronExpression string         `json:"cron_expression"`
	TargetID       int64          `json:"target_id"`
	RetentionDays  int64          `json:"retention_days"`
	Enabled        bool           `json:"enabled"`
}

func (q *Queries) CreateBackupSchedule(ctx context.Context, arg CreateBackupScheduleParams) (BackupSchedule, error) {
	row := q.queryRow(ctx, q.createBackupScheduleStmt, createBackupSchedule,
		arg.Name,
		arg.Description,
		arg.CronExpression,
		arg.TargetID,
		arg.RetentionDays,
		arg.Enabled,
	)
	var i BackupSchedule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CronExpression,
		&i.TargetID,
		&i.RetentionDays,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastRunAt,
		&i.NextRunAt,
	)
	return i, err
}

const createBackupTarget = `-- name: CreateBackupTarget :one
INSERT INTO backup_targets (
    name,
    type,
    bucket_name,
    region,
    endpoint,
    bucket_path,
    access_key_id,
    secret_key,
    s3_path_style,
    restic_password,
    created_at,
    updated_at
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP
) RETURNING id, name, bucket_name, region, endpoint, bucket_path, access_key_id, secret_key, s3_path_style, restic_password, type, created_at, updated_at
`

type CreateBackupTargetParams struct {
	Name           string         `json:"name"`
	Type           string         `json:"type"`
	BucketName     sql.NullString `json:"bucket_name"`
	Region         sql.NullString `json:"region"`
	Endpoint       sql.NullString `json:"endpoint"`
	BucketPath     sql.NullString `json:"bucket_path"`
	AccessKeyID    sql.NullString `json:"access_key_id"`
	SecretKey      sql.NullString `json:"secret_key"`
	S3PathStyle    sql.NullBool   `json:"s3_path_style"`
	ResticPassword sql.NullString `json:"restic_password"`
}

func (q *Queries) CreateBackupTarget(ctx context.Context, arg CreateBackupTargetParams) (BackupTarget, error) {
	row := q.queryRow(ctx, q.createBackupTargetStmt, createBackupTarget,
		arg.Name,
		arg.Type,
		arg.BucketName,
		arg.Region,
		arg.Endpoint,
		arg.BucketPath,
		arg.AccessKeyID,
		arg.SecretKey,
		arg.S3PathStyle,
		arg.ResticPassword,
	)
	var i BackupTarget
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BucketName,
		&i.Region,
		&i.Endpoint,
		&i.BucketPath,
		&i.AccessKeyID,
		&i.SecretKey,
		&i.S3PathStyle,
		&i.ResticPassword,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createFabricOrganization = `-- name: CreateFabricOrganization :one
INSERT INTO fabric_organizations (
    msp_id, description, config, ca_config, sign_key_id,
    tls_root_key_id, provider_id, created_by,
    admin_tls_key_id, admin_sign_key_id, client_sign_key_id
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, msp_id, description, config, ca_config, sign_key_id, tls_root_key_id, admin_tls_key_id, admin_sign_key_id, client_sign_key_id, provider_id, created_at, created_by, updated_at, crl_key_id, crl_last_update
`

type CreateFabricOrganizationParams struct {
	MspID           string         `json:"msp_id"`
	Description     sql.NullString `json:"description"`
	Config          sql.NullString `json:"config"`
	CaConfig        sql.NullString `json:"ca_config"`
	SignKeyID       sql.NullInt64  `json:"sign_key_id"`
	TlsRootKeyID    sql.NullInt64  `json:"tls_root_key_id"`
	ProviderID      sql.NullInt64  `json:"provider_id"`
	CreatedBy       sql.NullInt64  `json:"created_by"`
	AdminTlsKeyID   sql.NullInt64  `json:"admin_tls_key_id"`
	AdminSignKeyID  sql.NullInt64  `json:"admin_sign_key_id"`
	ClientSignKeyID sql.NullInt64  `json:"client_sign_key_id"`
}

func (q *Queries) CreateFabricOrganization(ctx context.Context, arg CreateFabricOrganizationParams) (FabricOrganization, error) {
	row := q.queryRow(ctx, q.createFabricOrganizationStmt, createFabricOrganization,
		arg.MspID,
		arg.Description,
		arg.Config,
		arg.CaConfig,
		arg.SignKeyID,
		arg.TlsRootKeyID,
		arg.ProviderID,
		arg.CreatedBy,
		arg.AdminTlsKeyID,
		arg.AdminSignKeyID,
		arg.ClientSignKeyID,
	)
	var i FabricOrganization
	err := row.Scan(
		&i.ID,
		&i.MspID,
		&i.Description,
		&i.Config,
		&i.CaConfig,
		&i.SignKeyID,
		&i.TlsRootKeyID,
		&i.AdminTlsKeyID,
		&i.AdminSignKeyID,
		&i.ClientSignKeyID,
		&i.ProviderID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.CrlKeyID,
		&i.CrlLastUpdate,
	)
	return i, err
}

const createKey = `-- name: CreateKey :one
INSERT INTO keys (
    name, description, algorithm, key_size, curve, format,
    public_key, private_key, certificate, status, expires_at, sha256_fingerprint,
    sha1_fingerprint, provider_id, user_id, is_ca, ethereum_address
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, description, algorithm, key_size, curve, format, public_key, private_key, certificate, status, created_at, updated_at, expires_at, last_rotated_at, signing_key_id, sha256_fingerprint, sha1_fingerprint, provider_id, user_id, is_ca, ethereum_address
`

type CreateKeyParams struct {
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Algorithm         string         `json:"algorithm"`
	KeySize           sql.NullInt64  `json:"key_size"`
	Curve             sql.NullString `json:"curve"`
	Format            string         `json:"format"`
	PublicKey         string         `json:"public_key"`
	PrivateKey        string         `json:"private_key"`
	Certificate       sql.NullString `json:"certificate"`
	Status            string         `json:"status"`
	ExpiresAt         sql.NullTime   `json:"expires_at"`
	Sha256Fingerprint string         `json:"sha256_fingerprint"`
	Sha1Fingerprint   string         `json:"sha1_fingerprint"`
	ProviderID        int64          `json:"provider_id"`
	UserID            int64          `json:"user_id"`
	IsCa              int64          `json:"is_ca"`
	EthereumAddress   sql.NullString `json:"ethereum_address"`
}

func (q *Queries) CreateKey(ctx context.Context, arg CreateKeyParams) (Key, error) {
	row := q.queryRow(ctx, q.createKeyStmt, createKey,
		arg.Name,
		arg.Description,
		arg.Algorithm,
		arg.KeySize,
		arg.Curve,
		arg.Format,
		arg.PublicKey,
		arg.PrivateKey,
		arg.Certificate,
		arg.Status,
		arg.ExpiresAt,
		arg.Sha256Fingerprint,
		arg.Sha1Fingerprint,
		arg.ProviderID,
		arg.UserID,
		arg.IsCa,
		arg.EthereumAddress,
	)
	var i Key
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Algorithm,
		&i.KeySize,
		&i.Curve,
		&i.Format,
		&i.PublicKey,
		&i.PrivateKey,
		&i.Certificate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.LastRotatedAt,
		&i.SigningKeyID,
		&i.Sha256Fingerprint,
		&i.Sha1Fingerprint,
		&i.ProviderID,
		&i.UserID,
		&i.IsCa,
		&i.EthereumAddress,
	)
	return i, err
}

const createKeyProvider = `-- name: CreateKeyProvider :one
INSERT INTO key_providers (name, type, is_default, config)
VALUES (?, ?, ?, ?)
RETURNING id, name, type, is_default, config, created_at, updated_at
`

type CreateKeyProviderParams struct {
	Name      string `json:"name"`
	Type      string `json:"type"`
	IsDefault int64  `json:"is_default"`
	Config    string `json:"config"`
}

func (q *Queries) CreateKeyProvider(ctx context.Context, arg CreateKeyProviderParams) (KeyProvider, error) {
	row := q.queryRow(ctx, q.createKeyProviderStmt, createKeyProvider,
		arg.Name,
		arg.Type,
		arg.IsDefault,
		arg.Config,
	)
	var i KeyProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.IsDefault,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createNetwork = `-- name: CreateNetwork :one
INSERT INTO networks (
    name, platform, status, description, config,
    deployment_config, exposed_ports, domain, created_by, network_id
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, name, network_id, platform, status, description, config, deployment_config, exposed_ports, domain, created_at, created_by, updated_at, genesis_block_b64, current_config_block_b64
`

type CreateNetworkParams struct {
	Name             string         `json:"name"`
	Platform         string         `json:"platform"`
	Status           string         `json:"status"`
	Description      sql.NullString `json:"description"`
	Config           sql.NullString `json:"config"`
	DeploymentConfig sql.NullString `json:"deployment_config"`
	ExposedPorts     sql.NullString `json:"exposed_ports"`
	Domain           sql.NullString `json:"domain"`
	CreatedBy        sql.NullInt64  `json:"created_by"`
	NetworkID        sql.NullString `json:"network_id"`
}

func (q *Queries) CreateNetwork(ctx context.Context, arg CreateNetworkParams) (Network, error) {
	row := q.queryRow(ctx, q.createNetworkStmt, createNetwork,
		arg.Name,
		arg.Platform,
		arg.Status,
		arg.Description,
		arg.Config,
		arg.DeploymentConfig,
		arg.ExposedPorts,
		arg.Domain,
		arg.CreatedBy,
		arg.NetworkID,
	)
	var i Network
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NetworkID,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.Config,
		&i.DeploymentConfig,
		&i.ExposedPorts,
		&i.Domain,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.GenesisBlockB64,
		&i.CurrentConfigBlockB64,
	)
	return i, err
}

const createNetworkFull = `-- name: CreateNetworkFull :one
INSERT INTO networks (
    name, platform, status, description, config,
    deployment_config, exposed_ports, domain, created_by, network_id, genesis_block_b64
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, name, network_id, platform, status, description, config, deployment_config, exposed_ports, domain, created_at, created_by, updated_at, genesis_block_b64, current_config_block_b64
`

type CreateNetworkFullParams struct {
	Name             string         `json:"name"`
	Platform         string         `json:"platform"`
	Status           string         `json:"status"`
	Description      sql.NullString `json:"description"`
	Config           sql.NullString `json:"config"`
	DeploymentConfig sql.NullString `json:"deployment_config"`
	ExposedPorts     sql.NullString `json:"exposed_ports"`
	Domain           sql.NullString `json:"domain"`
	CreatedBy        sql.NullInt64  `json:"created_by"`
	NetworkID        sql.NullString `json:"network_id"`
	GenesisBlockB64  sql.NullString `json:"genesis_block_b64"`
}

func (q *Queries) CreateNetworkFull(ctx context.Context, arg CreateNetworkFullParams) (Network, error) {
	row := q.queryRow(ctx, q.createNetworkFullStmt, createNetworkFull,
		arg.Name,
		arg.Platform,
		arg.Status,
		arg.Description,
		arg.Config,
		arg.DeploymentConfig,
		arg.ExposedPorts,
		arg.Domain,
		arg.CreatedBy,
		arg.NetworkID,
		arg.GenesisBlockB64,
	)
	var i Network
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NetworkID,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.Config,
		&i.DeploymentConfig,
		&i.ExposedPorts,
		&i.Domain,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.GenesisBlockB64,
		&i.CurrentConfigBlockB64,
	)
	return i, err
}

const createNetworkNode = `-- name: CreateNetworkNode :one
INSERT INTO network_nodes (
    network_id,
    node_id,
    status,
    role
) VALUES (
    ?, ?, ?, ?
) RETURNING id, network_id, node_id, role, status, config, created_at, updated_at
`

type CreateNetworkNodeParams struct {
	NetworkID int64  `json:"network_id"`
	NodeID    int64  `json:"node_id"`
	Status    string `json:"status"`
	Role      string `json:"role"`
}

// Add queries for CRUD operations
func (q *Queries) CreateNetworkNode(ctx context.Context, arg CreateNetworkNodeParams) (NetworkNode, error) {
	row := q.queryRow(ctx, q.createNetworkNodeStmt, createNetworkNode,
		arg.NetworkID,
		arg.NodeID,
		arg.Status,
		arg.Role,
	)
	var i NetworkNode
	err := row.Scan(
		&i.ID,
		&i.NetworkID,
		&i.NodeID,
		&i.Role,
		&i.Status,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createNode = `-- name: CreateNode :one
INSERT INTO nodes (
    name,
    slug,
    platform,
    status,
    description,
    network_id,
    config,
    resources,
    endpoint,
    public_endpoint,
    p2p_address,
    created_by,
    fabric_organization_id,
    node_type,
    node_config,
    created_at,
    updated_at
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP
) RETURNING id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config
`

type CreateNodeParams struct {
	Name                 string         `json:"name"`
	Slug                 string         `json:"slug"`
	Platform             string         `json:"platform"`
	Status               string         `json:"status"`
	Description          sql.NullString `json:"description"`
	NetworkID            sql.NullInt64  `json:"network_id"`
	Config               sql.NullString `json:"config"`
	Resources            sql.NullString `json:"resources"`
	Endpoint             sql.NullString `json:"endpoint"`
	PublicEndpoint       sql.NullString `json:"public_endpoint"`
	P2pAddress           sql.NullString `json:"p2p_address"`
	CreatedBy            sql.NullInt64  `json:"created_by"`
	FabricOrganizationID sql.NullInt64  `json:"fabric_organization_id"`
	NodeType             sql.NullString `json:"node_type"`
	NodeConfig           sql.NullString `json:"node_config"`
}

func (q *Queries) CreateNode(ctx context.Context, arg CreateNodeParams) (Node, error) {
	row := q.queryRow(ctx, q.createNodeStmt, createNode,
		arg.Name,
		arg.Slug,
		arg.Platform,
		arg.Status,
		arg.Description,
		arg.NetworkID,
		arg.Config,
		arg.Resources,
		arg.Endpoint,
		arg.PublicEndpoint,
		arg.P2pAddress,
		arg.CreatedBy,
		arg.FabricOrganizationID,
		arg.NodeType,
		arg.NodeConfig,
	)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.NetworkID,
		&i.Config,
		&i.Resources,
		&i.Endpoint,
		&i.PublicEndpoint,
		&i.P2pAddress,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.FabricOrganizationID,
		&i.NodeType,
		&i.NodeConfig,
		&i.DeploymentConfig,
	)
	return i, err
}

const createNodeEvent = `-- name: CreateNodeEvent :one
INSERT INTO node_events (
    node_id,
    event_type,
    description,
    data,
    status
) VALUES (
    ?, ?, ?, ?, ?
)
RETURNING id, node_id, event_type, description, data, status, created_at
`

type CreateNodeEventParams struct {
	NodeID      int64          `json:"node_id"`
	EventType   string         `json:"event_type"`
	Description string         `json:"description"`
	Data        sql.NullString `json:"data"`
	Status      string         `json:"status"`
}

func (q *Queries) CreateNodeEvent(ctx context.Context, arg CreateNodeEventParams) (NodeEvent, error) {
	row := q.queryRow(ctx, q.createNodeEventStmt, createNodeEvent,
		arg.NodeID,
		arg.EventType,
		arg.Description,
		arg.Data,
		arg.Status,
	)
	var i NodeEvent
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.EventType,
		&i.Description,
		&i.Data,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createNotificationProvider = `-- name: CreateNotificationProvider :one
INSERT INTO notification_providers (
    type,
    name,
    config,
    is_default,
    notify_node_downtime,
    notify_backup_success,
    notify_backup_failure,
    notify_s3_connection_issue,
    created_at,
    updated_at
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP
) RETURNING id, name, type, config, is_default, is_enabled, created_at, updated_at, notify_node_downtime, notify_backup_success, notify_backup_failure, notify_s3_connection_issue, last_test_at, last_test_status, last_test_message
`

type CreateNotificationProviderParams struct {
	Type                    string `json:"type"`
	Name                    string `json:"name"`
	Config                  string `json:"config"`
	IsDefault               bool   `json:"is_default"`
	NotifyNodeDowntime      bool   `json:"notify_node_downtime"`
	NotifyBackupSuccess     bool   `json:"notify_backup_success"`
	NotifyBackupFailure     bool   `json:"notify_backup_failure"`
	NotifyS3ConnectionIssue bool   `json:"notify_s3_connection_issue"`
}

func (q *Queries) CreateNotificationProvider(ctx context.Context, arg CreateNotificationProviderParams) (NotificationProvider, error) {
	row := q.queryRow(ctx, q.createNotificationProviderStmt, createNotificationProvider,
		arg.Type,
		arg.Name,
		arg.Config,
		arg.IsDefault,
		arg.NotifyNodeDowntime,
		arg.NotifyBackupSuccess,
		arg.NotifyBackupFailure,
		arg.NotifyS3ConnectionIssue,
	)
	var i NotificationProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Config,
		&i.IsDefault,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotifyNodeDowntime,
		&i.NotifyBackupSuccess,
		&i.NotifyBackupFailure,
		&i.NotifyS3ConnectionIssue,
		&i.LastTestAt,
		&i.LastTestStatus,
		&i.LastTestMessage,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
    session_id,
    user_id,
    token,
    expires_at
) VALUES (
    ?,
    ?,
    ?,
    ?
) RETURNING id, session_id, user_id, token, ip_address, user_agent, created_at, updated_at, expires_at, last_activity_at
`

type CreateSessionParams struct {
	SessionID string    `json:"session_id"`
	UserID    int64     `json:"user_id"`
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.queryRow(ctx, q.createSessionStmt, createSession,
		arg.SessionID,
		arg.UserID,
		arg.Token,
		arg.ExpiresAt,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.UserID,
		&i.Token,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.LastActivityAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    username, password, created_at, last_login_at, updated_at
) VALUES (
    ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
)
RETURNING id, username, password, name, email, role, provider, provider_id, avatar_url, created_at, last_login_at, updated_at
`

type CreateUserParams struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.queryRow(ctx, q.createUserStmt, createUser, arg.Username, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Name,
		&i.Email,
		&i.Role,
		&i.Provider,
		&i.ProviderID,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.LastLoginAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBackup = `-- name: DeleteBackup :exec
DELETE FROM backups WHERE id = ?
`

func (q *Queries) DeleteBackup(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteBackupStmt, deleteBackup, id)
	return err
}

const deleteBackupSchedule = `-- name: DeleteBackupSchedule :exec
DELETE FROM backup_schedules WHERE id = ?
`

func (q *Queries) DeleteBackupSchedule(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteBackupScheduleStmt, deleteBackupSchedule, id)
	return err
}

const deleteBackupTarget = `-- name: DeleteBackupTarget :exec
DELETE FROM backup_targets WHERE id = ?
`

func (q *Queries) DeleteBackupTarget(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteBackupTargetStmt, deleteBackupTarget, id)
	return err
}

const deleteBackupsBySchedule = `-- name: DeleteBackupsBySchedule :exec
DELETE FROM backups
WHERE schedule_id = ?
`

func (q *Queries) DeleteBackupsBySchedule(ctx context.Context, scheduleID sql.NullInt64) error {
	_, err := q.exec(ctx, q.deleteBackupsByScheduleStmt, deleteBackupsBySchedule, scheduleID)
	return err
}

const deleteBackupsByTarget = `-- name: DeleteBackupsByTarget :exec
DELETE FROM backups
WHERE target_id = ?
`

func (q *Queries) DeleteBackupsByTarget(ctx context.Context, targetID int64) error {
	_, err := q.exec(ctx, q.deleteBackupsByTargetStmt, deleteBackupsByTarget, targetID)
	return err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM sessions
WHERE expires_at <= CURRENT_TIMESTAMP
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) error {
	_, err := q.exec(ctx, q.deleteExpiredSessionsStmt, deleteExpiredSessions)
	return err
}

const deleteFabricOrganization = `-- name: DeleteFabricOrganization :exec
DELETE FROM fabric_organizations WHERE id = ?
`

func (q *Queries) DeleteFabricOrganization(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteFabricOrganizationStmt, deleteFabricOrganization, id)
	return err
}

const deleteKey = `-- name: DeleteKey :exec
DELETE FROM keys WHERE id = ?
`

func (q *Queries) DeleteKey(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteKeyStmt, deleteKey, id)
	return err
}

const deleteKeyProvider = `-- name: DeleteKeyProvider :exec
DELETE FROM key_providers WHERE id = ?
`

func (q *Queries) DeleteKeyProvider(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteKeyProviderStmt, deleteKeyProvider, id)
	return err
}

const deleteNetwork = `-- name: DeleteNetwork :exec
DELETE FROM networks
WHERE id = ?
`

func (q *Queries) DeleteNetwork(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteNetworkStmt, deleteNetwork, id)
	return err
}

const deleteNetworkNode = `-- name: DeleteNetworkNode :exec
DELETE FROM network_nodes
WHERE network_id = ? AND node_id = ?
`

type DeleteNetworkNodeParams struct {
	NetworkID int64 `json:"network_id"`
	NodeID    int64 `json:"node_id"`
}

func (q *Queries) DeleteNetworkNode(ctx context.Context, arg DeleteNetworkNodeParams) error {
	_, err := q.exec(ctx, q.deleteNetworkNodeStmt, deleteNetworkNode, arg.NetworkID, arg.NodeID)
	return err
}

const deleteNode = `-- name: DeleteNode :exec
DELETE FROM nodes WHERE id = ?
`

func (q *Queries) DeleteNode(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteNodeStmt, deleteNode, id)
	return err
}

const deleteNotificationProvider = `-- name: DeleteNotificationProvider :exec
DELETE FROM notification_providers
WHERE id = ?
`

func (q *Queries) DeleteNotificationProvider(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteNotificationProviderStmt, deleteNotificationProvider, id)
	return err
}

const deleteOldBackups = `-- name: DeleteOldBackups :exec
DELETE FROM backups
WHERE target_id = ? 
AND created_at < ?
`

type DeleteOldBackupsParams struct {
	TargetID  int64     `json:"target_id"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) DeleteOldBackups(ctx context.Context, arg DeleteOldBackupsParams) error {
	_, err := q.exec(ctx, q.deleteOldBackupsStmt, deleteOldBackups, arg.TargetID, arg.CreatedAt)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions
WHERE session_id = ?
`

func (q *Queries) DeleteSession(ctx context.Context, sessionID string) error {
	_, err := q.exec(ctx, q.deleteSessionStmt, deleteSession, sessionID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = ?
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteUserStmt, deleteUser, id)
	return err
}

const deleteUserSessions = `-- name: DeleteUserSessions :exec
DELETE FROM sessions
WHERE user_id = ?
`

func (q *Queries) DeleteUserSessions(ctx context.Context, userID int64) error {
	_, err := q.exec(ctx, q.deleteUserSessionsStmt, deleteUserSessions, userID)
	return err
}

const disableBackupSchedule = `-- name: DisableBackupSchedule :one
UPDATE backup_schedules
SET enabled = false,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, description, cron_expression, target_id, retention_days, enabled, created_at, updated_at, last_run_at, next_run_at
`

func (q *Queries) DisableBackupSchedule(ctx context.Context, id int64) (BackupSchedule, error) {
	row := q.queryRow(ctx, q.disableBackupScheduleStmt, disableBackupSchedule, id)
	var i BackupSchedule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CronExpression,
		&i.TargetID,
		&i.RetentionDays,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastRunAt,
		&i.NextRunAt,
	)
	return i, err
}

const enableBackupSchedule = `-- name: EnableBackupSchedule :one
UPDATE backup_schedules
SET enabled = true,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, description, cron_expression, target_id, retention_days, enabled, created_at, updated_at, last_run_at, next_run_at
`

func (q *Queries) EnableBackupSchedule(ctx context.Context, id int64) (BackupSchedule, error) {
	row := q.queryRow(ctx, q.enableBackupScheduleStmt, enableBackupSchedule, id)
	var i BackupSchedule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CronExpression,
		&i.TargetID,
		&i.RetentionDays,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastRunAt,
		&i.NextRunAt,
	)
	return i, err
}

const getAllKeys = `-- name: GetAllKeys :many
SELECT k.id, k.name, k.description, k.algorithm, k.key_size, k.curve, k.format, k.public_key, k.private_key, k.certificate, k.status, k.created_at, k.updated_at, k.expires_at, k.last_rotated_at, k.signing_key_id, k.sha256_fingerprint, k.sha1_fingerprint, k.provider_id, k.user_id, k.is_ca, k.ethereum_address, kp.name as provider_name, kp.type as provider_type
FROM keys k
JOIN key_providers kp ON k.provider_id = kp.id
WHERE (? IS NULL OR k.provider_id = ?)
`

type GetAllKeysParams struct {
	Column1    interface{} `json:"column_1"`
	ProviderID int64       `json:"provider_id"`
}

type GetAllKeysRow struct {
	ID                int64          `json:"id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Algorithm         string         `json:"algorithm"`
	KeySize           sql.NullInt64  `json:"key_size"`
	Curve             sql.NullString `json:"curve"`
	Format            string         `json:"format"`
	PublicKey         string         `json:"public_key"`
	PrivateKey        string         `json:"private_key"`
	Certificate       sql.NullString `json:"certificate"`
	Status            string         `json:"status"`
	CreatedAt         time.Time      `json:"created_at"`
	UpdatedAt         time.Time      `json:"updated_at"`
	ExpiresAt         sql.NullTime   `json:"expires_at"`
	LastRotatedAt     sql.NullTime   `json:"last_rotated_at"`
	SigningKeyID      sql.NullInt64  `json:"signing_key_id"`
	Sha256Fingerprint string         `json:"sha256_fingerprint"`
	Sha1Fingerprint   string         `json:"sha1_fingerprint"`
	ProviderID        int64          `json:"provider_id"`
	UserID            int64          `json:"user_id"`
	IsCa              int64          `json:"is_ca"`
	EthereumAddress   sql.NullString `json:"ethereum_address"`
	ProviderName      string         `json:"provider_name"`
	ProviderType      string         `json:"provider_type"`
}

func (q *Queries) GetAllKeys(ctx context.Context, arg GetAllKeysParams) ([]GetAllKeysRow, error) {
	rows, err := q.query(ctx, q.getAllKeysStmt, getAllKeys, arg.Column1, arg.ProviderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllKeysRow{}
	for rows.Next() {
		var i GetAllKeysRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Algorithm,
			&i.KeySize,
			&i.Curve,
			&i.Format,
			&i.PublicKey,
			&i.PrivateKey,
			&i.Certificate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
			&i.LastRotatedAt,
			&i.SigningKeyID,
			&i.Sha256Fingerprint,
			&i.Sha1Fingerprint,
			&i.ProviderID,
			&i.UserID,
			&i.IsCa,
			&i.EthereumAddress,
			&i.ProviderName,
			&i.ProviderType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllNodes = `-- name: GetAllNodes :many
SELECT id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config FROM nodes
`

func (q *Queries) GetAllNodes(ctx context.Context) ([]Node, error) {
	rows, err := q.query(ctx, q.getAllNodesStmt, getAllNodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Platform,
			&i.Status,
			&i.Description,
			&i.NetworkID,
			&i.Config,
			&i.Resources,
			&i.Endpoint,
			&i.PublicEndpoint,
			&i.P2pAddress,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.FabricOrganizationID,
			&i.NodeType,
			&i.NodeConfig,
			&i.DeploymentConfig,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBackup = `-- name: GetBackup :one
SELECT id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent FROM backups
WHERE id = ? LIMIT 1
`

func (q *Queries) GetBackup(ctx context.Context, id int64) (Backup, error) {
	row := q.queryRow(ctx, q.getBackupStmt, getBackup, id)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.ScheduleID,
		&i.TargetID,
		&i.Status,
		&i.SizeBytes,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.NotificationSent,
	)
	return i, err
}

const getBackupSchedule = `-- name: GetBackupSchedule :one
SELECT id, name, description, cron_expression, target_id, retention_days, enabled, created_at, updated_at, last_run_at, next_run_at FROM backup_schedules
WHERE id = ? LIMIT 1
`

func (q *Queries) GetBackupSchedule(ctx context.Context, id int64) (BackupSchedule, error) {
	row := q.queryRow(ctx, q.getBackupScheduleStmt, getBackupSchedule, id)
	var i BackupSchedule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CronExpression,
		&i.TargetID,
		&i.RetentionDays,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastRunAt,
		&i.NextRunAt,
	)
	return i, err
}

const getBackupTarget = `-- name: GetBackupTarget :one
SELECT id, name, bucket_name, region, endpoint, bucket_path, access_key_id, secret_key, s3_path_style, restic_password, type, created_at, updated_at FROM backup_targets
WHERE id = ? LIMIT 1
`

func (q *Queries) GetBackupTarget(ctx context.Context, id int64) (BackupTarget, error) {
	row := q.queryRow(ctx, q.getBackupTargetStmt, getBackupTarget, id)
	var i BackupTarget
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BucketName,
		&i.Region,
		&i.Endpoint,
		&i.BucketPath,
		&i.AccessKeyID,
		&i.SecretKey,
		&i.S3PathStyle,
		&i.ResticPassword,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBackupsByDateRange = `-- name: GetBackupsByDateRange :many
SELECT id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent FROM backups
WHERE created_at BETWEEN ? AND ?
ORDER BY created_at DESC
`

type GetBackupsByDateRangeParams struct {
	FromCreatedAt time.Time `json:"from_created_at"`
	ToCreatedAt   time.Time `json:"to_created_at"`
}

func (q *Queries) GetBackupsByDateRange(ctx context.Context, arg GetBackupsByDateRangeParams) ([]Backup, error) {
	rows, err := q.query(ctx, q.getBackupsByDateRangeStmt, getBackupsByDateRange, arg.FromCreatedAt, arg.ToCreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Backup{}
	for rows.Next() {
		var i Backup
		if err := rows.Scan(
			&i.ID,
			&i.ScheduleID,
			&i.TargetID,
			&i.Status,
			&i.SizeBytes,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.NotificationSent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBackupsByScheduleAndStatus = `-- name: GetBackupsByScheduleAndStatus :many
SELECT id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent FROM backups
WHERE schedule_id = ? AND status = ?
ORDER BY created_at DESC
`

type GetBackupsByScheduleAndStatusParams struct {
	ScheduleID sql.NullInt64 `json:"schedule_id"`
	Status     string        `json:"status"`
}

func (q *Queries) GetBackupsByScheduleAndStatus(ctx context.Context, arg GetBackupsByScheduleAndStatusParams) ([]Backup, error) {
	rows, err := q.query(ctx, q.getBackupsByScheduleAndStatusStmt, getBackupsByScheduleAndStatus, arg.ScheduleID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Backup{}
	for rows.Next() {
		var i Backup
		if err := rows.Scan(
			&i.ID,
			&i.ScheduleID,
			&i.TargetID,
			&i.Status,
			&i.SizeBytes,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.NotificationSent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBackupsByStatus = `-- name: GetBackupsByStatus :many
SELECT id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent FROM backups
WHERE status = ?
ORDER BY created_at DESC
`

func (q *Queries) GetBackupsByStatus(ctx context.Context, status string) ([]Backup, error) {
	rows, err := q.query(ctx, q.getBackupsByStatusStmt, getBackupsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Backup{}
	for rows.Next() {
		var i Backup
		if err := rows.Scan(
			&i.ID,
			&i.ScheduleID,
			&i.TargetID,
			&i.Status,
			&i.SizeBytes,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.NotificationSent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDefaultNotificationProvider = `-- name: GetDefaultNotificationProvider :one
SELECT id, name, type, config, is_default, is_enabled, created_at, updated_at, notify_node_downtime, notify_backup_success, notify_backup_failure, notify_s3_connection_issue, last_test_at, last_test_status, last_test_message FROM notification_providers
WHERE is_default = 1 AND type = ?
LIMIT 1
`

func (q *Queries) GetDefaultNotificationProvider(ctx context.Context, type_ string) (NotificationProvider, error) {
	row := q.queryRow(ctx, q.getDefaultNotificationProviderStmt, getDefaultNotificationProvider, type_)
	var i NotificationProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Config,
		&i.IsDefault,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotifyNodeDowntime,
		&i.NotifyBackupSuccess,
		&i.NotifyBackupFailure,
		&i.NotifyS3ConnectionIssue,
		&i.LastTestAt,
		&i.LastTestStatus,
		&i.LastTestMessage,
	)
	return i, err
}

const getDefaultNotificationProviderForType = `-- name: GetDefaultNotificationProviderForType :one
SELECT id, name, type, config, is_default, is_enabled, created_at, updated_at, notify_node_downtime, notify_backup_success, notify_backup_failure, notify_s3_connection_issue, last_test_at, last_test_status, last_test_message FROM notification_providers
WHERE is_default = true
  AND (
    (?1 = 'BACKUP_SUCCESS' AND notify_backup_success = true) OR
    (?1 = 'BACKUP_FAILURE' AND notify_backup_failure = true) OR
    (?1 = 'NODE_DOWNTIME' AND notify_node_downtime = true) OR
    (?1 = 'S3_CONNECTION_ISSUE' AND notify_s3_connection_issue = true)
  )
LIMIT 1
`

func (q *Queries) GetDefaultNotificationProviderForType(ctx context.Context, notificationType interface{}) (NotificationProvider, error) {
	row := q.queryRow(ctx, q.getDefaultNotificationProviderForTypeStmt, getDefaultNotificationProviderForType, notificationType)
	var i NotificationProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Config,
		&i.IsDefault,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotifyNodeDowntime,
		&i.NotifyBackupSuccess,
		&i.NotifyBackupFailure,
		&i.NotifyS3ConnectionIssue,
		&i.LastTestAt,
		&i.LastTestStatus,
		&i.LastTestMessage,
	)
	return i, err
}

const getFabricOrganization = `-- name: GetFabricOrganization :one
SELECT id, msp_id, description, config, ca_config, sign_key_id, tls_root_key_id, admin_tls_key_id, admin_sign_key_id, client_sign_key_id, provider_id, created_at, created_by, updated_at, crl_key_id, crl_last_update FROM fabric_organizations
WHERE id = ? LIMIT 1
`

func (q *Queries) GetFabricOrganization(ctx context.Context, id int64) (FabricOrganization, error) {
	row := q.queryRow(ctx, q.getFabricOrganizationStmt, getFabricOrganization, id)
	var i FabricOrganization
	err := row.Scan(
		&i.ID,
		&i.MspID,
		&i.Description,
		&i.Config,
		&i.CaConfig,
		&i.SignKeyID,
		&i.TlsRootKeyID,
		&i.AdminTlsKeyID,
		&i.AdminSignKeyID,
		&i.ClientSignKeyID,
		&i.ProviderID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.CrlKeyID,
		&i.CrlLastUpdate,
	)
	return i, err
}

const getFabricOrganizationByID = `-- name: GetFabricOrganizationByID :one
SELECT id, msp_id, description, config, ca_config, sign_key_id, tls_root_key_id, admin_tls_key_id, admin_sign_key_id, client_sign_key_id, provider_id, created_at, created_by, updated_at, crl_key_id, crl_last_update FROM fabric_organizations WHERE id = ? LIMIT 1
`

func (q *Queries) GetFabricOrganizationByID(ctx context.Context, id int64) (FabricOrganization, error) {
	row := q.queryRow(ctx, q.getFabricOrganizationByIDStmt, getFabricOrganizationByID, id)
	var i FabricOrganization
	err := row.Scan(
		&i.ID,
		&i.MspID,
		&i.Description,
		&i.Config,
		&i.CaConfig,
		&i.SignKeyID,
		&i.TlsRootKeyID,
		&i.AdminTlsKeyID,
		&i.AdminSignKeyID,
		&i.ClientSignKeyID,
		&i.ProviderID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.CrlKeyID,
		&i.CrlLastUpdate,
	)
	return i, err
}

const getFabricOrganizationByMSPID = `-- name: GetFabricOrganizationByMSPID :one
SELECT id, msp_id, description, config, ca_config, sign_key_id, tls_root_key_id, admin_tls_key_id, admin_sign_key_id, client_sign_key_id, provider_id, created_at, created_by, updated_at, crl_key_id, crl_last_update FROM fabric_organizations
WHERE msp_id = ? LIMIT 1
`

func (q *Queries) GetFabricOrganizationByMSPID(ctx context.Context, mspID string) (FabricOrganization, error) {
	row := q.queryRow(ctx, q.getFabricOrganizationByMSPIDStmt, getFabricOrganizationByMSPID, mspID)
	var i FabricOrganization
	err := row.Scan(
		&i.ID,
		&i.MspID,
		&i.Description,
		&i.Config,
		&i.CaConfig,
		&i.SignKeyID,
		&i.TlsRootKeyID,
		&i.AdminTlsKeyID,
		&i.AdminSignKeyID,
		&i.ClientSignKeyID,
		&i.ProviderID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.CrlKeyID,
		&i.CrlLastUpdate,
	)
	return i, err
}

const getFabricOrganizationByMspID = `-- name: GetFabricOrganizationByMspID :one
SELECT 
    fo.id, fo.msp_id, fo.description, fo.config, fo.ca_config, fo.sign_key_id, fo.tls_root_key_id, fo.admin_tls_key_id, fo.admin_sign_key_id, fo.client_sign_key_id, fo.provider_id, fo.created_at, fo.created_by, fo.updated_at, fo.crl_key_id, fo.crl_last_update,
    sk.public_key as sign_public_key,
    sk.certificate as sign_certificate,
    tk.public_key as tls_public_key,
    tk.certificate as tls_certificate,
    p.name as provider_name
FROM fabric_organizations fo
LEFT JOIN keys sk ON fo.sign_key_id = sk.id
LEFT JOIN keys tk ON fo.tls_root_key_id = tk.id
LEFT JOIN key_providers p ON fo.provider_id = p.id
WHERE fo.msp_id = ?
`

type GetFabricOrganizationByMspIDRow struct {
	ID              int64          `json:"id"`
	MspID           string         `json:"msp_id"`
	Description     sql.NullString `json:"description"`
	Config          sql.NullString `json:"config"`
	CaConfig        sql.NullString `json:"ca_config"`
	SignKeyID       sql.NullInt64  `json:"sign_key_id"`
	TlsRootKeyID    sql.NullInt64  `json:"tls_root_key_id"`
	AdminTlsKeyID   sql.NullInt64  `json:"admin_tls_key_id"`
	AdminSignKeyID  sql.NullInt64  `json:"admin_sign_key_id"`
	ClientSignKeyID sql.NullInt64  `json:"client_sign_key_id"`
	ProviderID      sql.NullInt64  `json:"provider_id"`
	CreatedAt       time.Time      `json:"created_at"`
	CreatedBy       sql.NullInt64  `json:"created_by"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
	CrlKeyID        sql.NullInt64  `json:"crl_key_id"`
	CrlLastUpdate   sql.NullTime   `json:"crl_last_update"`
	SignPublicKey   sql.NullString `json:"sign_public_key"`
	SignCertificate sql.NullString `json:"sign_certificate"`
	TlsPublicKey    sql.NullString `json:"tls_public_key"`
	TlsCertificate  sql.NullString `json:"tls_certificate"`
	ProviderName    sql.NullString `json:"provider_name"`
}

func (q *Queries) GetFabricOrganizationByMspID(ctx context.Context, mspID string) (GetFabricOrganizationByMspIDRow, error) {
	row := q.queryRow(ctx, q.getFabricOrganizationByMspIDStmt, getFabricOrganizationByMspID, mspID)
	var i GetFabricOrganizationByMspIDRow
	err := row.Scan(
		&i.ID,
		&i.MspID,
		&i.Description,
		&i.Config,
		&i.CaConfig,
		&i.SignKeyID,
		&i.TlsRootKeyID,
		&i.AdminTlsKeyID,
		&i.AdminSignKeyID,
		&i.ClientSignKeyID,
		&i.ProviderID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.CrlKeyID,
		&i.CrlLastUpdate,
		&i.SignPublicKey,
		&i.SignCertificate,
		&i.TlsPublicKey,
		&i.TlsCertificate,
		&i.ProviderName,
	)
	return i, err
}

const getFabricOrganizationWithKeys = `-- name: GetFabricOrganizationWithKeys :one
SELECT 
    fo.id, fo.msp_id, fo.description, fo.config, fo.ca_config, fo.sign_key_id, fo.tls_root_key_id, fo.admin_tls_key_id, fo.admin_sign_key_id, fo.client_sign_key_id, fo.provider_id, fo.created_at, fo.created_by, fo.updated_at, fo.crl_key_id, fo.crl_last_update,
    sk.public_key as sign_public_key,
    sk.certificate as sign_certificate,
    tk.public_key as tls_public_key,
    tk.certificate as tls_certificate,
    p.name as provider_name
FROM fabric_organizations fo
LEFT JOIN keys sk ON fo.sign_key_id = sk.id
LEFT JOIN keys tk ON fo.tls_root_key_id = tk.id
LEFT JOIN key_providers p ON fo.provider_id = p.id
WHERE fo.id = ?
`

type GetFabricOrganizationWithKeysRow struct {
	ID              int64          `json:"id"`
	MspID           string         `json:"msp_id"`
	Description     sql.NullString `json:"description"`
	Config          sql.NullString `json:"config"`
	CaConfig        sql.NullString `json:"ca_config"`
	SignKeyID       sql.NullInt64  `json:"sign_key_id"`
	TlsRootKeyID    sql.NullInt64  `json:"tls_root_key_id"`
	AdminTlsKeyID   sql.NullInt64  `json:"admin_tls_key_id"`
	AdminSignKeyID  sql.NullInt64  `json:"admin_sign_key_id"`
	ClientSignKeyID sql.NullInt64  `json:"client_sign_key_id"`
	ProviderID      sql.NullInt64  `json:"provider_id"`
	CreatedAt       time.Time      `json:"created_at"`
	CreatedBy       sql.NullInt64  `json:"created_by"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
	CrlKeyID        sql.NullInt64  `json:"crl_key_id"`
	CrlLastUpdate   sql.NullTime   `json:"crl_last_update"`
	SignPublicKey   sql.NullString `json:"sign_public_key"`
	SignCertificate sql.NullString `json:"sign_certificate"`
	TlsPublicKey    sql.NullString `json:"tls_public_key"`
	TlsCertificate  sql.NullString `json:"tls_certificate"`
	ProviderName    sql.NullString `json:"provider_name"`
}

func (q *Queries) GetFabricOrganizationWithKeys(ctx context.Context, id int64) (GetFabricOrganizationWithKeysRow, error) {
	row := q.queryRow(ctx, q.getFabricOrganizationWithKeysStmt, getFabricOrganizationWithKeys, id)
	var i GetFabricOrganizationWithKeysRow
	err := row.Scan(
		&i.ID,
		&i.MspID,
		&i.Description,
		&i.Config,
		&i.CaConfig,
		&i.SignKeyID,
		&i.TlsRootKeyID,
		&i.AdminTlsKeyID,
		&i.AdminSignKeyID,
		&i.ClientSignKeyID,
		&i.ProviderID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.CrlKeyID,
		&i.CrlLastUpdate,
		&i.SignPublicKey,
		&i.SignCertificate,
		&i.TlsPublicKey,
		&i.TlsCertificate,
		&i.ProviderName,
	)
	return i, err
}

const getKey = `-- name: GetKey :one
SELECT k.id, k.name, k.description, k.algorithm, k.key_size, k.curve, k.format, k.public_key, k.private_key, k.certificate, k.status, k.created_at, k.updated_at, k.expires_at, k.last_rotated_at, k.signing_key_id, k.sha256_fingerprint, k.sha1_fingerprint, k.provider_id, k.user_id, k.is_ca, k.ethereum_address, kp.name as provider_name, kp.type as provider_type
FROM keys k
JOIN key_providers kp ON k.provider_id = kp.id
WHERE k.id = ?
`

type GetKeyRow struct {
	ID                int64          `json:"id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Algorithm         string         `json:"algorithm"`
	KeySize           sql.NullInt64  `json:"key_size"`
	Curve             sql.NullString `json:"curve"`
	Format            string         `json:"format"`
	PublicKey         string         `json:"public_key"`
	PrivateKey        string         `json:"private_key"`
	Certificate       sql.NullString `json:"certificate"`
	Status            string         `json:"status"`
	CreatedAt         time.Time      `json:"created_at"`
	UpdatedAt         time.Time      `json:"updated_at"`
	ExpiresAt         sql.NullTime   `json:"expires_at"`
	LastRotatedAt     sql.NullTime   `json:"last_rotated_at"`
	SigningKeyID      sql.NullInt64  `json:"signing_key_id"`
	Sha256Fingerprint string         `json:"sha256_fingerprint"`
	Sha1Fingerprint   string         `json:"sha1_fingerprint"`
	ProviderID        int64          `json:"provider_id"`
	UserID            int64          `json:"user_id"`
	IsCa              int64          `json:"is_ca"`
	EthereumAddress   sql.NullString `json:"ethereum_address"`
	ProviderName      string         `json:"provider_name"`
	ProviderType      string         `json:"provider_type"`
}

func (q *Queries) GetKey(ctx context.Context, id int64) (GetKeyRow, error) {
	row := q.queryRow(ctx, q.getKeyStmt, getKey, id)
	var i GetKeyRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Algorithm,
		&i.KeySize,
		&i.Curve,
		&i.Format,
		&i.PublicKey,
		&i.PrivateKey,
		&i.Certificate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.LastRotatedAt,
		&i.SigningKeyID,
		&i.Sha256Fingerprint,
		&i.Sha1Fingerprint,
		&i.ProviderID,
		&i.UserID,
		&i.IsCa,
		&i.EthereumAddress,
		&i.ProviderName,
		&i.ProviderType,
	)
	return i, err
}

const getKeyByEthereumAddress = `-- name: GetKeyByEthereumAddress :one
SELECT k.id, k.name, k.description, k.algorithm, k.key_size, k.curve, k.format, k.public_key, k.private_key, k.certificate, k.status, k.created_at, k.updated_at, k.expires_at, k.last_rotated_at, k.signing_key_id, k.sha256_fingerprint, k.sha1_fingerprint, k.provider_id, k.user_id, k.is_ca, k.ethereum_address, kp.name as provider_name, kp.type as provider_type
FROM keys k
JOIN key_providers kp ON k.provider_id = kp.id
WHERE k.ethereum_address = ?
`

type GetKeyByEthereumAddressRow struct {
	ID                int64          `json:"id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Algorithm         string         `json:"algorithm"`
	KeySize           sql.NullInt64  `json:"key_size"`
	Curve             sql.NullString `json:"curve"`
	Format            string         `json:"format"`
	PublicKey         string         `json:"public_key"`
	PrivateKey        string         `json:"private_key"`
	Certificate       sql.NullString `json:"certificate"`
	Status            string         `json:"status"`
	CreatedAt         time.Time      `json:"created_at"`
	UpdatedAt         time.Time      `json:"updated_at"`
	ExpiresAt         sql.NullTime   `json:"expires_at"`
	LastRotatedAt     sql.NullTime   `json:"last_rotated_at"`
	SigningKeyID      sql.NullInt64  `json:"signing_key_id"`
	Sha256Fingerprint string         `json:"sha256_fingerprint"`
	Sha1Fingerprint   string         `json:"sha1_fingerprint"`
	ProviderID        int64          `json:"provider_id"`
	UserID            int64          `json:"user_id"`
	IsCa              int64          `json:"is_ca"`
	EthereumAddress   sql.NullString `json:"ethereum_address"`
	ProviderName      string         `json:"provider_name"`
	ProviderType      string         `json:"provider_type"`
}

func (q *Queries) GetKeyByEthereumAddress(ctx context.Context, ethereumAddress sql.NullString) (GetKeyByEthereumAddressRow, error) {
	row := q.queryRow(ctx, q.getKeyByEthereumAddressStmt, getKeyByEthereumAddress, ethereumAddress)
	var i GetKeyByEthereumAddressRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Algorithm,
		&i.KeySize,
		&i.Curve,
		&i.Format,
		&i.PublicKey,
		&i.PrivateKey,
		&i.Certificate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.LastRotatedAt,
		&i.SigningKeyID,
		&i.Sha256Fingerprint,
		&i.Sha1Fingerprint,
		&i.ProviderID,
		&i.UserID,
		&i.IsCa,
		&i.EthereumAddress,
		&i.ProviderName,
		&i.ProviderType,
	)
	return i, err
}

const getKeyByID = `-- name: GetKeyByID :one
SELECT k.id, k.name, k.description, k.algorithm, k.key_size, k.curve, k.format, k.public_key, k.private_key, k.certificate, k.status, k.created_at, k.updated_at, k.expires_at, k.last_rotated_at, k.signing_key_id, k.sha256_fingerprint, k.sha1_fingerprint, k.provider_id, k.user_id, k.is_ca, k.ethereum_address, kp.name as provider_name, kp.type as provider_type
FROM keys k
JOIN key_providers kp ON k.provider_id = kp.id
WHERE k.id = ?
`

type GetKeyByIDRow struct {
	ID                int64          `json:"id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Algorithm         string         `json:"algorithm"`
	KeySize           sql.NullInt64  `json:"key_size"`
	Curve             sql.NullString `json:"curve"`
	Format            string         `json:"format"`
	PublicKey         string         `json:"public_key"`
	PrivateKey        string         `json:"private_key"`
	Certificate       sql.NullString `json:"certificate"`
	Status            string         `json:"status"`
	CreatedAt         time.Time      `json:"created_at"`
	UpdatedAt         time.Time      `json:"updated_at"`
	ExpiresAt         sql.NullTime   `json:"expires_at"`
	LastRotatedAt     sql.NullTime   `json:"last_rotated_at"`
	SigningKeyID      sql.NullInt64  `json:"signing_key_id"`
	Sha256Fingerprint string         `json:"sha256_fingerprint"`
	Sha1Fingerprint   string         `json:"sha1_fingerprint"`
	ProviderID        int64          `json:"provider_id"`
	UserID            int64          `json:"user_id"`
	IsCa              int64          `json:"is_ca"`
	EthereumAddress   sql.NullString `json:"ethereum_address"`
	ProviderName      string         `json:"provider_name"`
	ProviderType      string         `json:"provider_type"`
}

func (q *Queries) GetKeyByID(ctx context.Context, id int64) (GetKeyByIDRow, error) {
	row := q.queryRow(ctx, q.getKeyByIDStmt, getKeyByID, id)
	var i GetKeyByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Algorithm,
		&i.KeySize,
		&i.Curve,
		&i.Format,
		&i.PublicKey,
		&i.PrivateKey,
		&i.Certificate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.LastRotatedAt,
		&i.SigningKeyID,
		&i.Sha256Fingerprint,
		&i.Sha1Fingerprint,
		&i.ProviderID,
		&i.UserID,
		&i.IsCa,
		&i.EthereumAddress,
		&i.ProviderName,
		&i.ProviderType,
	)
	return i, err
}

const getKeyCountByProvider = `-- name: GetKeyCountByProvider :one
SELECT COUNT(*) FROM keys WHERE provider_id = ?
`

func (q *Queries) GetKeyCountByProvider(ctx context.Context, providerID int64) (int64, error) {
	row := q.queryRow(ctx, q.getKeyCountByProviderStmt, getKeyCountByProvider, providerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getKeyProvider = `-- name: GetKeyProvider :one
SELECT id, name, type, is_default, config, created_at, updated_at FROM key_providers WHERE id = ?
`

func (q *Queries) GetKeyProvider(ctx context.Context, id int64) (KeyProvider, error) {
	row := q.queryRow(ctx, q.getKeyProviderStmt, getKeyProvider, id)
	var i KeyProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.IsDefault,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getKeyProviderByDefault = `-- name: GetKeyProviderByDefault :one
SELECT id, name, type, is_default, config, created_at, updated_at FROM key_providers WHERE is_default = 1 LIMIT 1
`

func (q *Queries) GetKeyProviderByDefault(ctx context.Context) (KeyProvider, error) {
	row := q.queryRow(ctx, q.getKeyProviderByDefaultStmt, getKeyProviderByDefault)
	var i KeyProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.IsDefault,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getKeyProviderByID = `-- name: GetKeyProviderByID :one
SELECT id, name, type, is_default, config, created_at, updated_at FROM key_providers WHERE id = ?
`

func (q *Queries) GetKeyProviderByID(ctx context.Context, id int64) (KeyProvider, error) {
	row := q.queryRow(ctx, q.getKeyProviderByIDStmt, getKeyProviderByID, id)
	var i KeyProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.IsDefault,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getKeysByAlgorithm = `-- name: GetKeysByAlgorithm :many
SELECT id, name, description, algorithm, key_size, curve, format, public_key, private_key, certificate, status, created_at, updated_at, expires_at, last_rotated_at, signing_key_id, sha256_fingerprint, sha1_fingerprint, provider_id, user_id, is_ca, ethereum_address FROM keys WHERE algorithm = ?
`

func (q *Queries) GetKeysByAlgorithm(ctx context.Context, algorithm string) ([]Key, error) {
	rows, err := q.query(ctx, q.getKeysByAlgorithmStmt, getKeysByAlgorithm, algorithm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Key{}
	for rows.Next() {
		var i Key
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Algorithm,
			&i.KeySize,
			&i.Curve,
			&i.Format,
			&i.PublicKey,
			&i.PrivateKey,
			&i.Certificate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
			&i.LastRotatedAt,
			&i.SigningKeyID,
			&i.Sha256Fingerprint,
			&i.Sha1Fingerprint,
			&i.ProviderID,
			&i.UserID,
			&i.IsCa,
			&i.EthereumAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKeysByProviderAndCurve = `-- name: GetKeysByProviderAndCurve :many
SELECT id, name, description, algorithm, key_size, curve, format, public_key, private_key, certificate, status, created_at, updated_at, expires_at, last_rotated_at, signing_key_id, sha256_fingerprint, sha1_fingerprint, provider_id, user_id, is_ca, ethereum_address FROM keys WHERE provider_id = ? AND curve = ?
`

type GetKeysByProviderAndCurveParams struct {
	ProviderID int64          `json:"provider_id"`
	Curve      sql.NullString `json:"curve"`
}

func (q *Queries) GetKeysByProviderAndCurve(ctx context.Context, arg GetKeysByProviderAndCurveParams) ([]Key, error) {
	rows, err := q.query(ctx, q.getKeysByProviderAndCurveStmt, getKeysByProviderAndCurve, arg.ProviderID, arg.Curve)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Key{}
	for rows.Next() {
		var i Key
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Algorithm,
			&i.KeySize,
			&i.Curve,
			&i.Format,
			&i.PublicKey,
			&i.PrivateKey,
			&i.Certificate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
			&i.LastRotatedAt,
			&i.SigningKeyID,
			&i.Sha256Fingerprint,
			&i.Sha1Fingerprint,
			&i.ProviderID,
			&i.UserID,
			&i.IsCa,
			&i.EthereumAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKeysCount = `-- name: GetKeysCount :one
SELECT COUNT(*) FROM keys
`

func (q *Queries) GetKeysCount(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.getKeysCountStmt, getKeysCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLatestNodeEvent = `-- name: GetLatestNodeEvent :one
SELECT id, node_id, event_type, description, data, status, created_at FROM node_events
WHERE node_id = ?
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestNodeEvent(ctx context.Context, nodeID int64) (NodeEvent, error) {
	row := q.queryRow(ctx, q.getLatestNodeEventStmt, getLatestNodeEvent, nodeID)
	var i NodeEvent
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.EventType,
		&i.Description,
		&i.Data,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getNetwork = `-- name: GetNetwork :one
SELECT id, name, network_id, platform, status, description, config, deployment_config, exposed_ports, domain, created_at, created_by, updated_at, genesis_block_b64, current_config_block_b64 FROM networks
WHERE id = ? LIMIT 1
`

func (q *Queries) GetNetwork(ctx context.Context, id int64) (Network, error) {
	row := q.queryRow(ctx, q.getNetworkStmt, getNetwork, id)
	var i Network
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NetworkID,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.Config,
		&i.DeploymentConfig,
		&i.ExposedPorts,
		&i.Domain,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.GenesisBlockB64,
		&i.CurrentConfigBlockB64,
	)
	return i, err
}

const getNetworkByName = `-- name: GetNetworkByName :one
SELECT id, name, network_id, platform, status, description, config, deployment_config, exposed_ports, domain, created_at, created_by, updated_at, genesis_block_b64, current_config_block_b64 FROM networks
WHERE name = ? LIMIT 1
`

func (q *Queries) GetNetworkByName(ctx context.Context, name string) (Network, error) {
	row := q.queryRow(ctx, q.getNetworkByNameStmt, getNetworkByName, name)
	var i Network
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NetworkID,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.Config,
		&i.DeploymentConfig,
		&i.ExposedPorts,
		&i.Domain,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.GenesisBlockB64,
		&i.CurrentConfigBlockB64,
	)
	return i, err
}

const getNetworkByNetworkId = `-- name: GetNetworkByNetworkId :one
SELECT id, name, network_id, platform, status, description, config, deployment_config, exposed_ports, domain, created_at, created_by, updated_at, genesis_block_b64, current_config_block_b64 FROM networks
WHERE network_id = ? LIMIT 1
`

func (q *Queries) GetNetworkByNetworkId(ctx context.Context, networkID sql.NullString) (Network, error) {
	row := q.queryRow(ctx, q.getNetworkByNetworkIdStmt, getNetworkByNetworkId, networkID)
	var i Network
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NetworkID,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.Config,
		&i.DeploymentConfig,
		&i.ExposedPorts,
		&i.Domain,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.GenesisBlockB64,
		&i.CurrentConfigBlockB64,
	)
	return i, err
}

const getNetworkCurrentConfigBlock = `-- name: GetNetworkCurrentConfigBlock :one
SELECT current_config_block_b64 FROM networks
WHERE id = ?
`

func (q *Queries) GetNetworkCurrentConfigBlock(ctx context.Context, id int64) (sql.NullString, error) {
	row := q.queryRow(ctx, q.getNetworkCurrentConfigBlockStmt, getNetworkCurrentConfigBlock, id)
	var current_config_block_b64 sql.NullString
	err := row.Scan(&current_config_block_b64)
	return current_config_block_b64, err
}

const getNetworkNode = `-- name: GetNetworkNode :one
SELECT id, network_id, node_id, role, status, config, created_at, updated_at FROM network_nodes
WHERE network_id = ? AND node_id = ?
`

type GetNetworkNodeParams struct {
	NetworkID int64 `json:"network_id"`
	NodeID    int64 `json:"node_id"`
}

func (q *Queries) GetNetworkNode(ctx context.Context, arg GetNetworkNodeParams) (NetworkNode, error) {
	row := q.queryRow(ctx, q.getNetworkNodeStmt, getNetworkNode, arg.NetworkID, arg.NodeID)
	var i NetworkNode
	err := row.Scan(
		&i.ID,
		&i.NetworkID,
		&i.NodeID,
		&i.Role,
		&i.Status,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNetworkNodes = `-- name: GetNetworkNodes :many
SELECT nn.id, nn.network_id, nn.node_id, nn.role, nn.status, nn.config, nn.created_at, nn.updated_at, n.id, n.name, n.slug, n.platform, n.status, n.description, n.network_id, n.config, n.resources, n.endpoint, n.public_endpoint, n.p2p_address, n.created_at, n.created_by, n.updated_at, n.fabric_organization_id, n.node_type, n.node_config, n.deployment_config 
FROM network_nodes nn
JOIN nodes n ON nn.node_id = n.id
WHERE nn.network_id = ? 
ORDER BY nn.created_at DESC
`

type GetNetworkNodesRow struct {
	ID                   int64          `json:"id"`
	NetworkID            int64          `json:"network_id"`
	NodeID               int64          `json:"node_id"`
	Role                 string         `json:"role"`
	Status               string         `json:"status"`
	Config               sql.NullString `json:"config"`
	CreatedAt            time.Time      `json:"created_at"`
	UpdatedAt            time.Time      `json:"updated_at"`
	ID_2                 int64          `json:"id_2"`
	Name                 string         `json:"name"`
	Slug                 string         `json:"slug"`
	Platform             string         `json:"platform"`
	Status_2             string         `json:"status_2"`
	Description          sql.NullString `json:"description"`
	NetworkID_2          sql.NullInt64  `json:"network_id_2"`
	Config_2             sql.NullString `json:"config_2"`
	Resources            sql.NullString `json:"resources"`
	Endpoint             sql.NullString `json:"endpoint"`
	PublicEndpoint       sql.NullString `json:"public_endpoint"`
	P2pAddress           sql.NullString `json:"p2p_address"`
	CreatedAt_2          time.Time      `json:"created_at_2"`
	CreatedBy            sql.NullInt64  `json:"created_by"`
	UpdatedAt_2          sql.NullTime   `json:"updated_at_2"`
	FabricOrganizationID sql.NullInt64  `json:"fabric_organization_id"`
	NodeType             sql.NullString `json:"node_type"`
	NodeConfig           sql.NullString `json:"node_config"`
	DeploymentConfig     sql.NullString `json:"deployment_config"`
}

func (q *Queries) GetNetworkNodes(ctx context.Context, networkID int64) ([]GetNetworkNodesRow, error) {
	rows, err := q.query(ctx, q.getNetworkNodesStmt, getNetworkNodes, networkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNetworkNodesRow{}
	for rows.Next() {
		var i GetNetworkNodesRow
		if err := rows.Scan(
			&i.ID,
			&i.NetworkID,
			&i.NodeID,
			&i.Role,
			&i.Status,
			&i.Config,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Name,
			&i.Slug,
			&i.Platform,
			&i.Status_2,
			&i.Description,
			&i.NetworkID_2,
			&i.Config_2,
			&i.Resources,
			&i.Endpoint,
			&i.PublicEndpoint,
			&i.P2pAddress,
			&i.CreatedAt_2,
			&i.CreatedBy,
			&i.UpdatedAt_2,
			&i.FabricOrganizationID,
			&i.NodeType,
			&i.NodeConfig,
			&i.DeploymentConfig,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNode = `-- name: GetNode :one
SELECT id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config FROM nodes
WHERE id = ? LIMIT 1
`

func (q *Queries) GetNode(ctx context.Context, id int64) (Node, error) {
	row := q.queryRow(ctx, q.getNodeStmt, getNode, id)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.NetworkID,
		&i.Config,
		&i.Resources,
		&i.Endpoint,
		&i.PublicEndpoint,
		&i.P2pAddress,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.FabricOrganizationID,
		&i.NodeType,
		&i.NodeConfig,
		&i.DeploymentConfig,
	)
	return i, err
}

const getNodeBySlug = `-- name: GetNodeBySlug :one
SELECT id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config FROM nodes WHERE slug = ?
`

func (q *Queries) GetNodeBySlug(ctx context.Context, slug string) (Node, error) {
	row := q.queryRow(ctx, q.getNodeBySlugStmt, getNodeBySlug, slug)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.NetworkID,
		&i.Config,
		&i.Resources,
		&i.Endpoint,
		&i.PublicEndpoint,
		&i.P2pAddress,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.FabricOrganizationID,
		&i.NodeType,
		&i.NodeConfig,
		&i.DeploymentConfig,
	)
	return i, err
}

const getNodeEvent = `-- name: GetNodeEvent :one
SELECT id, node_id, event_type, description, data, status, created_at FROM node_events
WHERE id = ? LIMIT 1
`

func (q *Queries) GetNodeEvent(ctx context.Context, id int64) (NodeEvent, error) {
	row := q.queryRow(ctx, q.getNodeEventStmt, getNodeEvent, id)
	var i NodeEvent
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.EventType,
		&i.Description,
		&i.Data,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getNotificationProvider = `-- name: GetNotificationProvider :one
SELECT id, name, type, config, is_default, is_enabled, created_at, updated_at, notify_node_downtime, notify_backup_success, notify_backup_failure, notify_s3_connection_issue, last_test_at, last_test_status, last_test_message FROM notification_providers
WHERE id = ? LIMIT 1
`

func (q *Queries) GetNotificationProvider(ctx context.Context, id int64) (NotificationProvider, error) {
	row := q.queryRow(ctx, q.getNotificationProviderStmt, getNotificationProvider, id)
	var i NotificationProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Config,
		&i.IsDefault,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotifyNodeDowntime,
		&i.NotifyBackupSuccess,
		&i.NotifyBackupFailure,
		&i.NotifyS3ConnectionIssue,
		&i.LastTestAt,
		&i.LastTestStatus,
		&i.LastTestMessage,
	)
	return i, err
}

const getOldestBackupByTarget = `-- name: GetOldestBackupByTarget :one
SELECT id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent FROM backups
WHERE target_id = ?
ORDER BY created_at ASC
LIMIT 1
`

func (q *Queries) GetOldestBackupByTarget(ctx context.Context, targetID int64) (Backup, error) {
	row := q.queryRow(ctx, q.getOldestBackupByTargetStmt, getOldestBackupByTarget, targetID)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.ScheduleID,
		&i.TargetID,
		&i.Status,
		&i.SizeBytes,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.NotificationSent,
	)
	return i, err
}

const getOrdererPorts = `-- name: GetOrdererPorts :many
SELECT endpoint, public_endpoint
FROM nodes
WHERE node_type = 'fabric-orderer'
AND (endpoint IS NOT NULL OR public_endpoint IS NOT NULL)
`

type GetOrdererPortsRow struct {
	Endpoint       sql.NullString `json:"endpoint"`
	PublicEndpoint sql.NullString `json:"public_endpoint"`
}

func (q *Queries) GetOrdererPorts(ctx context.Context) ([]GetOrdererPortsRow, error) {
	rows, err := q.query(ctx, q.getOrdererPortsStmt, getOrdererPorts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrdererPortsRow{}
	for rows.Next() {
		var i GetOrdererPortsRow
		if err := rows.Scan(&i.Endpoint, &i.PublicEndpoint); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationCRLInfo = `-- name: GetOrganizationCRLInfo :one
SELECT crl_key_id, crl_last_update
FROM fabric_organizations
WHERE id = ?
`

type GetOrganizationCRLInfoRow struct {
	CrlKeyID      sql.NullInt64 `json:"crl_key_id"`
	CrlLastUpdate sql.NullTime  `json:"crl_last_update"`
}

func (q *Queries) GetOrganizationCRLInfo(ctx context.Context, id int64) (GetOrganizationCRLInfoRow, error) {
	row := q.queryRow(ctx, q.getOrganizationCRLInfoStmt, getOrganizationCRLInfo, id)
	var i GetOrganizationCRLInfoRow
	err := row.Scan(&i.CrlKeyID, &i.CrlLastUpdate)
	return i, err
}

const getPeerPorts = `-- name: GetPeerPorts :many
SELECT endpoint, public_endpoint
FROM nodes
WHERE node_type = 'fabric-peer'
AND (endpoint IS NOT NULL OR public_endpoint IS NOT NULL)
`

type GetPeerPortsRow struct {
	Endpoint       sql.NullString `json:"endpoint"`
	PublicEndpoint sql.NullString `json:"public_endpoint"`
}

func (q *Queries) GetPeerPorts(ctx context.Context) ([]GetPeerPortsRow, error) {
	rows, err := q.query(ctx, q.getPeerPortsStmt, getPeerPorts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPeerPortsRow{}
	for rows.Next() {
		var i GetPeerPortsRow
		if err := rows.Scan(&i.Endpoint, &i.PublicEndpoint); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProvidersByNotificationType = `-- name: GetProvidersByNotificationType :many
SELECT id, name, type, config, is_default, is_enabled, created_at, updated_at, notify_node_downtime, notify_backup_success, notify_backup_failure, notify_s3_connection_issue, last_test_at, last_test_status, last_test_message FROM notification_providers
WHERE (
    (? = 'NODE_DOWNTIME' AND notify_node_downtime = 1) OR
    (? = 'BACKUP_SUCCESS' AND notify_backup_success = 1) OR
    (? = 'BACKUP_FAILURE' AND notify_backup_failure = 1) OR
    (? = 'S3_CONNECTION_ISSUE' AND notify_s3_connection_issue = 1)
)
ORDER BY created_at DESC
`

type GetProvidersByNotificationTypeParams struct {
	Column1 interface{} `json:"column_1"`
	Column2 interface{} `json:"column_2"`
	Column3 interface{} `json:"column_3"`
	Column4 interface{} `json:"column_4"`
}

func (q *Queries) GetProvidersByNotificationType(ctx context.Context, arg GetProvidersByNotificationTypeParams) ([]NotificationProvider, error) {
	rows, err := q.query(ctx, q.getProvidersByNotificationTypeStmt, getProvidersByNotificationType,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NotificationProvider{}
	for rows.Next() {
		var i NotificationProvider
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Config,
			&i.IsDefault,
			&i.IsEnabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NotifyNodeDowntime,
			&i.NotifyBackupSuccess,
			&i.NotifyBackupFailure,
			&i.NotifyS3ConnectionIssue,
			&i.LastTestAt,
			&i.LastTestStatus,
			&i.LastTestMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentCompletedBackups = `-- name: GetRecentCompletedBackups :many
SELECT id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent FROM backups
WHERE (status = 'COMPLETED' OR status = 'FAILED')
  AND notification_sent = false
ORDER BY completed_at DESC
LIMIT 50
`

func (q *Queries) GetRecentCompletedBackups(ctx context.Context) ([]Backup, error) {
	rows, err := q.query(ctx, q.getRecentCompletedBackupsStmt, getRecentCompletedBackups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Backup{}
	for rows.Next() {
		var i Backup
		if err := rows.Scan(
			&i.ID,
			&i.ScheduleID,
			&i.TargetID,
			&i.Status,
			&i.SizeBytes,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.NotificationSent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevokedCertificate = `-- name: GetRevokedCertificate :one
SELECT id, fabric_organization_id, serial_number, revocation_time, reason, issuer_certificate_id, created_at, updated_at FROM fabric_revoked_certificates
WHERE fabric_organization_id = ? AND serial_number = ?
`

type GetRevokedCertificateParams struct {
	FabricOrganizationID int64  `json:"fabric_organization_id"`
	SerialNumber         string `json:"serial_number"`
}

func (q *Queries) GetRevokedCertificate(ctx context.Context, arg GetRevokedCertificateParams) (FabricRevokedCertificate, error) {
	row := q.queryRow(ctx, q.getRevokedCertificateStmt, getRevokedCertificate, arg.FabricOrganizationID, arg.SerialNumber)
	var i FabricRevokedCertificate
	err := row.Scan(
		&i.ID,
		&i.FabricOrganizationID,
		&i.SerialNumber,
		&i.RevocationTime,
		&i.Reason,
		&i.IssuerCertificateID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRevokedCertificates = `-- name: GetRevokedCertificates :many
SELECT id, fabric_organization_id, serial_number, revocation_time, reason, issuer_certificate_id, created_at, updated_at FROM fabric_revoked_certificates
WHERE fabric_organization_id = ?
ORDER BY revocation_time DESC
`

func (q *Queries) GetRevokedCertificates(ctx context.Context, fabricOrganizationID int64) ([]FabricRevokedCertificate, error) {
	rows, err := q.query(ctx, q.getRevokedCertificatesStmt, getRevokedCertificates, fabricOrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FabricRevokedCertificate{}
	for rows.Next() {
		var i FabricRevokedCertificate
		if err := rows.Scan(
			&i.ID,
			&i.FabricOrganizationID,
			&i.SerialNumber,
			&i.RevocationTime,
			&i.Reason,
			&i.IssuerCertificateID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSession = `-- name: GetSession :one
SELECT s.id, s.session_id, s.token, s.expires_at, s.created_at, u.username
FROM sessions s
JOIN users u ON s.user_id = u.id
WHERE s.session_id = ? AND s.expires_at > CURRENT_TIMESTAMP
`

type GetSessionRow struct {
	ID        int64     `json:"id"`
	SessionID string    `json:"session_id"`
	Token     string    `json:"token"`
	ExpiresAt time.Time `json:"expires_at"`
	CreatedAt time.Time `json:"created_at"`
	Username  string    `json:"username"`
}

func (q *Queries) GetSession(ctx context.Context, sessionID string) (GetSessionRow, error) {
	row := q.queryRow(ctx, q.getSessionStmt, getSession, sessionID)
	var i GetSessionRow
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.Username,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, username, password, name, email, role, provider, provider_id, avatar_url, created_at, last_login_at, updated_at FROM users
WHERE id = ? LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
	row := q.queryRow(ctx, q.getUserStmt, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Name,
		&i.Email,
		&i.Role,
		&i.Provider,
		&i.ProviderID,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.LastLoginAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, password, name, email, role, provider, provider_id, avatar_url, created_at, last_login_at, updated_at FROM users
WHERE username = ? LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.queryRow(ctx, q.getUserByUsernameStmt, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Name,
		&i.Email,
		&i.Role,
		&i.Provider,
		&i.ProviderID,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.LastLoginAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listBackupSchedules = `-- name: ListBackupSchedules :many
SELECT id, name, description, cron_expression, target_id, retention_days, enabled, created_at, updated_at, last_run_at, next_run_at FROM backup_schedules
ORDER BY created_at DESC
`

func (q *Queries) ListBackupSchedules(ctx context.Context) ([]BackupSchedule, error) {
	rows, err := q.query(ctx, q.listBackupSchedulesStmt, listBackupSchedules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BackupSchedule{}
	for rows.Next() {
		var i BackupSchedule
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CronExpression,
			&i.TargetID,
			&i.RetentionDays,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastRunAt,
			&i.NextRunAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBackupTargets = `-- name: ListBackupTargets :many
SELECT id, name, bucket_name, region, endpoint, bucket_path, access_key_id, secret_key, s3_path_style, restic_password, type, created_at, updated_at FROM backup_targets
ORDER BY created_at DESC
`

func (q *Queries) ListBackupTargets(ctx context.Context) ([]BackupTarget, error) {
	rows, err := q.query(ctx, q.listBackupTargetsStmt, listBackupTargets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BackupTarget{}
	for rows.Next() {
		var i BackupTarget
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BucketName,
			&i.Region,
			&i.Endpoint,
			&i.BucketPath,
			&i.AccessKeyID,
			&i.SecretKey,
			&i.S3PathStyle,
			&i.ResticPassword,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBackups = `-- name: ListBackups :many
SELECT id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent FROM backups
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListBackupsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListBackups(ctx context.Context, arg ListBackupsParams) ([]Backup, error) {
	rows, err := q.query(ctx, q.listBackupsStmt, listBackups, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Backup{}
	for rows.Next() {
		var i Backup
		if err := rows.Scan(
			&i.ID,
			&i.ScheduleID,
			&i.TargetID,
			&i.Status,
			&i.SizeBytes,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.NotificationSent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBackupsBySchedule = `-- name: ListBackupsBySchedule :many
SELECT id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent FROM backups
WHERE schedule_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListBackupsBySchedule(ctx context.Context, scheduleID sql.NullInt64) ([]Backup, error) {
	rows, err := q.query(ctx, q.listBackupsByScheduleStmt, listBackupsBySchedule, scheduleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Backup{}
	for rows.Next() {
		var i Backup
		if err := rows.Scan(
			&i.ID,
			&i.ScheduleID,
			&i.TargetID,
			&i.Status,
			&i.SizeBytes,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.NotificationSent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBackupsByTarget = `-- name: ListBackupsByTarget :many
SELECT id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent FROM backups
WHERE target_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListBackupsByTarget(ctx context.Context, targetID int64) ([]Backup, error) {
	rows, err := q.query(ctx, q.listBackupsByTargetStmt, listBackupsByTarget, targetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Backup{}
	for rows.Next() {
		var i Backup
		if err := rows.Scan(
			&i.ID,
			&i.ScheduleID,
			&i.TargetID,
			&i.Status,
			&i.SizeBytes,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.NotificationSent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFabricOrganizations = `-- name: ListFabricOrganizations :many
SELECT id, msp_id, description, config, ca_config, sign_key_id, tls_root_key_id, admin_tls_key_id, admin_sign_key_id, client_sign_key_id, provider_id, created_at, created_by, updated_at, crl_key_id, crl_last_update FROM fabric_organizations
ORDER BY created_at DESC
`

func (q *Queries) ListFabricOrganizations(ctx context.Context) ([]FabricOrganization, error) {
	rows, err := q.query(ctx, q.listFabricOrganizationsStmt, listFabricOrganizations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FabricOrganization{}
	for rows.Next() {
		var i FabricOrganization
		if err := rows.Scan(
			&i.ID,
			&i.MspID,
			&i.Description,
			&i.Config,
			&i.CaConfig,
			&i.SignKeyID,
			&i.TlsRootKeyID,
			&i.AdminTlsKeyID,
			&i.AdminSignKeyID,
			&i.ClientSignKeyID,
			&i.ProviderID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.CrlKeyID,
			&i.CrlLastUpdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFabricOrganizationsWithKeys = `-- name: ListFabricOrganizationsWithKeys :many
SELECT 
    fo.id, fo.msp_id, fo.description, fo.config, fo.ca_config, fo.sign_key_id, fo.tls_root_key_id, fo.admin_tls_key_id, fo.admin_sign_key_id, fo.client_sign_key_id, fo.provider_id, fo.created_at, fo.created_by, fo.updated_at, fo.crl_key_id, fo.crl_last_update,
    sk.public_key as sign_public_key,
    sk.certificate as sign_certificate,
    tk.public_key as tls_public_key,
    tk.certificate as tls_certificate,
    p.name as provider_name
FROM fabric_organizations fo
LEFT JOIN keys sk ON fo.sign_key_id = sk.id
LEFT JOIN keys tk ON fo.tls_root_key_id = tk.id
LEFT JOIN key_providers p ON fo.provider_id = p.id
ORDER BY fo.created_at DESC
`

type ListFabricOrganizationsWithKeysRow struct {
	ID              int64          `json:"id"`
	MspID           string         `json:"msp_id"`
	Description     sql.NullString `json:"description"`
	Config          sql.NullString `json:"config"`
	CaConfig        sql.NullString `json:"ca_config"`
	SignKeyID       sql.NullInt64  `json:"sign_key_id"`
	TlsRootKeyID    sql.NullInt64  `json:"tls_root_key_id"`
	AdminTlsKeyID   sql.NullInt64  `json:"admin_tls_key_id"`
	AdminSignKeyID  sql.NullInt64  `json:"admin_sign_key_id"`
	ClientSignKeyID sql.NullInt64  `json:"client_sign_key_id"`
	ProviderID      sql.NullInt64  `json:"provider_id"`
	CreatedAt       time.Time      `json:"created_at"`
	CreatedBy       sql.NullInt64  `json:"created_by"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
	CrlKeyID        sql.NullInt64  `json:"crl_key_id"`
	CrlLastUpdate   sql.NullTime   `json:"crl_last_update"`
	SignPublicKey   sql.NullString `json:"sign_public_key"`
	SignCertificate sql.NullString `json:"sign_certificate"`
	TlsPublicKey    sql.NullString `json:"tls_public_key"`
	TlsCertificate  sql.NullString `json:"tls_certificate"`
	ProviderName    sql.NullString `json:"provider_name"`
}

func (q *Queries) ListFabricOrganizationsWithKeys(ctx context.Context) ([]ListFabricOrganizationsWithKeysRow, error) {
	rows, err := q.query(ctx, q.listFabricOrganizationsWithKeysStmt, listFabricOrganizationsWithKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFabricOrganizationsWithKeysRow{}
	for rows.Next() {
		var i ListFabricOrganizationsWithKeysRow
		if err := rows.Scan(
			&i.ID,
			&i.MspID,
			&i.Description,
			&i.Config,
			&i.CaConfig,
			&i.SignKeyID,
			&i.TlsRootKeyID,
			&i.AdminTlsKeyID,
			&i.AdminSignKeyID,
			&i.ClientSignKeyID,
			&i.ProviderID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.CrlKeyID,
			&i.CrlLastUpdate,
			&i.SignPublicKey,
			&i.SignCertificate,
			&i.TlsPublicKey,
			&i.TlsCertificate,
			&i.ProviderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listKeyProviders = `-- name: ListKeyProviders :many
SELECT id, name, type, is_default, config, created_at, updated_at FROM key_providers
`

func (q *Queries) ListKeyProviders(ctx context.Context) ([]KeyProvider, error) {
	rows, err := q.query(ctx, q.listKeyProvidersStmt, listKeyProviders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []KeyProvider{}
	for rows.Next() {
		var i KeyProvider
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.IsDefault,
			&i.Config,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listKeys = `-- name: ListKeys :many
SELECT k.id, k.name, k.description, k.algorithm, k.key_size, k.curve, k.format, k.public_key, k.private_key, k.certificate, k.status, k.created_at, k.updated_at, k.expires_at, k.last_rotated_at, k.signing_key_id, k.sha256_fingerprint, k.sha1_fingerprint, k.provider_id, k.user_id, k.is_ca, k.ethereum_address, kp.name as provider_name, kp.type as provider_type
FROM keys k
JOIN key_providers kp ON k.provider_id = kp.id
ORDER BY k.created_at DESC
LIMIT ? OFFSET ?
`

type ListKeysParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListKeysRow struct {
	ID                int64          `json:"id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Algorithm         string         `json:"algorithm"`
	KeySize           sql.NullInt64  `json:"key_size"`
	Curve             sql.NullString `json:"curve"`
	Format            string         `json:"format"`
	PublicKey         string         `json:"public_key"`
	PrivateKey        string         `json:"private_key"`
	Certificate       sql.NullString `json:"certificate"`
	Status            string         `json:"status"`
	CreatedAt         time.Time      `json:"created_at"`
	UpdatedAt         time.Time      `json:"updated_at"`
	ExpiresAt         sql.NullTime   `json:"expires_at"`
	LastRotatedAt     sql.NullTime   `json:"last_rotated_at"`
	SigningKeyID      sql.NullInt64  `json:"signing_key_id"`
	Sha256Fingerprint string         `json:"sha256_fingerprint"`
	Sha1Fingerprint   string         `json:"sha1_fingerprint"`
	ProviderID        int64          `json:"provider_id"`
	UserID            int64          `json:"user_id"`
	IsCa              int64          `json:"is_ca"`
	EthereumAddress   sql.NullString `json:"ethereum_address"`
	ProviderName      string         `json:"provider_name"`
	ProviderType      string         `json:"provider_type"`
}

func (q *Queries) ListKeys(ctx context.Context, arg ListKeysParams) ([]ListKeysRow, error) {
	rows, err := q.query(ctx, q.listKeysStmt, listKeys, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListKeysRow{}
	for rows.Next() {
		var i ListKeysRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Algorithm,
			&i.KeySize,
			&i.Curve,
			&i.Format,
			&i.PublicKey,
			&i.PrivateKey,
			&i.Certificate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
			&i.LastRotatedAt,
			&i.SigningKeyID,
			&i.Sha256Fingerprint,
			&i.Sha1Fingerprint,
			&i.ProviderID,
			&i.UserID,
			&i.IsCa,
			&i.EthereumAddress,
			&i.ProviderName,
			&i.ProviderType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNetworkNodesByNetwork = `-- name: ListNetworkNodesByNetwork :many
SELECT id, network_id, node_id, role, status, config, created_at, updated_at FROM network_nodes
WHERE network_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListNetworkNodesByNetwork(ctx context.Context, networkID int64) ([]NetworkNode, error) {
	rows, err := q.query(ctx, q.listNetworkNodesByNetworkStmt, listNetworkNodesByNetwork, networkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NetworkNode{}
	for rows.Next() {
		var i NetworkNode
		if err := rows.Scan(
			&i.ID,
			&i.NetworkID,
			&i.NodeID,
			&i.Role,
			&i.Status,
			&i.Config,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNetworkNodesByNode = `-- name: ListNetworkNodesByNode :many
SELECT id, network_id, node_id, role, status, config, created_at, updated_at FROM network_nodes
WHERE node_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListNetworkNodesByNode(ctx context.Context, nodeID int64) ([]NetworkNode, error) {
	rows, err := q.query(ctx, q.listNetworkNodesByNodeStmt, listNetworkNodesByNode, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NetworkNode{}
	for rows.Next() {
		var i NetworkNode
		if err := rows.Scan(
			&i.ID,
			&i.NetworkID,
			&i.NodeID,
			&i.Role,
			&i.Status,
			&i.Config,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNetworks = `-- name: ListNetworks :many
SELECT id, name, network_id, platform, status, description, config, deployment_config, exposed_ports, domain, created_at, created_by, updated_at, genesis_block_b64, current_config_block_b64 FROM networks
ORDER BY created_at DESC
`

func (q *Queries) ListNetworks(ctx context.Context) ([]Network, error) {
	rows, err := q.query(ctx, q.listNetworksStmt, listNetworks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Network{}
	for rows.Next() {
		var i Network
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.NetworkID,
			&i.Platform,
			&i.Status,
			&i.Description,
			&i.Config,
			&i.DeploymentConfig,
			&i.ExposedPorts,
			&i.Domain,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.GenesisBlockB64,
			&i.CurrentConfigBlockB64,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodeEvents = `-- name: ListNodeEvents :many
SELECT id, node_id, event_type, description, data, status, created_at FROM node_events
WHERE node_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListNodeEventsParams struct {
	NodeID int64 `json:"node_id"`
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListNodeEvents(ctx context.Context, arg ListNodeEventsParams) ([]NodeEvent, error) {
	rows, err := q.query(ctx, q.listNodeEventsStmt, listNodeEvents, arg.NodeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NodeEvent{}
	for rows.Next() {
		var i NodeEvent
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.EventType,
			&i.Description,
			&i.Data,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodeEventsByType = `-- name: ListNodeEventsByType :many
SELECT id, node_id, event_type, description, data, status, created_at FROM node_events
WHERE node_id = ? AND event_type = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListNodeEventsByTypeParams struct {
	NodeID    int64  `json:"node_id"`
	EventType string `json:"event_type"`
	Limit     int64  `json:"limit"`
	Offset    int64  `json:"offset"`
}

func (q *Queries) ListNodeEventsByType(ctx context.Context, arg ListNodeEventsByTypeParams) ([]NodeEvent, error) {
	rows, err := q.query(ctx, q.listNodeEventsByTypeStmt, listNodeEventsByType,
		arg.NodeID,
		arg.EventType,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NodeEvent{}
	for rows.Next() {
		var i NodeEvent
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.EventType,
			&i.Description,
			&i.Data,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodes = `-- name: ListNodes :many
SELECT id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config FROM nodes
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListNodesParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListNodes(ctx context.Context, arg ListNodesParams) ([]Node, error) {
	rows, err := q.query(ctx, q.listNodesStmt, listNodes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Platform,
			&i.Status,
			&i.Description,
			&i.NetworkID,
			&i.Config,
			&i.Resources,
			&i.Endpoint,
			&i.PublicEndpoint,
			&i.P2pAddress,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.FabricOrganizationID,
			&i.NodeType,
			&i.NodeConfig,
			&i.DeploymentConfig,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodesByNetwork = `-- name: ListNodesByNetwork :many
SELECT id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config FROM nodes
WHERE network_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListNodesByNetworkParams struct {
	NetworkID sql.NullInt64 `json:"network_id"`
	Limit     int64         `json:"limit"`
	Offset    int64         `json:"offset"`
}

func (q *Queries) ListNodesByNetwork(ctx context.Context, arg ListNodesByNetworkParams) ([]Node, error) {
	rows, err := q.query(ctx, q.listNodesByNetworkStmt, listNodesByNetwork, arg.NetworkID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Platform,
			&i.Status,
			&i.Description,
			&i.NetworkID,
			&i.Config,
			&i.Resources,
			&i.Endpoint,
			&i.PublicEndpoint,
			&i.P2pAddress,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.FabricOrganizationID,
			&i.NodeType,
			&i.NodeConfig,
			&i.DeploymentConfig,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodesByPlatform = `-- name: ListNodesByPlatform :many
SELECT id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config FROM nodes
WHERE platform = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListNodesByPlatformParams struct {
	Platform string `json:"platform"`
	Limit    int64  `json:"limit"`
	Offset   int64  `json:"offset"`
}

func (q *Queries) ListNodesByPlatform(ctx context.Context, arg ListNodesByPlatformParams) ([]Node, error) {
	rows, err := q.query(ctx, q.listNodesByPlatformStmt, listNodesByPlatform, arg.Platform, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Platform,
			&i.Status,
			&i.Description,
			&i.NetworkID,
			&i.Config,
			&i.Resources,
			&i.Endpoint,
			&i.PublicEndpoint,
			&i.P2pAddress,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.FabricOrganizationID,
			&i.NodeType,
			&i.NodeConfig,
			&i.DeploymentConfig,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotificationProviders = `-- name: ListNotificationProviders :many
SELECT id, name, type, config, is_default, is_enabled, created_at, updated_at, notify_node_downtime, notify_backup_success, notify_backup_failure, notify_s3_connection_issue, last_test_at, last_test_status, last_test_message FROM notification_providers
ORDER BY created_at DESC
`

func (q *Queries) ListNotificationProviders(ctx context.Context) ([]NotificationProvider, error) {
	rows, err := q.query(ctx, q.listNotificationProvidersStmt, listNotificationProviders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NotificationProvider{}
	for rows.Next() {
		var i NotificationProvider
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.Config,
			&i.IsDefault,
			&i.IsEnabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NotifyNodeDowntime,
			&i.NotifyBackupSuccess,
			&i.NotifyBackupFailure,
			&i.NotifyS3ConnectionIssue,
			&i.LastTestAt,
			&i.LastTestStatus,
			&i.LastTestMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, username, password, name, email, role, provider, provider_id, avatar_url, created_at, last_login_at, updated_at FROM users
ORDER BY created_at DESC
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.query(ctx, q.listUsersStmt, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Password,
			&i.Name,
			&i.Email,
			&i.Role,
			&i.Provider,
			&i.ProviderID,
			&i.AvatarUrl,
			&i.CreatedAt,
			&i.LastLoginAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markBackupNotified = `-- name: MarkBackupNotified :exec
UPDATE backups
SET notification_sent = true
WHERE id = ?
`

func (q *Queries) MarkBackupNotified(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.markBackupNotifiedStmt, markBackupNotified, id)
	return err
}

const unsetDefaultNotificationProvider = `-- name: UnsetDefaultNotificationProvider :exec
UPDATE notification_providers
SET is_default = 0,
    updated_at = CURRENT_TIMESTAMP
WHERE type = ? AND is_default = 1
`

func (q *Queries) UnsetDefaultNotificationProvider(ctx context.Context, type_ string) error {
	_, err := q.exec(ctx, q.unsetDefaultNotificationProviderStmt, unsetDefaultNotificationProvider, type_)
	return err
}

const unsetDefaultProvider = `-- name: UnsetDefaultProvider :exec
UPDATE key_providers SET is_default = 0 WHERE is_default = 1
`

func (q *Queries) UnsetDefaultProvider(ctx context.Context) error {
	_, err := q.exec(ctx, q.unsetDefaultProviderStmt, unsetDefaultProvider)
	return err
}

const updateBackupCompleted = `-- name: UpdateBackupCompleted :one
UPDATE backups
SET status = ?,
    completed_at = ?
WHERE id = ?
RETURNING id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent
`

type UpdateBackupCompletedParams struct {
	Status      string       `json:"status"`
	CompletedAt sql.NullTime `json:"completed_at"`
	ID          int64        `json:"id"`
}

func (q *Queries) UpdateBackupCompleted(ctx context.Context, arg UpdateBackupCompletedParams) (Backup, error) {
	row := q.queryRow(ctx, q.updateBackupCompletedStmt, updateBackupCompleted, arg.Status, arg.CompletedAt, arg.ID)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.ScheduleID,
		&i.TargetID,
		&i.Status,
		&i.SizeBytes,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.NotificationSent,
	)
	return i, err
}

const updateBackupFailed = `-- name: UpdateBackupFailed :one
UPDATE backups
SET status = ?,
    error_message = ?,
    completed_at = ?
WHERE id = ?
RETURNING id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent
`

type UpdateBackupFailedParams struct {
	Status       string         `json:"status"`
	ErrorMessage sql.NullString `json:"error_message"`
	CompletedAt  sql.NullTime   `json:"completed_at"`
	ID           int64          `json:"id"`
}

func (q *Queries) UpdateBackupFailed(ctx context.Context, arg UpdateBackupFailedParams) (Backup, error) {
	row := q.queryRow(ctx, q.updateBackupFailedStmt, updateBackupFailed,
		arg.Status,
		arg.ErrorMessage,
		arg.CompletedAt,
		arg.ID,
	)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.ScheduleID,
		&i.TargetID,
		&i.Status,
		&i.SizeBytes,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.NotificationSent,
	)
	return i, err
}

const updateBackupSchedule = `-- name: UpdateBackupSchedule :one
UPDATE backup_schedules
SET name = ?,
    description = ?,
    cron_expression = ?,
    target_id = ?,
    retention_days = ?,
    enabled = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, description, cron_expression, target_id, retention_days, enabled, created_at, updated_at, last_run_at, next_run_at
`

type UpdateBackupScheduleParams struct {
	Name           string         `json:"name"`
	Description    sql.NullString `json:"description"`
	CronExpression string         `json:"cron_expression"`
	TargetID       int64          `json:"target_id"`
	RetentionDays  int64          `json:"retention_days"`
	Enabled        bool           `json:"enabled"`
	ID             int64          `json:"id"`
}

func (q *Queries) UpdateBackupSchedule(ctx context.Context, arg UpdateBackupScheduleParams) (BackupSchedule, error) {
	row := q.queryRow(ctx, q.updateBackupScheduleStmt, updateBackupSchedule,
		arg.Name,
		arg.Description,
		arg.CronExpression,
		arg.TargetID,
		arg.RetentionDays,
		arg.Enabled,
		arg.ID,
	)
	var i BackupSchedule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CronExpression,
		&i.TargetID,
		&i.RetentionDays,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastRunAt,
		&i.NextRunAt,
	)
	return i, err
}

const updateBackupScheduleLastRun = `-- name: UpdateBackupScheduleLastRun :one
UPDATE backup_schedules
SET last_run_at = ?,
    next_run_at = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, description, cron_expression, target_id, retention_days, enabled, created_at, updated_at, last_run_at, next_run_at
`

type UpdateBackupScheduleLastRunParams struct {
	LastRunAt sql.NullTime `json:"last_run_at"`
	NextRunAt sql.NullTime `json:"next_run_at"`
	ID        int64        `json:"id"`
}

func (q *Queries) UpdateBackupScheduleLastRun(ctx context.Context, arg UpdateBackupScheduleLastRunParams) (BackupSchedule, error) {
	row := q.queryRow(ctx, q.updateBackupScheduleLastRunStmt, updateBackupScheduleLastRun, arg.LastRunAt, arg.NextRunAt, arg.ID)
	var i BackupSchedule
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CronExpression,
		&i.TargetID,
		&i.RetentionDays,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastRunAt,
		&i.NextRunAt,
	)
	return i, err
}

const updateBackupSize = `-- name: UpdateBackupSize :one
UPDATE backups
SET size_bytes = ?
WHERE id = ?
RETURNING id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent
`

type UpdateBackupSizeParams struct {
	SizeBytes sql.NullInt64 `json:"size_bytes"`
	ID        int64         `json:"id"`
}

func (q *Queries) UpdateBackupSize(ctx context.Context, arg UpdateBackupSizeParams) (Backup, error) {
	row := q.queryRow(ctx, q.updateBackupSizeStmt, updateBackupSize, arg.SizeBytes, arg.ID)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.ScheduleID,
		&i.TargetID,
		&i.Status,
		&i.SizeBytes,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.NotificationSent,
	)
	return i, err
}

const updateBackupStatus = `-- name: UpdateBackupStatus :one
UPDATE backups
SET status = ?
WHERE id = ?
RETURNING id, schedule_id, target_id, status, size_bytes, started_at, completed_at, error_message, created_at, notification_sent
`

type UpdateBackupStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateBackupStatus(ctx context.Context, arg UpdateBackupStatusParams) (Backup, error) {
	row := q.queryRow(ctx, q.updateBackupStatusStmt, updateBackupStatus, arg.Status, arg.ID)
	var i Backup
	err := row.Scan(
		&i.ID,
		&i.ScheduleID,
		&i.TargetID,
		&i.Status,
		&i.SizeBytes,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.NotificationSent,
	)
	return i, err
}

const updateBackupTarget = `-- name: UpdateBackupTarget :one
UPDATE backup_targets
SET name = ?,
    type = ?,
    bucket_name = ?,
    region = ?,
    endpoint = ?,
    bucket_path = ?,
    access_key_id = ?,
    secret_key = ?,
    s3_path_style = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, bucket_name, region, endpoint, bucket_path, access_key_id, secret_key, s3_path_style, restic_password, type, created_at, updated_at
`

type UpdateBackupTargetParams struct {
	Name        string         `json:"name"`
	Type        string         `json:"type"`
	BucketName  sql.NullString `json:"bucket_name"`
	Region      sql.NullString `json:"region"`
	Endpoint    sql.NullString `json:"endpoint"`
	BucketPath  sql.NullString `json:"bucket_path"`
	AccessKeyID sql.NullString `json:"access_key_id"`
	SecretKey   sql.NullString `json:"secret_key"`
	S3PathStyle sql.NullBool   `json:"s3_path_style"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdateBackupTarget(ctx context.Context, arg UpdateBackupTargetParams) (BackupTarget, error) {
	row := q.queryRow(ctx, q.updateBackupTargetStmt, updateBackupTarget,
		arg.Name,
		arg.Type,
		arg.BucketName,
		arg.Region,
		arg.Endpoint,
		arg.BucketPath,
		arg.AccessKeyID,
		arg.SecretKey,
		arg.S3PathStyle,
		arg.ID,
	)
	var i BackupTarget
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BucketName,
		&i.Region,
		&i.Endpoint,
		&i.BucketPath,
		&i.AccessKeyID,
		&i.SecretKey,
		&i.S3PathStyle,
		&i.ResticPassword,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateDeploymentConfig = `-- name: UpdateDeploymentConfig :one
UPDATE nodes
SET deployment_config = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config
`

type UpdateDeploymentConfigParams struct {
	DeploymentConfig sql.NullString `json:"deployment_config"`
	ID               int64          `json:"id"`
}

func (q *Queries) UpdateDeploymentConfig(ctx context.Context, arg UpdateDeploymentConfigParams) (Node, error) {
	row := q.queryRow(ctx, q.updateDeploymentConfigStmt, updateDeploymentConfig, arg.DeploymentConfig, arg.ID)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.NetworkID,
		&i.Config,
		&i.Resources,
		&i.Endpoint,
		&i.PublicEndpoint,
		&i.P2pAddress,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.FabricOrganizationID,
		&i.NodeType,
		&i.NodeConfig,
		&i.DeploymentConfig,
	)
	return i, err
}

const updateFabricOrganization = `-- name: UpdateFabricOrganization :one
UPDATE fabric_organizations
SET description = ?
WHERE id = ?
RETURNING id, msp_id, description, config, ca_config, sign_key_id, tls_root_key_id, admin_tls_key_id, admin_sign_key_id, client_sign_key_id, provider_id, created_at, created_by, updated_at, crl_key_id, crl_last_update
`

type UpdateFabricOrganizationParams struct {
	Description sql.NullString `json:"description"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdateFabricOrganization(ctx context.Context, arg UpdateFabricOrganizationParams) (FabricOrganization, error) {
	row := q.queryRow(ctx, q.updateFabricOrganizationStmt, updateFabricOrganization, arg.Description, arg.ID)
	var i FabricOrganization
	err := row.Scan(
		&i.ID,
		&i.MspID,
		&i.Description,
		&i.Config,
		&i.CaConfig,
		&i.SignKeyID,
		&i.TlsRootKeyID,
		&i.AdminTlsKeyID,
		&i.AdminSignKeyID,
		&i.ClientSignKeyID,
		&i.ProviderID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.CrlKeyID,
		&i.CrlLastUpdate,
	)
	return i, err
}

const updateKey = `-- name: UpdateKey :one
UPDATE keys
SET name = ?,
    description = ?,
    algorithm = ?,
    key_size = ?,
    curve = ?,
    format = ?,
    public_key = ?,
    private_key = ?,
    certificate = ?,
    status = ?,
    expires_at = ?,
    sha256_fingerprint = ?,
    sha1_fingerprint = ?,
    provider_id = ?,
    user_id = ?,
    ethereum_address = ?,
    updated_at = CURRENT_TIMESTAMP,
    signing_key_id = ?
WHERE id = ?
RETURNING id, name, description, algorithm, key_size, curve, format, public_key, private_key, certificate, status, created_at, updated_at, expires_at, last_rotated_at, signing_key_id, sha256_fingerprint, sha1_fingerprint, provider_id, user_id, is_ca, ethereum_address
`

type UpdateKeyParams struct {
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Algorithm         string         `json:"algorithm"`
	KeySize           sql.NullInt64  `json:"key_size"`
	Curve             sql.NullString `json:"curve"`
	Format            string         `json:"format"`
	PublicKey         string         `json:"public_key"`
	PrivateKey        string         `json:"private_key"`
	Certificate       sql.NullString `json:"certificate"`
	Status            string         `json:"status"`
	ExpiresAt         sql.NullTime   `json:"expires_at"`
	Sha256Fingerprint string         `json:"sha256_fingerprint"`
	Sha1Fingerprint   string         `json:"sha1_fingerprint"`
	ProviderID        int64          `json:"provider_id"`
	UserID            int64          `json:"user_id"`
	EthereumAddress   sql.NullString `json:"ethereum_address"`
	SigningKeyID      sql.NullInt64  `json:"signing_key_id"`
	ID                int64          `json:"id"`
}

func (q *Queries) UpdateKey(ctx context.Context, arg UpdateKeyParams) (Key, error) {
	row := q.queryRow(ctx, q.updateKeyStmt, updateKey,
		arg.Name,
		arg.Description,
		arg.Algorithm,
		arg.KeySize,
		arg.Curve,
		arg.Format,
		arg.PublicKey,
		arg.PrivateKey,
		arg.Certificate,
		arg.Status,
		arg.ExpiresAt,
		arg.Sha256Fingerprint,
		arg.Sha1Fingerprint,
		arg.ProviderID,
		arg.UserID,
		arg.EthereumAddress,
		arg.SigningKeyID,
		arg.ID,
	)
	var i Key
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Algorithm,
		&i.KeySize,
		&i.Curve,
		&i.Format,
		&i.PublicKey,
		&i.PrivateKey,
		&i.Certificate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.LastRotatedAt,
		&i.SigningKeyID,
		&i.Sha256Fingerprint,
		&i.Sha1Fingerprint,
		&i.ProviderID,
		&i.UserID,
		&i.IsCa,
		&i.EthereumAddress,
	)
	return i, err
}

const updateKeyProvider = `-- name: UpdateKeyProvider :one
UPDATE key_providers
SET name = ?,
    type = ?,
    is_default = ?,
    config = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, type, is_default, config, created_at, updated_at
`

type UpdateKeyProviderParams struct {
	Name      string `json:"name"`
	Type      string `json:"type"`
	IsDefault int64  `json:"is_default"`
	Config    string `json:"config"`
	ID        int64  `json:"id"`
}

func (q *Queries) UpdateKeyProvider(ctx context.Context, arg UpdateKeyProviderParams) (KeyProvider, error) {
	row := q.queryRow(ctx, q.updateKeyProviderStmt, updateKeyProvider,
		arg.Name,
		arg.Type,
		arg.IsDefault,
		arg.Config,
		arg.ID,
	)
	var i KeyProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.IsDefault,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateNetworkCurrentConfigBlock = `-- name: UpdateNetworkCurrentConfigBlock :exec
UPDATE networks
SET current_config_block_b64 = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateNetworkCurrentConfigBlockParams struct {
	CurrentConfigBlockB64 sql.NullString `json:"current_config_block_b64"`
	ID                    int64          `json:"id"`
}

func (q *Queries) UpdateNetworkCurrentConfigBlock(ctx context.Context, arg UpdateNetworkCurrentConfigBlockParams) error {
	_, err := q.exec(ctx, q.updateNetworkCurrentConfigBlockStmt, updateNetworkCurrentConfigBlock, arg.CurrentConfigBlockB64, arg.ID)
	return err
}

const updateNetworkGenesisBlock = `-- name: UpdateNetworkGenesisBlock :one
UPDATE networks
SET genesis_block_b64 = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, network_id, platform, status, description, config, deployment_config, exposed_ports, domain, created_at, created_by, updated_at, genesis_block_b64, current_config_block_b64
`

type UpdateNetworkGenesisBlockParams struct {
	GenesisBlockB64 sql.NullString `json:"genesis_block_b64"`
	ID              int64          `json:"id"`
}

func (q *Queries) UpdateNetworkGenesisBlock(ctx context.Context, arg UpdateNetworkGenesisBlockParams) (Network, error) {
	row := q.queryRow(ctx, q.updateNetworkGenesisBlockStmt, updateNetworkGenesisBlock, arg.GenesisBlockB64, arg.ID)
	var i Network
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NetworkID,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.Config,
		&i.DeploymentConfig,
		&i.ExposedPorts,
		&i.Domain,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.GenesisBlockB64,
		&i.CurrentConfigBlockB64,
	)
	return i, err
}

const updateNetworkNodeRole = `-- name: UpdateNetworkNodeRole :one
UPDATE network_nodes
SET role = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE network_id = ? AND node_id = ?
RETURNING id, network_id, node_id, role, status, config, created_at, updated_at
`

type UpdateNetworkNodeRoleParams struct {
	Role      string `json:"role"`
	NetworkID int64  `json:"network_id"`
	NodeID    int64  `json:"node_id"`
}

func (q *Queries) UpdateNetworkNodeRole(ctx context.Context, arg UpdateNetworkNodeRoleParams) (NetworkNode, error) {
	row := q.queryRow(ctx, q.updateNetworkNodeRoleStmt, updateNetworkNodeRole, arg.Role, arg.NetworkID, arg.NodeID)
	var i NetworkNode
	err := row.Scan(
		&i.ID,
		&i.NetworkID,
		&i.NodeID,
		&i.Role,
		&i.Status,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateNetworkNodeStatus = `-- name: UpdateNetworkNodeStatus :one
UPDATE network_nodes
SET status = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE network_id = ? AND node_id = ?
RETURNING id, network_id, node_id, role, status, config, created_at, updated_at
`

type UpdateNetworkNodeStatusParams struct {
	Status    string `json:"status"`
	NetworkID int64  `json:"network_id"`
	NodeID    int64  `json:"node_id"`
}

func (q *Queries) UpdateNetworkNodeStatus(ctx context.Context, arg UpdateNetworkNodeStatusParams) (NetworkNode, error) {
	row := q.queryRow(ctx, q.updateNetworkNodeStatusStmt, updateNetworkNodeStatus, arg.Status, arg.NetworkID, arg.NodeID)
	var i NetworkNode
	err := row.Scan(
		&i.ID,
		&i.NetworkID,
		&i.NodeID,
		&i.Role,
		&i.Status,
		&i.Config,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateNetworkStatus = `-- name: UpdateNetworkStatus :exec
UPDATE networks
SET status = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateNetworkStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateNetworkStatus(ctx context.Context, arg UpdateNetworkStatusParams) error {
	_, err := q.exec(ctx, q.updateNetworkStatusStmt, updateNetworkStatus, arg.Status, arg.ID)
	return err
}

const updateNodeConfig = `-- name: UpdateNodeConfig :one
UPDATE nodes
SET node_config = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config
`

type UpdateNodeConfigParams struct {
	NodeConfig sql.NullString `json:"node_config"`
	ID         int64          `json:"id"`
}

func (q *Queries) UpdateNodeConfig(ctx context.Context, arg UpdateNodeConfigParams) (Node, error) {
	row := q.queryRow(ctx, q.updateNodeConfigStmt, updateNodeConfig, arg.NodeConfig, arg.ID)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.NetworkID,
		&i.Config,
		&i.Resources,
		&i.Endpoint,
		&i.PublicEndpoint,
		&i.P2pAddress,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.FabricOrganizationID,
		&i.NodeType,
		&i.NodeConfig,
		&i.DeploymentConfig,
	)
	return i, err
}

const updateNodeDeploymentConfig = `-- name: UpdateNodeDeploymentConfig :one
UPDATE nodes
SET deployment_config = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config
`

type UpdateNodeDeploymentConfigParams struct {
	DeploymentConfig sql.NullString `json:"deployment_config"`
	ID               int64          `json:"id"`
}

func (q *Queries) UpdateNodeDeploymentConfig(ctx context.Context, arg UpdateNodeDeploymentConfigParams) (Node, error) {
	row := q.queryRow(ctx, q.updateNodeDeploymentConfigStmt, updateNodeDeploymentConfig, arg.DeploymentConfig, arg.ID)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.NetworkID,
		&i.Config,
		&i.Resources,
		&i.Endpoint,
		&i.PublicEndpoint,
		&i.P2pAddress,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.FabricOrganizationID,
		&i.NodeType,
		&i.NodeConfig,
		&i.DeploymentConfig,
	)
	return i, err
}

const updateNodeEndpoint = `-- name: UpdateNodeEndpoint :one
UPDATE nodes
SET endpoint = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config
`

type UpdateNodeEndpointParams struct {
	Endpoint sql.NullString `json:"endpoint"`
	ID       int64          `json:"id"`
}

func (q *Queries) UpdateNodeEndpoint(ctx context.Context, arg UpdateNodeEndpointParams) (Node, error) {
	row := q.queryRow(ctx, q.updateNodeEndpointStmt, updateNodeEndpoint, arg.Endpoint, arg.ID)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.NetworkID,
		&i.Config,
		&i.Resources,
		&i.Endpoint,
		&i.PublicEndpoint,
		&i.P2pAddress,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.FabricOrganizationID,
		&i.NodeType,
		&i.NodeConfig,
		&i.DeploymentConfig,
	)
	return i, err
}

const updateNodePublicEndpoint = `-- name: UpdateNodePublicEndpoint :one
UPDATE nodes
SET public_endpoint = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config
`

type UpdateNodePublicEndpointParams struct {
	PublicEndpoint sql.NullString `json:"public_endpoint"`
	ID             int64          `json:"id"`
}

func (q *Queries) UpdateNodePublicEndpoint(ctx context.Context, arg UpdateNodePublicEndpointParams) (Node, error) {
	row := q.queryRow(ctx, q.updateNodePublicEndpointStmt, updateNodePublicEndpoint, arg.PublicEndpoint, arg.ID)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.NetworkID,
		&i.Config,
		&i.Resources,
		&i.Endpoint,
		&i.PublicEndpoint,
		&i.P2pAddress,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.FabricOrganizationID,
		&i.NodeType,
		&i.NodeConfig,
		&i.DeploymentConfig,
	)
	return i, err
}

const updateNodeStatus = `-- name: UpdateNodeStatus :one
UPDATE nodes
SET status = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, slug, platform, status, description, network_id, config, resources, endpoint, public_endpoint, p2p_address, created_at, created_by, updated_at, fabric_organization_id, node_type, node_config, deployment_config
`

type UpdateNodeStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateNodeStatus(ctx context.Context, arg UpdateNodeStatusParams) (Node, error) {
	row := q.queryRow(ctx, q.updateNodeStatusStmt, updateNodeStatus, arg.Status, arg.ID)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Platform,
		&i.Status,
		&i.Description,
		&i.NetworkID,
		&i.Config,
		&i.Resources,
		&i.Endpoint,
		&i.PublicEndpoint,
		&i.P2pAddress,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.FabricOrganizationID,
		&i.NodeType,
		&i.NodeConfig,
		&i.DeploymentConfig,
	)
	return i, err
}

const updateNotificationProvider = `-- name: UpdateNotificationProvider :one
UPDATE notification_providers
SET type = ?,
    name = ?,
    config = ?,
    is_default = ?,
    notify_node_downtime = ?,
    notify_backup_success = ?,
    notify_backup_failure = ?,
    notify_s3_connection_issue = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, type, config, is_default, is_enabled, created_at, updated_at, notify_node_downtime, notify_backup_success, notify_backup_failure, notify_s3_connection_issue, last_test_at, last_test_status, last_test_message
`

type UpdateNotificationProviderParams struct {
	Type                    string `json:"type"`
	Name                    string `json:"name"`
	Config                  string `json:"config"`
	IsDefault               bool   `json:"is_default"`
	NotifyNodeDowntime      bool   `json:"notify_node_downtime"`
	NotifyBackupSuccess     bool   `json:"notify_backup_success"`
	NotifyBackupFailure     bool   `json:"notify_backup_failure"`
	NotifyS3ConnectionIssue bool   `json:"notify_s3_connection_issue"`
	ID                      int64  `json:"id"`
}

func (q *Queries) UpdateNotificationProvider(ctx context.Context, arg UpdateNotificationProviderParams) (NotificationProvider, error) {
	row := q.queryRow(ctx, q.updateNotificationProviderStmt, updateNotificationProvider,
		arg.Type,
		arg.Name,
		arg.Config,
		arg.IsDefault,
		arg.NotifyNodeDowntime,
		arg.NotifyBackupSuccess,
		arg.NotifyBackupFailure,
		arg.NotifyS3ConnectionIssue,
		arg.ID,
	)
	var i NotificationProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Config,
		&i.IsDefault,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotifyNodeDowntime,
		&i.NotifyBackupSuccess,
		&i.NotifyBackupFailure,
		&i.NotifyS3ConnectionIssue,
		&i.LastTestAt,
		&i.LastTestStatus,
		&i.LastTestMessage,
	)
	return i, err
}

const updateOrganizationCRL = `-- name: UpdateOrganizationCRL :exec
UPDATE fabric_organizations
SET crl_last_update = ?,
    crl_key_id = ?
WHERE id = ?
`

type UpdateOrganizationCRLParams struct {
	CrlLastUpdate sql.NullTime  `json:"crl_last_update"`
	CrlKeyID      sql.NullInt64 `json:"crl_key_id"`
	ID            int64         `json:"id"`
}

func (q *Queries) UpdateOrganizationCRL(ctx context.Context, arg UpdateOrganizationCRLParams) error {
	_, err := q.exec(ctx, q.updateOrganizationCRLStmt, updateOrganizationCRL, arg.CrlLastUpdate, arg.CrlKeyID, arg.ID)
	return err
}

const updateProviderTestResults = `-- name: UpdateProviderTestResults :one
UPDATE notification_providers
SET last_test_at = ?,
    last_test_status = ?,
    last_test_message = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, type, config, is_default, is_enabled, created_at, updated_at, notify_node_downtime, notify_backup_success, notify_backup_failure, notify_s3_connection_issue, last_test_at, last_test_status, last_test_message
`

type UpdateProviderTestResultsParams struct {
	LastTestAt      sql.NullTime   `json:"last_test_at"`
	LastTestStatus  sql.NullString `json:"last_test_status"`
	LastTestMessage sql.NullString `json:"last_test_message"`
	ID              int64          `json:"id"`
}

func (q *Queries) UpdateProviderTestResults(ctx context.Context, arg UpdateProviderTestResultsParams) (NotificationProvider, error) {
	row := q.queryRow(ctx, q.updateProviderTestResultsStmt, updateProviderTestResults,
		arg.LastTestAt,
		arg.LastTestStatus,
		arg.LastTestMessage,
		arg.ID,
	)
	var i NotificationProvider
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Config,
		&i.IsDefault,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NotifyNodeDowntime,
		&i.NotifyBackupSuccess,
		&i.NotifyBackupFailure,
		&i.NotifyS3ConnectionIssue,
		&i.LastTestAt,
		&i.LastTestStatus,
		&i.LastTestMessage,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET username = ?,
    password = CASE WHEN ? IS NOT NULL THEN ? ELSE password END,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, username, password, name, email, role, provider, provider_id, avatar_url, created_at, last_login_at, updated_at
`

type UpdateUserParams struct {
	Username string      `json:"username"`
	Column2  interface{} `json:"column_2"`
	Password string      `json:"password"`
	ID       int64       `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.queryRow(ctx, q.updateUserStmt, updateUser,
		arg.Username,
		arg.Column2,
		arg.Password,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Name,
		&i.Email,
		&i.Role,
		&i.Provider,
		&i.ProviderID,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.LastLoginAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserLastLogin = `-- name: UpdateUserLastLogin :one
UPDATE users
SET last_login_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, username, password, name, email, role, provider, provider_id, avatar_url, created_at, last_login_at, updated_at
`

func (q *Queries) UpdateUserLastLogin(ctx context.Context, id int64) (User, error) {
	row := q.queryRow(ctx, q.updateUserLastLoginStmt, updateUserLastLogin, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.Name,
		&i.Email,
		&i.Role,
		&i.Provider,
		&i.ProviderID,
		&i.AvatarUrl,
		&i.CreatedAt,
		&i.LastLoginAt,
		&i.UpdatedAt,
	)
	return i, err
}
